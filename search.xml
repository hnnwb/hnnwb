<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>rabbitmq</title>
      <link href="2022/02/13/rabbitmq/"/>
      <url>2022/02/13/rabbitmq/</url>
      
        <content type="html"><![CDATA[<h2 id="1-rabbitmq-Liuux安装"><a href="#1-rabbitmq-Liuux安装" class="headerlink" title="1.rabbitmq-Liuux安装"></a>1.rabbitmq-Liuux安装</h2><h3 id="1-安装依赖环境"><a href="#1-安装依赖环境" class="headerlink" title="1. 安装依赖环境"></a>1. 安装依赖环境</h3><p>在线安装依赖环境：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz</span><br></pre></td></tr></table></figure><h3 id="2-安装Erlang"><a href="#2-安装Erlang" class="headerlink" title="2.安装Erlang"></a>2.安装Erlang</h3><p>上传安装包</p><p>erlang-18.3-1.el7.centos.x86_64.rpm<br>socat-1.7.3.2-5.el7.lux.x86_64.rpm<br>rabbitmq-server-3.6.5-1.noarch.rpm</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">rpm -ivh erlang-18.3-1.el7.centos.x86_64.rpm</span><br></pre></td></tr></table></figure><p>如果出现如下错误</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/rabbitmq/202202132308890.png" alt="image-20220213230749467"></p><p>说明gblic 版本太低。我们可以查看当前机器的gblic 版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strings /lib64/libc.so.6 | grep GLIBC</span><br></pre></td></tr></table></figure><p>当前最高版本2.12，需要2.15.所以需要升级glibc</p><p>使用yum更新安装依赖</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make -y</span><br></pre></td></tr></table></figure><p>下载rpm包</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-utils-2.17-55.el6.x86_64.rpm &amp;</span><br><span class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-static-2.17-55.el6.x86_64.rpm &amp;</span><br><span class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-2.17-55.el6.x86_64.rpm &amp;</span><br><span class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-common-2.17-55.el6.x86_64.rpm &amp;</span><br><span class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-devel-2.17-55.el6.x86_64.rpm &amp;</span><br><span class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-headers-2.17-55.el6.x86_64.rpm &amp;</span><br><span class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/nscd-2.17-55.el6.x86_64.rpm &amp;</span><br></pre></td></tr></table></figure><p>安装rpm包</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rpm -Uvh *-2.17-55.el6.x86_64.rpm --force --nodeps</span><br></pre></td></tr></table></figure><p>安装完毕后再查看glibc版本,发现glibc版本已经到2.17了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strings /lib64/libc.so.6 | grep GLIBC</span><br></pre></td></tr></table></figure><h3 id="3-安装RabbitMQ"><a href="#3-安装RabbitMQ" class="headerlink" title="3.安装RabbitMQ"></a>3.安装RabbitMQ</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">rpm -ivh socat-1.7.3.2-5.el7.lux.x86_64.rpm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">rpm -ivh rabbitmq-server-3.6.5-1.noarch.rpm</span><br></pre></td></tr></table></figure><h3 id="4-开启管理界面及配置"><a href="#4-开启管理界面及配置" class="headerlink" title="4. 开启管理界面及配置"></a>4. 开启管理界面及配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启管理界面</span></span><br><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改默认配置信息</span></span><br><span class="line">vim /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin/rabbit.app </span><br><span class="line"><span class="meta">#</span><span class="bash"> 比如修改密码、配置等等，例如：loopback_users 中的 &lt;&lt;<span class="string">&quot;guest&quot;</span>&gt;&gt;,只保留guest</span></span><br></pre></td></tr></table></figure><h3 id="5-常用命令"><a href="#5-常用命令" class="headerlink" title="5. 常用命令"></a>5. 常用命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service rabbitmq-server start # 启动服务</span><br><span class="line">service rabbitmq-server stop # 停止服务</span><br><span class="line">service rabbitmq-server restart # 重启服务</span><br><span class="line">service rabbitmq-server status #查看状态</span><br><span class="line">chkconfig rabbitmq-server on #设置开机启动</span><br><span class="line">rabbitmq-plugins enable rabbitmq_management#开启控制台</span><br><span class="line">rabbitmq-plugins disable rabbitmq_management#关闭控制台</span><br></pre></td></tr></table></figure><h3 id="6-配置虚拟主机及用户"><a href="#6-配置虚拟主机及用户" class="headerlink" title="6. 配置虚拟主机及用户"></a>6. 配置虚拟主机及用户</h3><h4 id="6-1-用户角色"><a href="#6-1-用户角色" class="headerlink" title="6.1. 用户角色"></a>6.1. 用户角色</h4><p>RabbitMQ在安装好后，可以访问<code>http://ip地址:15672</code> ；其自带了guest/guest的用户名和密码；如果需要创建自定义用户；那么也可以登录管理界面后，如下操作：</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/rabbitmq/202202132308892.png" alt="image-20220213202249490"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/rabbitmq/202202132308893.png" alt="image-20220213202300735"></p><p><strong>角色说明</strong>：</p><p>1、 超级管理员(administrator)</p><p>可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</p><p>2、 监控者(monitoring)</p><p>可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</p><p>3、 策略制定者(policymaker)</p><p>可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。</p><p>4、 普通管理者(management)</p><p>仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。</p><p>5、 其他</p><p>无法登陆管理控制台，通常就是普通的生产者和消费者。</p><h4 id="6-2-Virtual-Hosts配置"><a href="#6-2-Virtual-Hosts配置" class="headerlink" title="6.2. Virtual Hosts配置"></a>6.2. Virtual Hosts配置</h4><p>像mysql拥有数据库的概念并且可以指定用户对库和表等操作的权限。RabbitMQ也有类似的权限管理；在RabbitMQ中可以虚拟消息服务器Virtual Host，每个Virtual Hosts相当于一个相对独立的RabbitMQ服务器，每个VirtualHost之间是相互隔离的。exchange、queue、message不能互通。 相当于mysql的db。Virtual Name一般以/开头。</p><h5 id="6-2-1-创建Virtual-Hosts"><a href="#6-2-1-创建Virtual-Hosts" class="headerlink" title="6.2.1. 创建Virtual Hosts"></a>6.2.1. 创建Virtual Hosts</h5><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/rabbitmq/202202132308894.png" alt="image-20220213202334601"></p><h5 id="6-2-2-设置Virtual-Hosts权限"><a href="#6-2-2-设置Virtual-Hosts权限" class="headerlink" title="6.2.2. 设置Virtual Hosts权限"></a>6.2.2. 设置Virtual Hosts权限</h5><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/rabbitmq/202202132308895.png" alt="image-20220213202347090"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/rabbitmq/202202132308896.png" alt="image-20220213202355763"></p><h3 id="7-MQ配置文件"><a href="#7-MQ配置文件" class="headerlink" title="7.MQ配置文件"></a>7.MQ配置文件</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/rabbitmq/202202132308897.png" alt="image-20220213202418617"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/share/doc/rabbitmq-server-3.6.5/</span><br><span class="line">rabbitmq.config.example</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拷贝过去并改名</span></span><br><span class="line">cp rabbitmq.config.example /etc/rabbitmq/rabbitmq.config</span><br><span class="line"><span class="meta">#</span><span class="bash">重启</span></span><br><span class="line">service rabbitmq-server restart</span><br></pre></td></tr></table></figure><h2 id="2-rabbitmq"><a href="#2-rabbitmq" class="headerlink" title="2.rabbitmq"></a>2.rabbitmq</h2><h3 id="1-rabbitmq-快速入门"><a href="#1-rabbitmq-快速入门" class="headerlink" title="1.rabbitmq-快速入门"></a>1.rabbitmq-快速入门</h3><p>创建服务生产者和消费者，引入pom文件配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.rabbitmq&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;amqp-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;5.6.0&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">   &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">   &lt;build&gt;</span><br><span class="line">       &lt;plugins&gt;</span><br><span class="line">           &lt;plugin&gt;</span><br><span class="line">               &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">               &lt;version&gt;3.8.0&lt;&#x2F;version&gt;</span><br><span class="line">               &lt;configuration&gt;</span><br><span class="line">                   &lt;source&gt;1.8&lt;&#x2F;source&gt;</span><br><span class="line">                   &lt;target&gt;1.8&lt;&#x2F;target&gt;</span><br><span class="line">               &lt;&#x2F;configuration&gt;</span><br><span class="line">           &lt;&#x2F;plugin&gt;</span><br><span class="line">       &lt;&#x2F;plugins&gt;</span><br><span class="line">   &lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure><p>生产者发送消息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/02/13/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:发送消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerHello</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.链接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//2 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.50.128&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//3 创建链接 Connection</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//4 创建Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//5 创建队列Queue</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * String queue,队列</span></span><br><span class="line"><span class="comment">         * boolean durable,是否持久化当mq重启之后，还在</span></span><br><span class="line"><span class="comment">         * boolean exclusive,是否独占，只能有一个消费者监听这队列，当connection关闭时是否删除队列</span></span><br><span class="line"><span class="comment">         * boolean autoDelete,是否自动删除，当没有消费者时自动删除</span></span><br><span class="line"><span class="comment">         * Map&lt;String, Object&gt; arguments 参数</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;hello_mq&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//6 发送消息</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * String exchange,交换机，简单模式下会使用默认“”</span></span><br><span class="line"><span class="comment">         * String routingKey,路由名称</span></span><br><span class="line"><span class="comment">         * BasicProperties props, 配置信息</span></span><br><span class="line"><span class="comment">         * byte[] body 发送消息数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String body = <span class="string">&quot;hello_mq~~~&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>,<span class="string">&quot;hello_mq&quot;</span>,<span class="keyword">null</span>,body.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7 释放资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>消费者监听：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/02/13/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerHello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.链接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//2 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.50.128&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//3 创建链接 Connection</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//4 创建Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//5 创建队列Queue</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * String queue,队列</span></span><br><span class="line"><span class="comment">         * boolean durable,是否持久化当mq重启之后，还在</span></span><br><span class="line"><span class="comment">         * boolean exclusive,是否独占，只能有一个消费者监听这队列，当connection关闭时是否删除队列</span></span><br><span class="line"><span class="comment">         * boolean autoDelete,是否自动删除，当没有消费者时自动删除</span></span><br><span class="line"><span class="comment">         * Map&lt;String, Object&gt; arguments 参数</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;hello_mq&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  String queue,队列名称</span></span><br><span class="line"><span class="comment">         *  boolean autoAck,是否自动确认</span></span><br><span class="line"><span class="comment">         *  Consumer callback 回调对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 回调 收到消息后自动执行该方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> consumerTag 标识</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> envelope 获取一些信息，交换机，路由key。。。</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> properties  配置信息</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> body  数据</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;consumerTag:&quot;</span>+consumerTag);</span><br><span class="line">                System.out.println(<span class="string">&quot;envelope.getExchange:&quot;</span>+envelope.getExchange());</span><br><span class="line">                System.out.println(<span class="string">&quot;envelope.getRoutingKey:&quot;</span>+envelope.getRoutingKey());</span><br><span class="line">                System.out.println(<span class="string">&quot;properties:&quot;</span>+properties);</span><br><span class="line">                System.out.println(<span class="string">&quot;body:&quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(<span class="string">&quot;hello_mq&quot;</span>,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-rabbitmq-工作模式"><a href="#2-rabbitmq-工作模式" class="headerlink" title="2.rabbitmq-工作模式"></a>2.rabbitmq-工作模式</h3><h4 id="1-work-queues-工作队列模式"><a href="#1-work-queues-工作队列模式" class="headerlink" title="1.work queues 工作队列模式"></a>1.work queues 工作队列模式</h4><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/rabbitmq/202202132308898.png" alt="image-20220213204939753"></p><p>创建生产者发布消息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/02/13/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:发送消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerWorkQueues</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.链接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//2 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.50.128&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//3 创建链接 Connection</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//4 创建Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//5 创建队列Queue</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * String queue,队列</span></span><br><span class="line"><span class="comment">         * boolean durable,是否持久化当mq重启之后，还在</span></span><br><span class="line"><span class="comment">         * boolean exclusive,是否独占，只能有一个消费者监听这队列，当connection关闭时是否删除队列</span></span><br><span class="line"><span class="comment">         * boolean autoDelete,是否自动删除，当没有消费者时自动删除</span></span><br><span class="line"><span class="comment">         * Map&lt;String, Object&gt; arguments 参数</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;work_queues&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//6 发送消息</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * String exchange,交换机，简单模式下会使用默认“”</span></span><br><span class="line"><span class="comment">         * String routingKey,路由名称</span></span><br><span class="line"><span class="comment">         * BasicProperties props, 配置信息</span></span><br><span class="line"><span class="comment">         * byte[] body 发送消息数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            String body = i+<span class="string">&quot;hello_mq~~~&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;work_queues&quot;</span>, <span class="keyword">null</span>, body.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7 释放资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建两个消费者监听消息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/02/13/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerWorkQueues1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.链接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//2 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.50.128&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//3 创建链接 Connection</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//4 创建Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//5 创建队列Queue</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * String queue,队列</span></span><br><span class="line"><span class="comment">         * boolean durable,是否持久化当mq重启之后，还在</span></span><br><span class="line"><span class="comment">         * boolean exclusive,是否独占，只能有一个消费者监听这队列，当connection关闭时是否删除队列</span></span><br><span class="line"><span class="comment">         * boolean autoDelete,是否自动删除，当没有消费者时自动删除</span></span><br><span class="line"><span class="comment">         * Map&lt;String, Object&gt; arguments 参数</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;work_queues&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  String queue,队列名称</span></span><br><span class="line"><span class="comment">         *  boolean autoAck,是否自动确认</span></span><br><span class="line"><span class="comment">         *  Consumer callback 回调对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 回调 收到消息后自动执行该方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> consumerTag 标识</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> envelope 获取一些信息，交换机，路由key。。。</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> properties  配置信息</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> body  数据</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//System.out.println(&quot;consumerTag:&quot;+consumerTag);</span></span><br><span class="line">                <span class="comment">//System.out.println(&quot;envelope.getExchange:&quot;+envelope.getExchange());</span></span><br><span class="line">                <span class="comment">//System.out.println(&quot;envelope.getRoutingKey:&quot;+envelope.getRoutingKey());</span></span><br><span class="line">                <span class="comment">//System.out.println(&quot;properties:&quot;+properties);</span></span><br><span class="line">                System.out.println(<span class="string">&quot;body:&quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(<span class="string">&quot;work_queues&quot;</span>,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/02/13/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerWorkQueues2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.链接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//2 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.50.128&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//3 创建链接 Connection</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//4 创建Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//5 创建队列Queue</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * String queue,队列</span></span><br><span class="line"><span class="comment">         * boolean durable,是否持久化当mq重启之后，还在</span></span><br><span class="line"><span class="comment">         * boolean exclusive,是否独占，只能有一个消费者监听这队列，当connection关闭时是否删除队列</span></span><br><span class="line"><span class="comment">         * boolean autoDelete,是否自动删除，当没有消费者时自动删除</span></span><br><span class="line"><span class="comment">         * Map&lt;String, Object&gt; arguments 参数</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;work_queues&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  String queue,队列名称</span></span><br><span class="line"><span class="comment">         *  boolean autoAck,是否自动确认</span></span><br><span class="line"><span class="comment">         *  Consumer callback 回调对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 回调 收到消息后自动执行该方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> consumerTag 标识</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> envelope 获取一些信息，交换机，路由key。。。</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> properties  配置信息</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> body  数据</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//System.out.println(&quot;consumerTag:&quot;+consumerTag);</span></span><br><span class="line">                <span class="comment">//System.out.println(&quot;envelope.getExchange:&quot;+envelope.getExchange());</span></span><br><span class="line">                <span class="comment">//System.out.println(&quot;envelope.getRoutingKey:&quot;+envelope.getRoutingKey());</span></span><br><span class="line">                <span class="comment">//System.out.println(&quot;properties:&quot;+properties);</span></span><br><span class="line">                System.out.println(<span class="string">&quot;body:&quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(<span class="string">&quot;work_queues&quot;</span>,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>他们会分别监听到消息</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/rabbitmq/202202132308899.png" alt="image-20220213205652076"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/rabbitmq/202202132308900.png" alt="image-20220213205659723"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/rabbitmq/202202132308901.png" alt="image-20220213205810664"></p><h4 id="2-pub-sub订阅模式"><a href="#2-pub-sub订阅模式" class="headerlink" title="2.pub/sub订阅模式"></a>2.pub/sub订阅模式</h4><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/rabbitmq/202202132308902.png" alt="image-20220213205934627"></p><p>创建生产者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/02/13/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:发送消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerPubSub</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.链接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//2 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.50.128&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//3 创建链接 Connection</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//4 创建Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> exchange 交换机名称</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> type 类型</span></span><br><span class="line"><span class="comment">            * DIRECT(&quot;direct&quot;)定向,</span></span><br><span class="line"><span class="comment">            * FANOUT(&quot;fanout&quot;)扇形,发送消息到每个绑定的队列</span></span><br><span class="line"><span class="comment">             * TOPIC(&quot;topic&quot;),通配符的方式</span></span><br><span class="line"><span class="comment">             * HEADERS(&quot;headers&quot;);参数匹配</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> durable 是否持久化</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> autoDelete 自动删除</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> internal 内部使用，一般为false</span></span><br><span class="line"><span class="comment">         * published to by a client.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> arguments 参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//5 创建交换机</span></span><br><span class="line">        String exchangeName=<span class="string">&quot;test_fanout&quot;</span>;</span><br><span class="line">        channel.exchangeDeclare(exchangeName, BuiltinExchangeType.FANOUT,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//6 创建队列Queue</span></span><br><span class="line">        String queue1Name = <span class="string">&quot;test_fanout_queue1&quot;</span>;</span><br><span class="line">        String queue2Name = <span class="string">&quot;test_fanout_queue2&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queue1Name,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        channel.queueDeclare(queue2Name,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//7 绑定队列和交换机</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * String queue,队列</span></span><br><span class="line"><span class="comment">         * String exchange,交换机</span></span><br><span class="line"><span class="comment">         * String routingKey,路由键，绑定规则</span></span><br><span class="line"><span class="comment">         *      如果交换机类型fanout 则设置“”</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueBind(queue1Name,exchangeName,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        channel.queueBind(queue2Name,exchangeName,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//8 发送消息</span></span><br><span class="line">        String body = <span class="string">&quot;调用findall消息===&quot;</span>;</span><br><span class="line">        channel.basicPublish(exchangeName,<span class="string">&quot;&quot;</span>,<span class="keyword">null</span>,body.getBytes());</span><br><span class="line">        <span class="comment">//9 释放资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>消费者1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/02/13/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerPubSub1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.链接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//2 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.50.128&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//3 创建链接 Connection</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//4 创建Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//5 创建队列Queue</span></span><br><span class="line">        String queue1Name = <span class="string">&quot;test_fanout_queue1&quot;</span>;</span><br><span class="line">        String queue2Name = <span class="string">&quot;test_fanout_queue2&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  String queue,队列名称</span></span><br><span class="line"><span class="comment">         *  boolean autoAck,是否自动确认</span></span><br><span class="line"><span class="comment">         *  Consumer callback 回调对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 回调 收到消息后自动执行该方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> consumerTag 标识</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> envelope 获取一些信息，交换机，路由key。。。</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> properties  配置信息</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> body  数据</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//System.out.println(&quot;consumerTag:&quot;+consumerTag);</span></span><br><span class="line">                <span class="comment">//System.out.println(&quot;envelope.getExchange:&quot;+envelope.getExchange());</span></span><br><span class="line">                <span class="comment">//System.out.println(&quot;envelope.getRoutingKey:&quot;+envelope.getRoutingKey());</span></span><br><span class="line">                <span class="comment">//System.out.println(&quot;properties:&quot;+properties);</span></span><br><span class="line">                System.out.println(<span class="string">&quot;body:&quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">                System.out.println(<span class="string">&quot;日志信息打印到控制台---&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queue1Name,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>消费者2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/02/13/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerPubSub2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.链接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//2 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.50.128&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//3 创建链接 Connection</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//4 创建Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//5 创建队列Queue</span></span><br><span class="line">        String queue1Name = <span class="string">&quot;test_fanout_queue1&quot;</span>;</span><br><span class="line">        String queue2Name = <span class="string">&quot;test_fanout_queue2&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  String queue,队列名称</span></span><br><span class="line"><span class="comment">         *  boolean autoAck,是否自动确认</span></span><br><span class="line"><span class="comment">         *  Consumer callback 回调对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 回调 收到消息后自动执行该方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> consumerTag 标识</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> envelope 获取一些信息，交换机，路由key。。。</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> properties  配置信息</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> body  数据</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//System.out.println(&quot;consumerTag:&quot;+consumerTag);</span></span><br><span class="line">                <span class="comment">//System.out.println(&quot;envelope.getExchange:&quot;+envelope.getExchange());</span></span><br><span class="line">                <span class="comment">//System.out.println(&quot;envelope.getRoutingKey:&quot;+envelope.getRoutingKey());</span></span><br><span class="line">                <span class="comment">//System.out.println(&quot;properties:&quot;+properties);</span></span><br><span class="line">                System.out.println(<span class="string">&quot;body:&quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">                System.out.println(<span class="string">&quot;日志信息保存数据库---&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queue2Name,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-routing路由模式"><a href="#3-routing路由模式" class="headerlink" title="3.routing路由模式"></a>3.routing路由模式</h4><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/rabbitmq/202202132308903.png" alt="image-20220213212742746"></p><p>创建生产者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/02/13/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:发送消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerRouting</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.链接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//2 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.50.128&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//3 创建链接 Connection</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//4 创建Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> exchange 交换机名称</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> type 类型</span></span><br><span class="line"><span class="comment">            * DIRECT(&quot;direct&quot;)定向,</span></span><br><span class="line"><span class="comment">            * FANOUT(&quot;fanout&quot;)扇形,发送消息到每个绑定的队列</span></span><br><span class="line"><span class="comment">             * TOPIC(&quot;topic&quot;),通配符的方式</span></span><br><span class="line"><span class="comment">             * HEADERS(&quot;headers&quot;);参数匹配</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> durable 是否持久化</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> autoDelete 自动删除</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> internal 内部使用，一般为false</span></span><br><span class="line"><span class="comment">         * published to by a client.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> arguments 参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//5 创建交换机</span></span><br><span class="line">        String exchangeName=<span class="string">&quot;test_direct&quot;</span>;</span><br><span class="line">        channel.exchangeDeclare(exchangeName, BuiltinExchangeType.DIRECT,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//6 创建队列Queue</span></span><br><span class="line">        String queue1Name = <span class="string">&quot;test_direct_queue1&quot;</span>;</span><br><span class="line">        String queue2Name = <span class="string">&quot;test_direct_queue2&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queue1Name,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        channel.queueDeclare(queue2Name,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//7 绑定队列和交换机</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * String queue,队列</span></span><br><span class="line"><span class="comment">         * String exchange,交换机</span></span><br><span class="line"><span class="comment">         * String routingKey,路由键，绑定规则</span></span><br><span class="line"><span class="comment">         *      如果交换机类型fanout 则设置“”</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//队列1</span></span><br><span class="line">        channel.queueBind(queue1Name,exchangeName,<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="comment">//队列2</span></span><br><span class="line">        channel.queueBind(queue2Name,exchangeName,<span class="string">&quot;info&quot;</span>);</span><br><span class="line">        channel.queueBind(queue2Name,exchangeName,<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        channel.queueBind(queue2Name,exchangeName,<span class="string">&quot;warning&quot;</span>);</span><br><span class="line">        <span class="comment">//8 发送消息</span></span><br><span class="line">        String body = <span class="string">&quot;调用findall消息===&quot;</span>;</span><br><span class="line">        channel.basicPublish(exchangeName,<span class="string">&quot;error&quot;</span>,<span class="keyword">null</span>,body.getBytes());</span><br><span class="line">        <span class="comment">//9 释放资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建消费者1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/02/13/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerRouting1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.链接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//2 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.50.128&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//3 创建链接 Connection</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//4 创建Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//5 创建队列Queue</span></span><br><span class="line">        String queue1Name = <span class="string">&quot;test_direct_queue1&quot;</span>;</span><br><span class="line">        String queue2Name = <span class="string">&quot;test_direct_queue2&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  String queue,队列名称</span></span><br><span class="line"><span class="comment">         *  boolean autoAck,是否自动确认</span></span><br><span class="line"><span class="comment">         *  Consumer callback 回调对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 回调 收到消息后自动执行该方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> consumerTag 标识</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> envelope 获取一些信息，交换机，路由key。。。</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> properties  配置信息</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> body  数据</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//System.out.println(&quot;consumerTag:&quot;+consumerTag);</span></span><br><span class="line">                <span class="comment">//System.out.println(&quot;envelope.getExchange:&quot;+envelope.getExchange());</span></span><br><span class="line">                <span class="comment">//System.out.println(&quot;envelope.getRoutingKey:&quot;+envelope.getRoutingKey());</span></span><br><span class="line">                <span class="comment">//System.out.println(&quot;properties:&quot;+properties);</span></span><br><span class="line">                System.out.println(<span class="string">&quot;body:&quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">                System.out.println(<span class="string">&quot;日志信息打印到控制台---&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queue1Name,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/02/13/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerRouting2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.链接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//2 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.50.128&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//3 创建链接 Connection</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//4 创建Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//5 创建队列Queue</span></span><br><span class="line">        String queue1Name = <span class="string">&quot;test_direct_queue1&quot;</span>;</span><br><span class="line">        String queue2Name = <span class="string">&quot;test_direct_queue2&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  String queue,队列名称</span></span><br><span class="line"><span class="comment">         *  boolean autoAck,是否自动确认</span></span><br><span class="line"><span class="comment">         *  Consumer callback 回调对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 回调 收到消息后自动执行该方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> consumerTag 标识</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> envelope 获取一些信息，交换机，路由key。。。</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> properties  配置信息</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> body  数据</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//System.out.println(&quot;consumerTag:&quot;+consumerTag);</span></span><br><span class="line">                <span class="comment">//System.out.println(&quot;envelope.getExchange:&quot;+envelope.getExchange());</span></span><br><span class="line">                <span class="comment">//System.out.println(&quot;envelope.getRoutingKey:&quot;+envelope.getRoutingKey());</span></span><br><span class="line">                <span class="comment">//System.out.println(&quot;properties:&quot;+properties);</span></span><br><span class="line">                System.out.println(<span class="string">&quot;body:&quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">                System.out.println(<span class="string">&quot;日志信息存到数据库---&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queue2Name,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/rabbitmq/202202132308904.png" alt="image-20220213213707213"></p><h4 id="4-topics通配符模式"><a href="#4-topics通配符模式" class="headerlink" title="4.topics通配符模式"></a>4.topics通配符模式</h4><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/rabbitmq/202202132308905.png" alt="image-20220213213752368"></p><p>通配符*代表一个单词 #代表多个单词</p><p>创建生产者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/02/13/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:发送消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerTopic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.链接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//2 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.50.128&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//3 创建链接 Connection</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//4 创建Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> exchange 交换机名称</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> type 类型</span></span><br><span class="line"><span class="comment">            * DIRECT(&quot;direct&quot;)定向,</span></span><br><span class="line"><span class="comment">            * FANOUT(&quot;fanout&quot;)扇形,发送消息到每个绑定的队列</span></span><br><span class="line"><span class="comment">             * TOPIC(&quot;topic&quot;),通配符的方式</span></span><br><span class="line"><span class="comment">             * HEADERS(&quot;headers&quot;);参数匹配</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> durable 是否持久化</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> autoDelete 自动删除</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> internal 内部使用，一般为false</span></span><br><span class="line"><span class="comment">         * published to by a client.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> arguments 参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//5 创建交换机</span></span><br><span class="line">        String exchangeName=<span class="string">&quot;test_topic&quot;</span>;</span><br><span class="line">        channel.exchangeDeclare(exchangeName, BuiltinExchangeType.TOPIC,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//6 创建队列Queue</span></span><br><span class="line">        String queue1Name = <span class="string">&quot;test_topic_queue1&quot;</span>;</span><br><span class="line">        String queue2Name = <span class="string">&quot;test_topic_queue2&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queue1Name,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        channel.queueDeclare(queue2Name,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//7 绑定队列和交换机</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * String queue,队列</span></span><br><span class="line"><span class="comment">         * String exchange,交换机</span></span><br><span class="line"><span class="comment">         * String routingKey,路由键，绑定规则</span></span><br><span class="line"><span class="comment">         *      如果交换机类型fanout 则设置“”</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//队列1</span></span><br><span class="line">        <span class="comment">//所有error和order级别的日志都存入数据库</span></span><br><span class="line">        channel.queueBind(queue1Name,exchangeName,<span class="string">&quot;#.error&quot;</span>);</span><br><span class="line">        channel.queueBind(queue1Name,exchangeName,<span class="string">&quot;order.*&quot;</span>);</span><br><span class="line">        <span class="comment">//队列2</span></span><br><span class="line">        <span class="comment">//所有信息都打印控制台</span></span><br><span class="line">        channel.queueBind(queue2Name,exchangeName,<span class="string">&quot;*.*&quot;</span>);</span><br><span class="line">        <span class="comment">//8 发送消息</span></span><br><span class="line">        String body = <span class="string">&quot;调用findall消息===&quot;</span>;</span><br><span class="line">        channel.basicPublish(exchangeName,<span class="string">&quot;order.info&quot;</span>,<span class="keyword">null</span>,body.getBytes());</span><br><span class="line">        <span class="comment">//9 释放资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建两个消费者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/02/13/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerTopic1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.链接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//2 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.50.128&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//3 创建链接 Connection</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//4 创建Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//5 创建队列Queue</span></span><br><span class="line">        String queue1Name = <span class="string">&quot;test_topic_queue1&quot;</span>;</span><br><span class="line">        String queue2Name = <span class="string">&quot;test_topic_queue2&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  String queue,队列名称</span></span><br><span class="line"><span class="comment">         *  boolean autoAck,是否自动确认</span></span><br><span class="line"><span class="comment">         *  Consumer callback 回调对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 回调 收到消息后自动执行该方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> consumerTag 标识</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> envelope 获取一些信息，交换机，路由key。。。</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> properties  配置信息</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> body  数据</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//System.out.println(&quot;consumerTag:&quot;+consumerTag);</span></span><br><span class="line">                <span class="comment">//System.out.println(&quot;envelope.getExchange:&quot;+envelope.getExchange());</span></span><br><span class="line">                <span class="comment">//System.out.println(&quot;envelope.getRoutingKey:&quot;+envelope.getRoutingKey());</span></span><br><span class="line">                <span class="comment">//System.out.println(&quot;properties:&quot;+properties);</span></span><br><span class="line">                System.out.println(<span class="string">&quot;body:&quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">                System.out.println(<span class="string">&quot;日志信息存入数据库---&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queue1Name,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/02/13/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerTopic2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.链接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//2 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.50.128&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//3 创建链接 Connection</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//4 创建Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//5 创建队列Queue</span></span><br><span class="line">        String queue1Name = <span class="string">&quot;test_topic_queue1&quot;</span>;</span><br><span class="line">        String queue2Name = <span class="string">&quot;test_topic_queue2&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  String queue,队列名称</span></span><br><span class="line"><span class="comment">         *  boolean autoAck,是否自动确认</span></span><br><span class="line"><span class="comment">         *  Consumer callback 回调对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 回调 收到消息后自动执行该方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> consumerTag 标识</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> envelope 获取一些信息，交换机，路由key。。。</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> properties  配置信息</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> body  数据</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//System.out.println(&quot;consumerTag:&quot;+consumerTag);</span></span><br><span class="line">                <span class="comment">//System.out.println(&quot;envelope.getExchange:&quot;+envelope.getExchange());</span></span><br><span class="line">                <span class="comment">//System.out.println(&quot;envelope.getRoutingKey:&quot;+envelope.getRoutingKey());</span></span><br><span class="line">                <span class="comment">//System.out.println(&quot;properties:&quot;+properties);</span></span><br><span class="line">                System.out.println(<span class="string">&quot;body:&quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">                System.out.println(<span class="string">&quot;日志信息打印到控制台---&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queue2Name,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/rabbitmq/202202132308906.png" alt="image-20220213215025825"></p><h3 id="3-工作模式总结"><a href="#3-工作模式总结" class="headerlink" title="3.工作模式总结"></a>3.工作模式总结</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/rabbitmq/202202132308907.png" alt="image-20220213215109234"></p><h2 id="3-spring整合rabbitmq"><a href="#3-spring整合rabbitmq" class="headerlink" title="3.spring整合rabbitmq"></a>3.spring整合rabbitmq</h2><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/rabbitmq/202202132308908.png" alt="image-20220213215227632"></p><p>生产者创建：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.itcast&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-rabbitmq-producer&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;8&lt;&#x2F;maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;8&lt;&#x2F;maven.compiler.target&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.7.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.amqp&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-rabbit&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.1.8.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.7.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.8.0&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;1.8&lt;&#x2F;source&gt;</span><br><span class="line">                    &lt;target&gt;1.8&lt;&#x2F;target&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><p>创建配置文件rabbitmq.properties和spring-rabbitmq-producer.xml</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">rabbitmq.host=192.168.50.128</span></span><br><span class="line"><span class="string">rabbitmq.port=5672</span></span><br><span class="line"><span class="string">rabbitmq.username=admin</span></span><br><span class="line"><span class="string">rabbitmq.password=admin</span></span><br><span class="line"><span class="string">rabbitmq.virtual-host=/itcast</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:rabbit</span>=<span class="string">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">host</span>=<span class="string">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">port</span>=<span class="string">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">username</span>=<span class="string">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">password</span>=<span class="string">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">virtual-host</span>=<span class="string">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义管理交换机、队列--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--定义持久化队列，不存在则自动创建；不绑定到交换机则绑定到默认交换机</span></span><br><span class="line"><span class="comment">    默认交换机类型为direct，名字为：&quot;&quot;，路由键为队列的名称</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">id</span>=<span class="string">&quot;spring_queue&quot;</span> <span class="attr">name</span>=<span class="string">&quot;spring_queue&quot;</span> <span class="attr">auto-declare</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~广播；所有队列都能收到消息~~~~~~~~~~~~~~~~~~~~~~~~~~~~ --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义广播交换机中的持久化队列，不存在则自动创建--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">id</span>=<span class="string">&quot;spring_fanout_queue_1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;spring_fanout_queue_1&quot;</span> <span class="attr">auto-declare</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--定义广播交换机中的持久化队列，不存在则自动创建--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">id</span>=<span class="string">&quot;spring_fanout_queue_2&quot;</span> <span class="attr">name</span>=<span class="string">&quot;spring_fanout_queue_2&quot;</span> <span class="attr">auto-declare</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--定义广播类型交换机；并绑定上述两个队列--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:fanout-exchange</span> <span class="attr">id</span>=<span class="string">&quot;spring_fanout_exchange&quot;</span> <span class="attr">name</span>=<span class="string">&quot;spring_fanout_exchange&quot;</span> <span class="attr">auto-declare</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">queue</span>=<span class="string">&quot;spring_fanout_queue_1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">queue</span>=<span class="string">&quot;spring_fanout_queue_2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:fanout-exchange</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~通配符；*匹配一个单词，#匹配多个单词 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义广播交换机中的持久化队列，不存在则自动创建--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">id</span>=<span class="string">&quot;spring_topic_queue_star&quot;</span> <span class="attr">name</span>=<span class="string">&quot;spring_topic_queue_star&quot;</span> <span class="attr">auto-declare</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义广播交换机中的持久化队列，不存在则自动创建--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">id</span>=<span class="string">&quot;spring_topic_queue_well&quot;</span> <span class="attr">name</span>=<span class="string">&quot;spring_topic_queue_well&quot;</span> <span class="attr">auto-declare</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义广播交换机中的持久化队列，不存在则自动创建--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">id</span>=<span class="string">&quot;spring_topic_queue_well2&quot;</span> <span class="attr">name</span>=<span class="string">&quot;spring_topic_queue_well2&quot;</span> <span class="attr">auto-declare</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:topic-exchange</span> <span class="attr">id</span>=<span class="string">&quot;spring_topic_exchange&quot;</span> <span class="attr">name</span>=<span class="string">&quot;spring_topic_exchange&quot;</span> <span class="attr">auto-declare</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">pattern</span>=<span class="string">&quot;order.*&quot;</span> <span class="attr">queue</span>=<span class="string">&quot;spring_topic_queue_star&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">pattern</span>=<span class="string">&quot;order.#&quot;</span> <span class="attr">queue</span>=<span class="string">&quot;spring_topic_queue_well&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">pattern</span>=<span class="string">&quot;itcast.#&quot;</span> <span class="attr">queue</span>=<span class="string">&quot;spring_topic_queue_well2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:topic-exchange</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--定义rabbitTemplate对象操作可以在代码中方便发送消息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">&quot;rabbitTemplate&quot;</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建测试类发送消息:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/02/13/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-producer.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入rabbitTemplate</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHellomq</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;spring_queue&quot;</span>,<span class="string">&quot;hello_mq_spring------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFanout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;spring_fanout_exchange&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;spring---fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTopic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;spring_topic_exchange&quot;</span>,<span class="string">&quot;order.hehe&quot;</span>,<span class="string">&quot;spring---topic&quot;</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;spring_topic_exchange&quot;</span>,<span class="string">&quot;order.hehe.haha&quot;</span>,<span class="string">&quot;spring---topic&quot;</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;spring_topic_exchange&quot;</span>,<span class="string">&quot;itcast.haha&quot;</span>,<span class="string">&quot;spring---topic&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建消费者：</p><p>配置文件：rabbitmq.properties和spring-rabbitmq-consumer.xml</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">rabbitmq.host=192.168.50.128</span></span><br><span class="line"><span class="string">rabbitmq.port=5672</span></span><br><span class="line"><span class="string">rabbitmq.username=admin</span></span><br><span class="line"><span class="string">rabbitmq.password=admin</span></span><br><span class="line"><span class="string">rabbitmq.virtual-host=/itcast</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:rabbit</span>=<span class="string">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">host</span>=<span class="string">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">port</span>=<span class="string">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">username</span>=<span class="string">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">password</span>=<span class="string">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">virtual-host</span>=<span class="string">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;springQueueListener&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itcast.rabbitmq.listener.SpringQueueListener&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;bean id=&quot;fanoutListener1&quot; class=&quot;com.itcast.rabbitmq.listener.FanoutListener1&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;bean id=&quot;fanoutListener2&quot; class=&quot;com.itcast.rabbitmq.listener.FanoutListener2&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;bean id=&quot;topicListenerStar&quot; class=&quot;com.itcast.rabbitmq.listener.TopicListenerStar&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;bean id=&quot;topicListenerWell&quot; class=&quot;com.itcast.rabbitmq.listener.TopicListenerWell&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;bean id=&quot;topicListenerWell2&quot; class=&quot;com.itcast.rabbitmq.listener.TopicListenerWell2&quot;/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">auto-declare</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">ref</span>=<span class="string">&quot;springQueueListener&quot;</span> <span class="attr">queue-names</span>=<span class="string">&quot;spring_queue&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;rabbit:listener ref=&quot;fanoutListener1&quot; queue-names=&quot;spring_fanout_queue_1&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;rabbit:listener ref=&quot;fanoutListener2&quot; queue-names=&quot;spring_fanout_queue_2&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;rabbit:listener ref=&quot;topicListenerStar&quot; queue-names=&quot;spring_topic_queue_star&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;rabbit:listener ref=&quot;topicListenerWell&quot; queue-names=&quot;spring_topic_queue_well&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;rabbit:listener ref=&quot;topicListenerWell2&quot; queue-names=&quot;spring_topic_queue_well2&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:listener-container</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.rabbitmq.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessageListener;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/02/13/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringQueueListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/02/13/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-consumer.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-springBoot整合Rabbitmq"><a href="#4-springBoot整合Rabbitmq" class="headerlink" title="4.springBoot整合Rabbitmq"></a>4.springBoot整合Rabbitmq</h2><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/rabbitmq/202202132308909.png" alt="image-20220213223245934"></p><p>编写配置文件</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.50</span><span class="number">.128</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br></pre></td></tr></table></figure><p>编写配置类RabbitMQConfig</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.rabbitmq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/02/13/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME=<span class="string">&quot;boot_topic_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;boot_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;bootExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exchange <span class="title">bootExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_NAME).durable(<span class="keyword">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;bootQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">bootQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 队列和交换机绑定</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 知道哪个队列 哪个交换机 和routing key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindQueueExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;bootQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@Qualifier(&quot;bootExchange&quot;)</span> Exchange exchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;boot.#&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.rabbitmq.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itcast.rabbitmq.config.RabbitMQConfig;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/02/13/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSend</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_NAME,<span class="string">&quot;boot.hellomq&quot;</span>,<span class="string">&quot;你好 mq~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>消费者：</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/rabbitmq/202202132308910.png" alt="image-20220213225655778"></p><p>引入配置文件：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.50</span><span class="number">.128</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br></pre></td></tr></table></figure><p>创建监听类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.rabbitmq.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/02/13/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;boot_queue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ListenerQueue</span><span class="params">(Message message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/rabbitmq/202202132308911.png" alt="image-20220213230422553"></p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql学习之路</title>
      <link href="2021/08/15/mysql-xue-xi-zhi-lu/"/>
      <url>2021/08/15/mysql-xue-xi-zhi-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h3 id="Mysql数据库环境搭建"><a href="#Mysql数据库环境搭建" class="headerlink" title="Mysql数据库环境搭建"></a>Mysql数据库环境搭建</h3><p>略==</p><h3 id="mysql数据库简介"><a href="#mysql数据库简介" class="headerlink" title="mysql数据库简介"></a>mysql数据库简介</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815200352.png" alt="image-20210815200352668"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815200412.png" alt="image-20210815200412488"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815200430.png" alt="image-20210815200430761"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815200448.png" alt="image-20210815200448200"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815200501.png" alt="image-20210815200501304"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815200523.png" alt="image-20210815200523604"></p><h3 id="数据库软件的典型架构是怎样"><a href="#数据库软件的典型架构是怎样" class="headerlink" title="数据库软件的典型架构是怎样"></a>数据库软件的典型架构是怎样</h3><p>常见的软件架构</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815200628.png" alt="image-20210815200627932"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815200726.png" alt="image-20210815200726788"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815200802.png" alt="image-20210815200802478"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815200827.png" alt="image-20210815200827057"></p><p>MySQL架构</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815200921.png" alt="image-20210815200921292"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815201110.png" alt="image-20210815201109914"></p><h3 id="客户端如何链接MySQL"><a href="#客户端如何链接MySQL" class="headerlink" title="客户端如何链接MySQL"></a>客户端如何链接MySQL</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815201223.png" alt="image-20210815201223177"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815201236.png" alt="image-20210815201236561"></p><p> <img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815201300.png" alt="image-20210815201300728"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815201320.png" alt="image-20210815201320908"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815201333.png" alt="image-20210815201333398"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815201356.png" alt="image-20210815201356045"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815201413.png" alt="image-20210815201413440"></p><p> <img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815201502.png" alt="image-20210815201502441"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815201517.png" alt="image-20210815201517728"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815201539.png" alt="image-20210815201539885"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815201601.png" alt="image-20210815201601890"></p><h3 id="一条SQL语句的执行过程"><a href="#一条SQL语句的执行过程" class="headerlink" title="一条SQL语句的执行过程"></a>一条SQL语句的执行过程</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815201621.png" alt="image-20210815201620982"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815201907.png" alt="image-20210815201907440"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815202021.png" alt="image-20210815202021051"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815202039.png" alt="image-20210815202039197"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815202158.png" alt="image-20210815202158225"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815202304.png" alt="image-20210815202304171"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815202344.png" alt="image-20210815202344519"></p><h3 id="MySQL常见的存储引擎"><a href="#MySQL常见的存储引擎" class="headerlink" title="MySQL常见的存储引擎"></a>MySQL常见的存储引擎</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815202431.png" alt="image-20210815202431582"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815202544.png" alt="image-20210815202544880"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815202628.png" alt="image-20210815202628310"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815202652.png" alt="image-20210815202652054"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815202803.png" alt="image-20210815202803089"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815202922.png" alt="image-20210815202922720"></p><h3 id="为什么需要数据库"><a href="#为什么需要数据库" class="headerlink" title="为什么需要数据库"></a>为什么需要数据库</h3><ul><li>数据库面向软件</li><li>数据库支持事务</li><li>数据库有SQL语言</li><li>数据库可扩展</li></ul><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815203207.png" alt="image-20210815203207425"></p><h3 id="如何建表更符合业务"><a href="#如何建表更符合业务" class="headerlink" title="如何建表更符合业务"></a>如何建表更符合业务</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815203453.png" alt="image-20210815203453840"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815203623.png" alt="image-20210815203623385"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815203720.png" alt="image-20210815203720588"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815203909.png" alt="image-20210815203909601"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815204053.png" alt="image-20210815204053141"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815204231.png" alt="image-20210815204231039"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815204345.png" alt="image-20210815204345890"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815204620.png" alt="image-20210815204620270"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815204730.png" alt="image-20210815204730515"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815205233.png" alt="image-20210815205233445"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815205515.png" alt="image-20210815205515482"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815205616.png" alt="image-20210815205616714"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815205734.png" alt="image-20210815205734100"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815205838.png" alt="image-20210815205838770"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815210158.png" alt="image-20210815210158033"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815210406.png" alt="image-20210815210406577"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210815210557.png" alt="image-20210815210557419"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210821194141.png" alt="image-20210821194134335"></p><h3 id="有合适的索引不走，怎么办？"><a href="#有合适的索引不走，怎么办？" class="headerlink" title="有合适的索引不走，怎么办？"></a>有合适的索引不走，怎么办？</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822121536.png" alt="image-20210822121529685"></p><h3 id="COUNT性能慢，怎么办？"><a href="#COUNT性能慢，怎么办？" class="headerlink" title="COUNT性能慢，怎么办？"></a>COUNT性能慢，怎么办？</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822121755.png" alt="image-20210822121755154"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822122158.png" alt="image-20210822122158017"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822122407.png" alt="image-20210822122407407"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822122534.png" alt="image-20210822122534166"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822122707.png" alt="image-20210822122707543"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822122847.png" alt="image-20210822122847562"></p><h3 id="ORDER-BY-性能慢，怎么办"><a href="#ORDER-BY-性能慢，怎么办" class="headerlink" title="ORDER BY 性能慢，怎么办?"></a>ORDER BY 性能慢，怎么办?</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822123247.png" alt="image-20210822123247339"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822123425.png" alt="image-20210822123425087"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822123600.png" alt="image-20210822123559920"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822123959.png" alt="image-20210822123959792"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822124227.png" alt="image-20210822124227234"></p><h3 id="随机选取性能慢-怎么办？"><a href="#随机选取性能慢-怎么办？" class="headerlink" title="随机选取性能慢,怎么办？"></a>随机选取性能慢,怎么办？</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822124631.png" alt="image-20210822124631047"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822124729.png" alt="image-20210822124728921"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822124812.png" alt="image-20210822124812692"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822124859.png" alt="image-20210822124859799"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822125019.png" alt="image-20210822125019365"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822125354.png" alt="image-20210822125354531"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822125451.png" alt="image-20210822125451475"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822125517.png" alt="image-20210822125517718"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822161831.png" alt="image-20210822161831280"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822161943.png" alt="image-20210822161943533"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822162137.png" alt="image-20210822162137559"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822163158.png" alt="image-20210822163158028"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822163329.png" alt="image-20210822163329287"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822164752.png" alt="image-20210822164752462"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822165005.png" alt="image-20210822165005034"></p><h3 id="分页查询性能慢，怎么办？"><a href="#分页查询性能慢，怎么办？" class="headerlink" title="分页查询性能慢，怎么办？"></a>分页查询性能慢，怎么办？</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822165247.png" alt="image-20210822165247390"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822165545.png" alt="image-20210822165545173"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822170052.png" alt="image-20210822170052393"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822170139.png" alt="image-20210822170139630"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822170232.png" alt="image-20210822170232330"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822170301.png" alt="image-20210822170301614"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822170336.png" alt="image-20210822170336111"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822170406.png" alt="image-20210822170406898"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822170500.png" alt="image-20210822170500857"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822171149.png" alt="image-20210822171149119"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822171218.png" alt="image-20210822171218636"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822171336.png" alt="image-20210822171336618"></p><h3 id="如何处理数据更新？"><a href="#如何处理数据更新？" class="headerlink" title="如何处理数据更新？"></a>如何处理数据更新？</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822191354.png" alt="image-20210822191354687"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822191509.png" alt="image-20210822191509172"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822191639.png" alt="image-20210822191639809"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822191905.png" alt="image-20210822191904905"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822192115.png" alt="image-20210822192114976"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822192218.png" alt="image-20210822192218731"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822200639.png" alt="image-20210822200639329"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822200705.png" alt="image-20210822200705668"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822200830.png" alt="image-20210822200830509"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822200954.png" alt="image-20210822200954331"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822201033.png" alt="image-20210822201032888"></p><h3 id="锁：怎样平衡功能与性能？"><a href="#锁：怎样平衡功能与性能？" class="headerlink" title="锁：怎样平衡功能与性能？"></a>锁：怎样平衡功能与性能？</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822201155.png" alt="image-20210822201155332"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822201252.png" alt="image-20210822201252327"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822201353.png" alt="image-20210822201353655"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822201506.png" alt="image-20210822201506104"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822201641.png" alt="image-20210822201641816"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822201801.png" alt="image-20210822201801474"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822202001.png" alt="image-20210822202001173"></p><h3 id="事务：InnoDB的杀手锏"><a href="#事务：InnoDB的杀手锏" class="headerlink" title="事务：InnoDB的杀手锏"></a>事务：InnoDB的杀手锏</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822202138.png" alt="image-20210822202138081"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822202227.png" alt="image-20210822202227164"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822202308.png" alt="image-20210822202308714"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822202404.png" alt="image-20210822202404269"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822202429.png" alt="image-20210822202429115"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822202446.png" alt="image-20210822202446275"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822202634.png" alt="image-20210822202634865"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822203004.png" alt="image-20210822203004032"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822203309.png" alt="image-20210822203309654"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822203628.png" alt="image-20210822203628397"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822203658.png" alt="image-20210822203658170"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210822203840.png" alt="image-20210822203840373"></p><h3 id="MVCC是如何做到千人千面的？"><a href="#MVCC是如何做到千人千面的？" class="headerlink" title="MVCC是如何做到千人千面的？"></a>MVCC是如何做到千人千面的？</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823204821.png" alt="image-20210823204813573"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823204945.png" alt="image-20210823204944944"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823205601.png" alt="image-20210823205601611"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823205708.png" alt="image-20210823205708385"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823210059.png" alt="image-20210823210058892"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823210239.png" alt="image-20210823210239706"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823210445.png" alt="image-20210823210445239"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823210711.png" alt="image-20210823210711171"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823211635.png" alt="image-20210823211635588"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823211746.png" alt="image-20210823211746130"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823211955.png" alt="image-20210823211954911"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823213001.png" alt="image-20210823213001596"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823213028.png" alt="image-20210823213028165"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823213343.png" alt="image-20210823213342926"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823213436.png" alt="image-20210823213436442"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823213542.png" alt="image-20210823213542390"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823213753.png" alt="image-20210823213753763"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823213913.png" alt="image-20210823213913457"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823214000.png" alt="image-20210823214000516"></p><h3 id="长事务的危害"><a href="#长事务的危害" class="headerlink" title="长事务的危害"></a>长事务的危害</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823214139.png" alt="image-20210823214139651"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823214212.png" alt="image-20210823214211820"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823214300.png" alt="image-20210823214300418"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823214357.png" alt="image-20210823214356924"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823214707.png" alt="image-20210823214707686"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823215022.png" alt="image-20210823215022047"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823215432.png" alt="image-20210823215432445"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823215511.png" alt="image-20210823215511472"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823215534.png" alt="image-20210823215534048"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823215647.png" alt="image-20210823215647360"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823215715.png" alt="image-20210823215715573"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823215804.png" alt="image-20210823215803859"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823215824.png" alt="image-20210823215824677"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823215910.png" alt="image-20210823215910499"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823215941.png" alt="image-20210823215941364"></p><p>​    <img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823220032.png" alt="image-20210823220032596"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210823220111.png" alt="image-20210823220110998"></p><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210824210110.png" alt="image-20210824210102914"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210824210131.png" alt="image-20210824210131565"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210824210337.png" alt="image-20210824210336841"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210824210642.png" alt="image-20210824210641761"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210824210839.png" alt="image-20210824210839566"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210824210901.png" alt="image-20210824210901273"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210824211202.png" alt="image-20210824211202652"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210824211705.png" alt="image-20210824211704600"></p><h3 id="数据库的备份"><a href="#数据库的备份" class="headerlink" title="数据库的备份"></a>数据库的备份</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210824212144.png" alt="image-20210824212144705"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210824212230.png" alt="image-20210824212229963"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210824212325.png" alt="image-20210824212325794"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210824212355.png" alt="image-20210824212355299"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210824212527.png" alt="image-20210824212527061"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210824212547.png" alt="image-20210824212546761"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210824212643.png" alt="image-20210824212643439"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210824212752.png" alt="image-20210824212752146"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210824213258.png" alt="image-20210824213258660"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210824213418.png" alt="image-20210824213418000"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210824213732.png" alt="image-20210824213732339"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210824213931.png" alt="image-20210824213931124"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210824214011.png" alt="image-20210824214010892"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210824215208.png" alt="image-20210824215208732"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210824215257.png" alt="image-20210824215257621"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210824215355.png" alt="image-20210824215355418"></p><h3 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828161853.png" alt="image-20210828161853213"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828162017.png" alt="image-20210828162017321"></p><h3 id="mysqldump全量-增量备份"><a href="#mysqldump全量-增量备份" class="headerlink" title="mysqldump全量+增量备份"></a>mysqldump全量+增量备份</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump全量备份</span><br><span class="line">mysqldump -uroot -pXXXX --databases sakila --single-transaction &gt;test.sql</span><br><span class="line"></span><br><span class="line">mysqladmin 切换binlog</span><br><span class="line">mysqladmin -uroot -proot123456 flush-logs</span><br><span class="line"></span><br><span class="line">mysqldump增量备份</span><br><span class="line">mysqldump -uroot -pXXXX --databases sakila --single-transaction --flush-logs --master-data&#x3D;2 &gt;test.sql</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828172253.png" alt="image-20210828172252813"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828172731.png" alt="image-20210828172731598"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828172913.png" alt="image-20210828172913436"></p><h3 id="XtraBackup物理备份"><a href="#XtraBackup物理备份" class="headerlink" title="XtraBackup物理备份"></a>XtraBackup物理备份</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828173223.png" alt="image-20210828173223732"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828173439.png" alt="image-20210828173439298"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828173759.png" alt="image-20210828173758901"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828173941.png" alt="image-20210828173941468"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828174037.png" alt="image-20210828174037209"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828174142.png" alt="image-20210828174142456"></p><h3 id="ibbackup免费版xtraBackup"><a href="#ibbackup免费版xtraBackup" class="headerlink" title="ibbackup免费版xtraBackup"></a>ibbackup免费版xtraBackup</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828174319.png" alt="image-20210828174319792"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828175500.png" alt="image-20210828175500488"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828175521.png" alt="image-20210828175521308"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828175628.png" alt="image-20210828175627943"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828180000.png" alt="image-20210828180000385"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下载</span><br><span class="line">wget https:&#x2F;&#x2F;downloads.percona.com&#x2F;downloads&#x2F;Percona-XtraBackup-2.4&#x2F;Percona-XtraBackup-2.4.23&#x2F;binary&#x2F;redhat&#x2F;7&#x2F;x86_64&#x2F;percona-xtrabackup-24-2.4.23-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">安装</span><br><span class="line">rpm -ivh --nodeps --force percona-xtrabackup-24-2.4.23-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">全量备份</span><br><span class="line">innobackupex --user&#x3D;root --password&#x3D;root123456 bakdir&#x2F;user&#x2F;local&#x2F;mysql&#x2F;data</span><br><span class="line">还原(停掉mysqld)</span><br><span class="line">innobackupex --copy-back bakdir&#x2F;XXXX-XX-XX&#x2F;</span><br><span class="line"></span><br><span class="line">增量备份</span><br><span class="line">innobackupex --user&#x3D;root --password&#x3D;root123456 --incremental bakdir&#x2F;--incremental-basedir&#x3D;&#39;&#x2F;bakdir&#x2F;XXXX-XX-XX&#x2F;&#39;</span><br><span class="line">增量备份合并至全量备份</span><br><span class="line">innobackupex --apply-log bakdir&#x2F;XXXX-XX-XX&#x2F; --incremental-dir&#x3D;bakdir&#x2F;YYYY-YY-YY&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828180208.png"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828180252.png" alt="image-20210828180252373"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828180434.png" alt="image-20210828180434720"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828180511.png" alt="image-20210828180511072"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828180649.png" alt="image-20210828180649345"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828181046.png" alt="image-20210828181046566"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828181604.png" alt="image-20210828181604213"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828181632.png" alt="image-20210828181631757"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828182007.png" alt="image-20210828182007082"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828182118.png" alt="image-20210828182118631"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828182130.png" alt="image-20210828182130206"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828182146.png" alt="image-20210828182146039"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828182218.png" alt="image-20210828182217692"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828182301.png" alt="image-20210828182301799"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210828182331.png" alt="image-20210828182331120"></p><h3 id="mySql三高"><a href="#mySql三高" class="headerlink" title="mySql三高"></a>mySql三高</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829170221.png" alt="image-20210829170214067"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829170320.png" alt="image-20210829170319974"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829170435.png" alt="image-20210829170435797"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829170538.png" alt="image-20210829170538042"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829170605.png" alt="image-20210829170605709"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829170731.png" alt="image-20210829170731036"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829170815.png" alt="image-20210829170815086"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829171143.png" alt="image-20210829171143809"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829171236.png" alt="image-20210829171236626"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829171333.png" alt="image-20210829171333570"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829171357.png" alt="image-20210829171357025"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829171619.png" alt="image-20210829171619155"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829171718.png" alt="image-20210829171718522"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829171941.png" alt="image-20210829171941817"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829172030.png" alt="image-20210829172030047"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829173305.png" alt="image-20210829173305507"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829173351.png" alt="image-20210829173351219"></p><p>​    </p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829173443.png" alt="image-20210829173443083">    </p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829173510.png" alt="image-20210829173510159"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829173721.png" alt="image-20210829173721436"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829173850.png" alt="image-20210829173850416"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829174344.png" alt="image-20210829174343958"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829174529.png" alt="image-20210829174529882"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829174651.png" alt="image-20210829174651837"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829174709.png" alt="image-20210829174708943"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829175143.png" alt="image-20210829175143192"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829175432.png" alt="image-20210829175431931"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829175640.png" alt="image-20210829175640400"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829175717.png" alt="image-20210829175716918"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829175753.png" alt="image-20210829175753419"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829175856.png" alt="image-20210829175856182"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829180017.png" alt="image-20210829180017538"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829180226.png" alt="image-20210829180226027"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829180352.png" alt="image-20210829180352608"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829180734.png" alt="image-20210829180734848"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829180949.png" alt="image-20210829180949194"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829181032.png" alt="image-20210829181032412"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829181133.png" alt="image-20210829181133512"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829181425.png" alt="image-20210829181425884"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829181540.png" alt="image-20210829181540180"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829181701.png" alt="image-20210829181701592"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829181801.png" alt="image-20210829181801151"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829181928.png" alt="image-20210829181928243"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829182006.png" alt="image-20210829182006534"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829182222.png" alt="image-20210829182222705"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829182306.png" alt="image-20210829182306106"></p><p> <img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829182348.png" alt="image-20210829182348295"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829182446.png" alt="image-20210829182446552"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20210829182524.png" alt="image-20210829182524530"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java自带常用工具类</title>
      <link href="2021/06/25/java-chang-yong-gong-ju-lei/"/>
      <url>2021/06/25/java-chang-yong-gong-ju-lei/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Java自带工具方法"><a href="#1-Java自带工具方法" class="headerlink" title="1. Java自带工具方法"></a>1. Java自带工具方法</h1><h2 id="1-1-List集合拼接成以逗号分隔的字符串"><a href="#1-1-List集合拼接成以逗号分隔的字符串" class="headerlink" title="1.1 List集合拼接成以逗号分隔的字符串"></a>1.1 List集合拼接成以逗号分隔的字符串</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 如何把list集合拼接成以逗号分隔的字符串 a,b,c</span><br><span class="line">List&lt;String&gt; list &#x3D; Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">&#x2F;&#x2F; 第一种方法，可以用stream流</span><br><span class="line">String join &#x3D; list.stream().collect(Collectors.joining(&quot;,&quot;));</span><br><span class="line">System.out.println(join); &#x2F;&#x2F; 输出 a,b,c</span><br><span class="line">&#x2F;&#x2F; 第二种方法，其实String也有join方法可以实现这个功能</span><br><span class="line">String join &#x3D; String.join(&quot;,&quot;, list);</span><br><span class="line">System.out.println(join); &#x2F;&#x2F; 输出 a,b,c</span><br></pre></td></tr></table></figure><h2 id="1-2-比较两个字符串是否相等，忽略大小写"><a href="#1-2-比较两个字符串是否相等，忽略大小写" class="headerlink" title="1.2 比较两个字符串是否相等，忽略大小写"></a>1.2 比较两个字符串是否相等，忽略大小写</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (strA.equalsIgnoreCase(strB)) &#123;</span><br><span class="line">  System.out.println(&quot;相等&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-比较两个对象是否相等"><a href="#1-3-比较两个对象是否相等" class="headerlink" title="1.3 比较两个对象是否相等"></a>1.3 比较两个对象是否相等</h2><p>当我们用equals比较两个对象是否相等的时候，还需要对左边的对象进行判空，不然可能会报空指针异常，我们可以用java.util包下Objects封装好的比较是否相等的方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Objects.equals(strA, strB);</span><br><span class="line">源码：</span><br><span class="line">public static boolean equals(Object a, Object b) &#123;</span><br><span class="line">    return (a &#x3D;&#x3D; b) || (a !&#x3D; null &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-两个List集合取交集"><a href="#1-4-两个List集合取交集" class="headerlink" title="1.4 两个List集合取交集"></a>1.4 两个List集合取交集</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list1 &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">list1.add(&quot;a&quot;);</span><br><span class="line">list1.add(&quot;b&quot;);</span><br><span class="line">list1.add(&quot;c&quot;);</span><br><span class="line">List&lt;String&gt; list2 &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">list2.add(&quot;a&quot;);</span><br><span class="line">list2.add(&quot;b&quot;);</span><br><span class="line">list2.add(&quot;d&quot;);</span><br><span class="line">list1.retainAll(list2);</span><br><span class="line">System.out.println(list1); &#x2F;&#x2F; 输出[a, b]</span><br></pre></td></tr></table></figure><h1 id="2-apache-commons工具类库"><a href="#2-apache-commons工具类库" class="headerlink" title="2. apache commons工具类库"></a>2. apache commons工具类库</h1><p>apache commons是最强大的，也是使用最广泛的工具类库，里面的子库非常多，下面介绍几个最常用的</p><h2 id="2-1-commons-lang，java-lang的增强版"><a href="#2-1-commons-lang，java-lang的增强版" class="headerlink" title="2.1 commons-lang，java.lang的增强版"></a>2.1 commons-lang，java.lang的增强版</h2><p>建议使用commons-lang3，优化了一些api，原来的commons-lang已停止更新</p><p>Maven依赖是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-lang3&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.12.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="2-1-1-字符串判空"><a href="#2-1-1-字符串判空" class="headerlink" title="2.1.1 字符串判空"></a>2.1.1 字符串判空</h3><p>传参CharSequence类型是String、StringBuilder、StringBuffer的父类，都可以直接下面方法判空，以下是源码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean isEmpty(final CharSequence cs) &#123;</span><br><span class="line">    return cs &#x3D;&#x3D; null || cs.length() &#x3D;&#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static boolean isNotEmpty(final CharSequence cs) &#123;</span><br><span class="line">    return !isEmpty(cs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判空的时候，会去除字符串中的空白字符，比如空格、换行、制表符</span><br><span class="line">public static boolean isBlank(final CharSequence cs) &#123;</span><br><span class="line">    final int strLen &#x3D; length(cs);</span><br><span class="line">    if (strLen &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; strLen; i++) &#123;</span><br><span class="line">        if (!Character.isWhitespace(cs.charAt(i))) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static boolean isNotBlank(final CharSequence cs) &#123;</span><br><span class="line">    return !isBlank(cs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-2-首字母转成大写"><a href="#2-1-2-首字母转成大写" class="headerlink" title="2.1.2 首字母转成大写"></a>2.1.2 首字母转成大写</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String str &#x3D; &quot;yideng&quot;;</span><br><span class="line">String capitalize &#x3D; StringUtils.capitalize(str);</span><br><span class="line">System.out.println(capitalize); &#x2F;&#x2F; 输出Yideng</span><br></pre></td></tr></table></figure><h3 id="2-1-3-重复拼接字符串"><a href="#2-1-3-重复拼接字符串" class="headerlink" title="2.1.3 重复拼接字符串"></a>2.1.3 重复拼接字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String str &#x3D; StringUtils.repeat(&quot;ab&quot;, 2);</span><br><span class="line">System.out.println(str); &#x2F;&#x2F; 输出abab</span><br></pre></td></tr></table></figure><h3 id="2-1-4-格式化日期"><a href="#2-1-4-格式化日期" class="headerlink" title="2.1.4 格式化日期"></a>2.1.4 格式化日期</h3><p>再也不用手写SimpleDateFormat格式化了</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Date类型转String类型</span><br><span class="line">String date &#x3D; DateFormatUtils.format(new Date(), &quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">System.out.println(date); &#x2F;&#x2F; 输出 2021-05-01 01:01:01</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; String类型转Date类型</span><br><span class="line">Date date &#x3D; DateUtils.parseDate(&quot;2021-05-01 01:01:01&quot;, &quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 计算一个小时后的日期</span><br><span class="line">Date date &#x3D; DateUtils.addHours(new Date(), 1);</span><br></pre></td></tr></table></figure><h3 id="2-1-5-包装临时对象"><a href="#2-1-5-包装临时对象" class="headerlink" title="2.1.5 包装临时对象"></a>2.1.5 包装临时对象</h3><p>当一个方法需要返回两个及以上字段时，我们一般会封装成一个临时对象返回，现在有了Pair和Triple就不需要了</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 返回两个字段</span><br><span class="line">ImmutablePair&lt;Integer, String&gt; pair &#x3D; ImmutablePair.of(1, &quot;yideng&quot;);</span><br><span class="line">System.out.println(pair.getLeft() + &quot;,&quot; + pair.getRight()); &#x2F;&#x2F; 输出 1,yideng</span><br><span class="line">&#x2F;&#x2F; 返回三个字段</span><br><span class="line">ImmutableTriple&lt;Integer, String, Date&gt; triple &#x3D; ImmutableTriple.of(1, &quot;yideng&quot;, new Date());</span><br><span class="line">System.out.println(triple.getLeft() + &quot;,&quot; + triple.getMiddle() + &quot;,&quot; + triple.getRight()); &#x2F;&#x2F; 输出 1,yideng,Wed Apr 07 23:30:00 CST 2021</span><br></pre></td></tr></table></figure><h2 id="2-2-commons-collections-集合工具类"><a href="#2-2-commons-collections-集合工具类" class="headerlink" title="2.2 commons-collections 集合工具类"></a>2.2 commons-collections 集合工具类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections4&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.4&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="2-2-1-集合判空"><a href="#2-2-1-集合判空" class="headerlink" title="2.2.1 集合判空"></a>2.2.1 集合判空</h3><p>封装了集合判空的方法，以下是源码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean isEmpty(final Collection&lt;?&gt; coll) &#123;</span><br><span class="line">    return coll &#x3D;&#x3D; null || coll.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static boolean isNotEmpty(final Collection&lt;?&gt; coll) &#123;</span><br><span class="line">    return !isEmpty(coll);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 两个集合取交集</span><br><span class="line">Collection&lt;String&gt; collection &#x3D; CollectionUtils.retainAll(listA, listB);</span><br><span class="line">&#x2F;&#x2F; 两个集合取并集</span><br><span class="line">Collection&lt;String&gt; collection &#x3D; CollectionUtils.union(listA, listB);</span><br><span class="line">&#x2F;&#x2F; 两个集合取差集</span><br><span class="line">Collection&lt;String&gt; collection &#x3D; CollectionUtils.subtract(listA, listB);</span><br></pre></td></tr></table></figure><h2 id="2-3-common-beanutils-操作对象"><a href="#2-3-common-beanutils-操作对象" class="headerlink" title="2.3 common-beanutils 操作对象"></a>2.3 common-beanutils 操作对象</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-beanutils&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-beanutils&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.9.4&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br><span class="line">设置对象属性</span><br><span class="line">User user &#x3D; new User();</span><br><span class="line">BeanUtils.setProperty(user, &quot;id&quot;, 1);</span><br><span class="line">BeanUtils.setProperty(user, &quot;name&quot;, &quot;yideng&quot;);</span><br><span class="line">System.out.println(BeanUtils.getProperty(user, &quot;name&quot;)); &#x2F;&#x2F; 输出 yideng</span><br><span class="line">System.out.println(user); &#x2F;&#x2F; 输出 &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;yideng&quot;&#125;</span><br><span class="line">对象和map互转</span><br><span class="line">&#x2F;&#x2F; 对象转map</span><br><span class="line">Map&lt;String, String&gt; map &#x3D; BeanUtils.describe(user);</span><br><span class="line">System.out.println(map); &#x2F;&#x2F; 输出 &#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;yideng&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; map转对象</span><br><span class="line">User newUser &#x3D; new User();</span><br><span class="line">BeanUtils.populate(newUser, map);</span><br><span class="line">System.out.println(newUser); &#x2F;&#x2F; 输出 &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;yideng&quot;&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-commons-io-文件流处理"><a href="#2-4-commons-io-文件流处理" class="headerlink" title="2.4 commons-io 文件流处理"></a>2.4 commons-io 文件流处理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-io&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-io&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.8.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">File file &#x3D; new File(&quot;demo1.txt&quot;);</span><br><span class="line">&#x2F;&#x2F; 读取文件</span><br><span class="line">List&lt;String&gt; lines &#x3D; FileUtils.readLines(file, Charset.defaultCharset());</span><br><span class="line">&#x2F;&#x2F; 写入文件</span><br><span class="line">FileUtils.writeLines(new File(&quot;demo2.txt&quot;), lines);</span><br><span class="line">&#x2F;&#x2F; 复制文件</span><br><span class="line">FileUtils.copyFile(srcFile, destFile);</span><br></pre></td></tr></table></figure><h1 id="3-Google-Guava-工具类库"><a href="#3-Google-Guava-工具类库" class="headerlink" title="3. Google Guava 工具类库"></a>3. Google Guava 工具类库</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;30.1.1-jre&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="3-1-创建集合"><a href="#3-1-创建集合" class="headerlink" title="3.1 创建集合"></a>3.1 创建集合</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; Lists.newArrayList();</span><br><span class="line">List&lt;Integer&gt; list &#x3D; Lists.newArrayList(1, 2, 3);</span><br><span class="line">&#x2F;&#x2F; 反转list</span><br><span class="line">List&lt;Integer&gt; reverse &#x3D; Lists.reverse(list);</span><br><span class="line">System.out.println(reverse); &#x2F;&#x2F; 输出 [3, 2, 1]</span><br><span class="line">&#x2F;&#x2F; list集合元素太多，可以分成若干个集合，每个集合10个元素</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; partition &#x3D; Lists.partition(list, 10);</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; map &#x3D; Maps.newHashMap();</span><br><span class="line">Set&lt;String&gt; set &#x3D; Sets.newHashSet();</span><br></pre></td></tr></table></figure><h2 id="3-2-黑科技集合"><a href="#3-2-黑科技集合" class="headerlink" title="3.2 黑科技集合"></a>3.2 黑科技集合</h2><h3 id="3-2-1-Multimap-一个key可以映射多个value的HashMap"><a href="#3-2-1-Multimap-一个key可以映射多个value的HashMap" class="headerlink" title="3.2.1 Multimap 一个key可以映射多个value的HashMap"></a>3.2.1 Multimap 一个key可以映射多个value的HashMap</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Multimap&lt;String, Integer&gt; map &#x3D; ArrayListMultimap.create();</span><br><span class="line">map.put(&quot;key&quot;, 1);</span><br><span class="line">map.put(&quot;key&quot;, 2);</span><br><span class="line">Collection&lt;Integer&gt; values &#x3D; map.get(&quot;key&quot;);</span><br><span class="line">System.out.println(map); &#x2F;&#x2F; 输出 &#123;&quot;key&quot;:[1,2]&#125;</span><br><span class="line">&#x2F;&#x2F; 还能返回你以前使用的臃肿的Map</span><br><span class="line">Map&lt;String, Collection&lt;Integer&gt;&gt; collectionMap &#x3D; map.asMap();</span><br><span class="line">多省事，多简洁，省得你再创建 Map&lt;String, List&gt;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-BiMap-一种连value也不能重复的HashMap"><a href="#3-2-2-BiMap-一种连value也不能重复的HashMap" class="headerlink" title="3.2.2 BiMap 一种连value也不能重复的HashMap"></a>3.2.2 BiMap 一种连value也不能重复的HashMap</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BiMap&lt;String, String&gt; biMap &#x3D; HashBiMap.create();</span><br><span class="line">&#x2F;&#x2F; 如果value重复，put方法会抛异常，除非用forcePut方法</span><br><span class="line">biMap.put(&quot;key&quot;,&quot;value&quot;);</span><br><span class="line">System.out.println(biMap); &#x2F;&#x2F; 输出 &#123;&quot;key&quot;:&quot;value&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; 既然value不能重复，何不实现个翻转key&#x2F;value的方法，已经有了</span><br><span class="line">BiMap&lt;String, String&gt; inverse &#x3D; biMap.inverse();</span><br><span class="line">System.out.println(inverse); &#x2F;&#x2F; 输出 &#123;&quot;value&quot;:&quot;key&quot;&#125;</span><br><span class="line"></span><br><span class="line">这其实是双向映射，在某些场景还是很实用的。</span><br></pre></td></tr></table></figure><h3 id="3-2-3-Table-一种有两个key的HashMap"><a href="#3-2-3-Table-一种有两个key的HashMap" class="headerlink" title="3.2.3 Table 一种有两个key的HashMap"></a>3.2.3 Table 一种有两个key的HashMap</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 一批用户，同时按年龄和性别分组</span><br><span class="line">Table&lt;Integer, String, String&gt; table &#x3D; HashBasedTable.create();</span><br><span class="line">table.put(18, &quot;男&quot;, &quot;yideng&quot;);</span><br><span class="line">table.put(18, &quot;女&quot;, &quot;Lily&quot;);</span><br><span class="line">System.out.println(table.get(18, &quot;男&quot;)); &#x2F;&#x2F; 输出 yideng</span><br><span class="line">&#x2F;&#x2F; 这其实是一个二维的Map，可以查看行数据</span><br><span class="line">Map&lt;String, String&gt; row &#x3D; table.row(18);</span><br><span class="line">System.out.println(row); &#x2F;&#x2F; 输出 &#123;&quot;男&quot;:&quot;yideng&quot;,&quot;女&quot;:&quot;Lily&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; 查看列数据</span><br><span class="line">Map&lt;Integer, String&gt; column &#x3D; table.column(&quot;男&quot;);</span><br><span class="line">System.out.println(column); &#x2F;&#x2F; 输出 &#123;18:&quot;yideng&quot;&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-4-Multiset-一种用来计数的Set"><a href="#3-2-4-Multiset-一种用来计数的Set" class="headerlink" title="3.2.4 Multiset 一种用来计数的Set"></a>3.2.4 Multiset 一种用来计数的Set</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Multiset&lt;String&gt; multiset &#x3D; HashMultiset.create();</span><br><span class="line">multiset.add(&quot;apple&quot;);</span><br><span class="line">multiset.add(&quot;apple&quot;);</span><br><span class="line">multiset.add(&quot;orange&quot;);</span><br><span class="line">System.out.println(multiset.count(&quot;apple&quot;)); &#x2F;&#x2F; 输出 2</span><br><span class="line">&#x2F;&#x2F; 查看去重的元素</span><br><span class="line">Set&lt;String&gt; set &#x3D; multiset.elementSet();</span><br><span class="line">System.out.println(set); &#x2F;&#x2F; 输出 [&quot;orange&quot;,&quot;apple&quot;]</span><br><span class="line">&#x2F;&#x2F; 还能查看没有去重的元素</span><br><span class="line">Iterator&lt;String&gt; iterator &#x3D; multiset.iterator();</span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 还能手动设置某个元素出现的次数</span><br><span class="line">multiset.setCount(&quot;apple&quot;, 5);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA工具类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA工具类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springCloudAlibaba</title>
      <link href="2021/03/14/springcloudalibaba/"/>
      <url>2021/03/14/springcloudalibaba/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-微服务介绍"><a href="#第一章-微服务介绍" class="headerlink" title="第一章 微服务介绍"></a>第一章 微服务介绍</h1><h2 id="1-1-系统架构演变"><a href="#1-1-系统架构演变" class="headerlink" title="1.1  系统架构演变"></a>1.1  系统架构演变</h2><p>​    随着互联网的发展，网站应用的规模也在不断的扩大，进而导致系统架构也在不断的进行变化。  从互联网早起到现在，系统架构大体经历了下面几个过程: 单体应用架构—&gt;垂直应用架构—&gt;分布式架构—&gt;SOA架构—&gt;微服务架构，当然还有悄然兴起的Service Mesh(服务网格化)。接下来我们就来了解一下每种系统架构是什么样子的， 以及各有什么优缺点。</p><h3 id="1-1-1-单体应用架构"><a href="#1-1-1-单体应用架构" class="headerlink" title="1.1.1  单体应用架构"></a>1.1.1  单体应用架构</h3><p>​    互联网早期，一般的网站应用流量较小，只需一个应用，将所有功能代码都部署在一起就可以，这 样可以减少开发、部署和维护的成本。</p><p>​    比如说一个电商系统，里面会包含很多用户管理，商品管理，订单管理，物流管理等等很多模块， 我们会把它们做成一个web项目，然后部署到一台tomcat服务器上。</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210314161333.png" alt="image-20210314161333586"></p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>项目架构简单，小型项目的话， 开发成本低</li><li>项目部署在一个节点上， 维护方便</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>全部功能集成在一个工程中，对于大型项目来讲不易开发和维护</li><li>项目模块之间紧密耦合，单点容错率低</li><li>无法针对不同模块进行针对性优化和水平扩展</li></ul><h3 id="1-1-2-垂直应用架构"><a href="#1-1-2-垂直应用架构" class="headerlink" title="1.1.2  垂直应用架构"></a>1.1.2  垂直应用架构</h3><p>​    随着访问量的逐渐增大，单一应用只能依靠增加节点来应对，但是这时候会发现并不是所有的模块 都会有比较大的访问量.</p><p>​    还是以上面的电商为例子， 用户访问量的增加可能影响的只是用户和订单模块， 但是对消息模块的影响就比较小. 那么此时我们希望只多增加几个订单模块， 而不增加消息模块. 此时单体应用就做不到了， 垂直应用就应运而生了.</p><p>​    所谓的垂直应用架构，就是将原来的一个应用拆成互不相干的几个应用，以提升效率。比如我们可 以将上面电商的单体应用拆分成:</p><ul><li>电商系统(用户管理 商品管理 订单管理)</li><li>后台系统(用户管理 订单管理 客户管理)</li><li>CMS系统(广告管理 营销管理)</li></ul><p>这样拆分完毕之后，一旦用户访问量变大，只需要增加电商系统的节点就可以了，而无需增加后台 和CMS的节点。</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210314162050.png" alt="image-20210314162050443"></p><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ul><li>系统拆分实现了流量分担，解决了并发问题，而且可以针对不同模块进行优化和水平扩展</li><li>一个系统的问题不会影响到其他系统，提高容错率</li></ul><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>系统之间相互独立， 无法进行相互调用</li><li>系统之间相互独立， 会有重复的开发任务</li></ul><h3 id="1-1-3-分布式架构"><a href="#1-1-3-分布式架构" class="headerlink" title="1.1.3  分布式架构"></a>1.1.3  分布式架构</h3><p>当垂直应用越来越多，重复的业务代码就会越来越多。这时候，我们就思考可不可以将重复的代码 抽取出来，做成统一的业务层作为独立的服务，然后由前端控制层调用不同的业务层服务呢？</p><p> 这就产生了新的分布式系统架构。它将把工程拆分成表现层和服务层两个部分，服务层中包含业务 逻辑。表现层只需要处理和页面的交互，业务逻辑都是调用服务层的服务来实现。</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210314163302.png" alt="image-20210314163302580"></p><h4 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h4><ul><li>抽取公共的功能为服务层，提高代码复用性</li></ul><h4 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>系统间耦合度变高，调用关系错综复杂，难以维护</li></ul><h3 id="1-1-4-SOA架构"><a href="#1-1-4-SOA架构" class="headerlink" title="1.1.4  SOA架构"></a>1.1.4  SOA架构</h3><p>在分布式架构下，当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加 一个调度中心对集群进行实时管理。此时，用于资源调度和治理中心(SOA Service Oriented Architecture，面向服务的架构)是关键。</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210314163455.png" alt="image-20210314163455353"></p><h4 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h4><ul><li>使用注册中心解决了服务间调用关系的自动调节</li></ul><h4 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>服务间会有依赖关系，一旦某个环节出错会影响较大( 服务雪崩 )</li><li>服务关系复杂，运维、测试部署困难</li></ul><h3 id="1-1-5-微服务架构"><a href="#1-1-5-微服务架构" class="headerlink" title="1.1.5 微服务架构"></a>1.1.5 微服务架构</h3><p>微服务架构在某种程度上是面向服务的架构SOA继续发展的下一步，它更加强调服务的”彻底拆分”。</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210314163623.png" alt="image-20210314163623612"></p><h4 id="优点：-4"><a href="#优点：-4" class="headerlink" title="优点："></a>优点：</h4><ul><li>服务原子化拆分，独立打包、部署和升级，保证每个微服务清晰的任务划分，利于扩展</li><li>微服务之间采用Restful等轻量级http协议相互调用</li></ul><h4 id="缺点：-4"><a href="#缺点：-4" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>分布式系统开发的技术成本高（容错、分布式事务等）</li></ul><h2 id="1-2-微服务架构介绍"><a href="#1-2-微服务架构介绍" class="headerlink" title="1.2  微服务架构介绍"></a>1.2  微服务架构介绍</h2><p>微服务架构， 简单的说就是将单体应用进一步拆分，拆分成更小的服务，每个服务都是一个可以独立运行的项目。</p><h3 id="1-2-1-微服务架构的常见问题"><a href="#1-2-1-微服务架构的常见问题" class="headerlink" title="1.2.1  微服务架构的常见问题"></a>1.2.1  微服务架构的常见问题</h3><p>一旦采用微服务系统架构，就势必会遇到这样几个问题：</p><ul><li>这么多小服务，如何管理他们？(服务治理 注册中心[服务注册 发现 剔除]) </li><li>这么多小服务，他们之间如何通讯？(<strong>restful</strong> rpc)</li><li>这么多小服务，客户端怎么访问他们？(网关)</li><li>这么多小服务，一旦出现问题了，应该如何自处理？(容错) </li><li>这么多小服务，一旦出现问题了，应该如何排错? (链路追踪)</li></ul><p>对于上面的问题，是任何一个微服务设计者都不能绕过去的，因此大部分的微服务产品都针对每一 个问题提供了相应的组件来解决它们。</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210314163849.png" alt="image-20210314163849136"></p><h3 id="1-2-2-微服务架构的常见概念"><a href="#1-2-2-微服务架构的常见概念" class="headerlink" title="1.2.2  微服务架构的常见概念"></a>1.2.2  微服务架构的常见概念</h3><h4 id="1-2-2-1-服务治理"><a href="#1-2-2-1-服务治理" class="headerlink" title="1.2.2.1 服务治理"></a>1.2.2.1 服务治理</h4><p>服务治理就是进行服务的自动化管理，其核心是服务的自动注册与发现。</p><p><strong>服务注册</strong>：服务实例将自身服务信息注册到注册中心。</p><p><strong>服务发现</strong>：服务实例通过注册中心，获取到注册到其中的服务实例的信息，通过这些信息去请求它们提 供的服务。</p><p><strong>服务剔除</strong>：服务注册中心将出问题的服务自动剔除到可用列表之外，使其不会被调用到。</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210314164129.png" alt="image-20210314164129264"></p><h4 id="1-2-2-2-服务调用"><a href="#1-2-2-2-服务调用" class="headerlink" title="1.2.2.2 服务调用"></a>1.2.2.2 服务调用</h4><p>在微服务架构中，通常存在多个服务之间的远程调用的需求。目前主流的远程调用技术有基于</p><p>HTTP的RESTful接口以及基于TCP的RPC协议。</p><ul><li><p><strong>REST</strong>(Representational State Transfer）</p><p>这是一种HTTP调用的格式，更标准，更通用，无论哪种语言都支持http协议</p></li><li><p><strong>RPC</strong>（Remote Promote Call）</p><p>一种进程间通信方式。允许像调用本地服务一样调用远程服务。RPC框架的主要目标就是让远程服 务调用更简单、透明。RPC框架负责屏蔽底层的传输方式、序列化方式和通信细节。开发人员在使 用的时候只需要了解谁在什么位置提供了什么样的远程服务接口即可，并不需要关心底层通信细节 和调用过程。</p></li></ul><p><strong>区别与联系</strong></p><table><thead><tr><th><strong>比较项</strong></th><th><strong>RESTful</strong></th><th><strong>RPC</strong></th></tr></thead><tbody><tr><td>通讯协议</td><td>HTTP</td><td>一般使用TCP</td></tr><tr><td>性能</td><td>略低</td><td>较高</td></tr><tr><td>灵活度</td><td>高</td><td>低</td></tr><tr><td>应用</td><td>微服务架构</td><td>SOA架构</td></tr></tbody></table><h4 id="1-2-2-3-服务网关"><a href="#1-2-2-3-服务网关" class="headerlink" title="1.2.2.3 服务网关"></a>1.2.2.3 服务网关</h4><p>随着微服务的不断增多，不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个 服务的接口才能完成一个业务需求，如果让客户端直接与各个微服务通信可能出现：</p><ul><li>客户端需要调用不同的url地址，增加难度</li><li>在一定的场景下，存在跨域请求的问题</li><li>每个微服务都需要进行单独的身份认证</li></ul><p>针对这些问题，API网关顺势而生。</p><p>API网关直面意思是将所有API调用统一接入到API网关层，由网关层统一接入和输出。一个网关的 基本功能有：统一接入、安全防护、协议适配、流量管控、长短链接支持、容错能力。有了网关之后， 各个API服务提供团队可以专注于自己的的业务逻辑处理，而API网关更专注于安全、流量、路由等问题。</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210314164405.png" alt="image-20210314164405474"></p><h4 id="1-2-2-4-服务容错"><a href="#1-2-2-4-服务容错" class="headerlink" title="1.2.2.4 服务容错"></a>1.2.2.4 服务容错</h4><p>在微服务当中，一个请求经常会涉及到调用几个服务，如果其中某个服务不可用，没有做服务容错 的话，极有可能会造成一连串的服务不可用，这就是雪崩效应。</p><p>我们没法预防雪崩效应的发生，只能尽可能去做好容错。服务容错的三个核心思想是：</p><ul><li>不被外界环境影响</li><li>不被上游请求压垮</li><li>不被下游响应拖垮</li></ul><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210314164515.png" alt="image-20210314164515852"></p><h4 id="1-2-2-5-链路追踪"><a href="#1-2-2-5-链路追踪" class="headerlink" title="1.2.2.5 链路追踪"></a>1.2.2.5 链路追踪</h4><p>随着微服务架构的流行，服务按照不同的维度进行拆分，一次请求往往需要涉及到多个服务。互联 网应用构建在不同的软件模块集上，这些软件模块，有可能是由不同的团队开发、可能使用不同的编程 语言来实现、有可能布在了几千台服务器，横跨多个不同的数据中心。因此，就需要对一次请求涉及的 多个服务链路进行日志记录，性能监控即链路追踪</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210314164555.png" alt="image-20210314164555735"></p><h3 id="1-2-3-微服务架构的常见解决方"><a href="#1-2-3-微服务架构的常见解决方" class="headerlink" title="1.2.3  微服务架构的常见解决方"></a>1.2.3  微服务架构的常见解决方</h3><h4 id="1-2-3-1-ServiceComb"><a href="#1-2-3-1-ServiceComb" class="headerlink" title="1.2.3.1 ServiceComb"></a>1.2.3.1 ServiceComb</h4><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210314164658.png" alt="image-20210314164658342"></p><p>Apache ServiceComb，前身是华为云的微服务引擎 CSE (Cloud Service Engine) 云服务，是全球首个Apache微服务顶级项目。它提供了一站式的微服务开源解决方案，致力于帮助企业、用户和开发 者将企业应用轻松微服务化上云，并实现对微服务应用的高效运维管理。</p><h4 id="1-2-3-2-SpringCloud"><a href="#1-2-3-2-SpringCloud" class="headerlink" title="1.2.3.2 SpringCloud"></a>1.2.3.2 SpringCloud</h4><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210314164730.png" alt="image-20210314164729867"></p><p>Spring Cloud是一系列框架的集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</p><p>Spring  Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring  Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><h4 id="1-2-3-3-SpringCloud-Alibaba"><a href="#1-2-3-3-SpringCloud-Alibaba" class="headerlink" title="1.2.3.3 SpringCloud Alibaba"></a>1.2.3.3 SpringCloud Alibaba</h4><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210314164809.png" alt="image-20210314164809605"></p><p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p><h2 id="1-3-SpringCloud-Alibaba介绍"><a href="#1-3-SpringCloud-Alibaba介绍" class="headerlink" title="1.3  SpringCloud Alibaba介绍"></a>1.3  SpringCloud Alibaba介绍</h2><p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p><p>依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p><h3 id="1-3-1-主要功能"><a href="#1-3-1-主要功能" class="headerlink" title="1.3.1  主要功能"></a>1.3.1  主要功能</h3><ul><li><strong>服务限流降级</strong>：默认支持 WebServlet、WebFlux， OpenFeign、RestTemplate、Spring Cloud Gateway， Zuul， Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。</li><li><strong>服务注册与发现</strong>：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。</li><li><strong>分布式配置管理</strong>：支持分布式系统中的外部化配置，配置更改时自动刷新。</li><li><strong>消息驱动能力</strong>：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。</li><li><strong>分布式事务</strong>：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。</li><li><strong>阿里云对象存储</strong>：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任 何时间、任何地点存储和访问任意类型的数据。</li><li><strong>分布式任务调度</strong>：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有Worker（schedulerx-client）上执行。</li><li><strong>阿里云短信服务</strong>：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建 客户触达通道。</li></ul><h3 id="1-3-2-组件"><a href="#1-3-2-组件" class="headerlink" title="1.3.2  组件"></a>1.3.2  组件</h3><ul><li><strong>Sentinel</strong>：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</li><li><strong>Nacos</strong>：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li><li><strong>RocketMQ</strong>：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠 的消息发布与订阅服务。</li><li><strong>Dubbo</strong>：Apache Dubbo™ 是一款高性能 Java RPC 框架。</li><li><strong>Seata</strong>：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</li><li><strong>Alibaba Cloud ACM</strong>：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。</li><li><strong>Alibaba Cloud OSS</strong>: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提 供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和 访问任意类型的数据。</li><li><strong>Alibaba Cloud SchedulerX</strong>: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。</li><li><strong>Alibaba Cloud SMS</strong>: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li></ul><h1 id="第二章-微服务环境搭建"><a href="#第二章-微服务环境搭建" class="headerlink" title="第二章 微服务环境搭建"></a>第二章 微服务环境搭建</h1><p>本次是使用的电商项目中的商品、订单、用户为案例进行讲解。</p><h2 id="2-1-案例准备"><a href="#2-1-案例准备" class="headerlink" title="2.1  案例准备"></a>2.1  案例准备</h2><h3 id="2-1-1-技术选型"><a href="#2-1-1-技术选型" class="headerlink" title="2.1.1  技术选型"></a>2.1.1  技术选型</h3><p>maven：3.3.9</p><p>数据库：MySQL 5.7</p><p>持久层: SpingData Jpa</p><p>其他: SpringCloud Alibaba 技术栈</p><h3 id="2-1-2-模块设计"><a href="#2-1-2-模块设计" class="headerlink" title="2.1.2  模块设计"></a>2.1.2  模块设计</h3><ul><li>springcloud-alibaba 父工程</li><li>shop-common 公共模块【实体类】</li><li>shop-user 用户微服务 【端口: 807x】</li><li>shop-product 商品微服务 【端口: 808x】</li><li>shop-order 订单微服务 【端口: 809x】</li></ul><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210314170040.png" alt="image-20210314170040663"></p><h3 id="2-1-3-微服务调用"><a href="#2-1-3-微服务调用" class="headerlink" title="2.1.3  微服务调用"></a>2.1.3  微服务调用</h3><p>在微服务架构中，最常见的场景就是微服务之间的相互调用。我们以电商系统中常见的<strong>用户下单</strong>为 例来演示微服务的调用：客户向订单微服务发起一个下单的请求，在进行保存订单之前需要调用商品微 服务查询商品的信息。</p><p>我们一般把服务的主动调用方称为<strong>服务消费者</strong>，把服务的被调用方称为<strong>服务提供者</strong>。</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210314170114.png" alt="image-20210314170114588"></p><p>在这种场景下，订单微服务就是一个服务消费者， 商品微服务就是一个服务提供者。</p><h2 id="2-2-创建父工程"><a href="#2-2-创建父工程" class="headerlink" title="2.2  创建父工程"></a>2.2  创建父工程</h2><p>创建一个maven工程，然后在pom.xml文件中添加下面内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.wb&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springCloudAlibaba&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;&#x2F;packaging&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;shop-common&lt;&#x2F;module&gt;</span><br><span class="line">        &lt;module&gt;shop-user&lt;&#x2F;module&gt;</span><br><span class="line">        &lt;module&gt;shop-product&lt;&#x2F;module&gt;</span><br><span class="line">        &lt;module&gt;shop-order&lt;&#x2F;module&gt;</span><br><span class="line">    &lt;&#x2F;modules&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.3.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF- 8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;spring-cloud.version&gt;Greenwich.RELEASE&lt;&#x2F;spring-cloud.version&gt;</span><br><span class="line">        &lt;spring-cloud-alibaba.version&gt;2.1.0.RELEASE&lt;&#x2F;spring-cloud-alibaba.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;&#x2F;dependencies&gt;</span><br><span class="line">    &lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><p>版本对应：</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210314213835.png" alt="image-20210314213835253"></p><h2 id="2-3-创建基础模块"><a href="#2-3-创建基础模块" class="headerlink" title="2.3  创建基础模块"></a>2.3  创建基础模块</h2><p>1    创建shop-common 模块，在pom.xml中添加依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;springCloudAlibaba&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.wb&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;shop-common&lt;&#x2F;artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.56&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.6&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><p>2 创建实体类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wb.domain;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">import javax.persistence.Entity;</span><br><span class="line">import javax.persistence.GeneratedValue;</span><br><span class="line">import javax.persistence.GenerationType;</span><br><span class="line">import javax.persistence.Id;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: wbnn</span><br><span class="line"> * @Date: 2021&#x2F;03&#x2F;14&#x2F;</span><br><span class="line"> * @Description:用户</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Entity(name &#x3D; &quot;shop_user&quot;) &#x2F;&#x2F;实体类跟数据表对应</span><br><span class="line">@Data</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy &#x3D; GenerationType.IDENTITY)     &#x2F;&#x2F;数据库自增长</span><br><span class="line">    private Integer uid;&#x2F;&#x2F;主键</span><br><span class="line">    private String username;&#x2F;&#x2F;用户名</span><br><span class="line">    private String password;&#x2F;&#x2F;密码</span><br><span class="line">    private String telephone;&#x2F;&#x2F;手机号</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wb.domain;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">import javax.persistence.Entity;</span><br><span class="line">import javax.persistence.GeneratedValue;</span><br><span class="line">import javax.persistence.GenerationType;</span><br><span class="line">import javax.persistence.Id;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: wbnn</span><br><span class="line"> * @Date: 2021&#x2F;03&#x2F;14&#x2F;</span><br><span class="line"> * @Description:商品</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Entity(name &#x3D; &quot;shop_product&quot;)</span><br><span class="line">@Data</span><br><span class="line">public class Product &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy &#x3D; GenerationType.IDENTITY)</span><br><span class="line">    private Integer pid;&#x2F;&#x2F;主键</span><br><span class="line"></span><br><span class="line">    private String pname;&#x2F;&#x2F;商品名称</span><br><span class="line"></span><br><span class="line">    private Double pprice;&#x2F;&#x2F;商品价格</span><br><span class="line"></span><br><span class="line">    private Integer stock;&#x2F;&#x2F;库存</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wb.domain;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">import javax.persistence.Entity;</span><br><span class="line">import javax.persistence.GeneratedValue;</span><br><span class="line">import javax.persistence.GenerationType;</span><br><span class="line">import javax.persistence.Id;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: wbnn</span><br><span class="line"> * @Date: 2021&#x2F;03&#x2F;14&#x2F;</span><br><span class="line"> * @Description:订单</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Entity(name &#x3D; &quot;shop_order&quot;)</span><br><span class="line">@Data</span><br><span class="line">public class Order &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy &#x3D; GenerationType.IDENTITY)</span><br><span class="line">    private Long oid;&#x2F;&#x2F;订单id</span><br><span class="line"></span><br><span class="line">    private Integer uid;&#x2F;&#x2F; 用户</span><br><span class="line"></span><br><span class="line">    private String username;&#x2F;&#x2F;用户名</span><br><span class="line"></span><br><span class="line">    private Integer pid;&#x2F;&#x2F;商品id</span><br><span class="line"></span><br><span class="line">    private String pname;&#x2F;&#x2F;商品名称</span><br><span class="line"></span><br><span class="line">    private Double pprice;&#x2F;&#x2F;商品单价</span><br><span class="line"></span><br><span class="line">    private Integer number;&#x2F;&#x2F;购买数量</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-4-创建用户微服务"><a href="#2-4-创建用户微服务" class="headerlink" title="2.4  创建用户微服务"></a>2.4  创建用户微服务</h2><p>步骤:</p><ul><li>1 创建模块 导入依赖</li><li>2 创建SpringBoot主类</li><li>3 加入配置文件</li><li>4 创建必要的接口和实现类(controller service dao)</li></ul><p>1 创建pom.xml</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;springCloudAlibaba&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.wb&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;shop-user&lt;&#x2F;artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.wb&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shop-common&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><p>2 编写主类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wb;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: wbnn</span><br><span class="line"> * @Date: 2021&#x2F;03&#x2F;14&#x2F;</span><br><span class="line"> * @Description:User服务</span><br><span class="line"> *&#x2F;</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class UserApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(UserApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3 创建配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8071</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: service-user</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;&#x2F;shop?serverTimezone&#x3D;UTC&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;useSSL&#x3D;true</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">  jpa:</span><br><span class="line">    properties:</span><br><span class="line">      hibernate:</span><br><span class="line">        hbm2ddl:</span><br><span class="line">          auto: update</span><br><span class="line">        dialect: org.hibernate.dialect.MySQL5InnoDBDialect</span><br></pre></td></tr></table></figure><h2 id="2-5-创建商品微服务"><a href="#2-5-创建商品微服务" class="headerlink" title="2.5  创建商品微服务"></a>2.5  创建商品微服务</h2><p>1    创建一个名为shop_product 的模块，并添加springboot依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;springCloudAlibaba&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.wb&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;shop-product&lt;&#x2F;artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.wb&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shop-common&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><p>2 创建工程的主类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wb;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: wbnn</span><br><span class="line"> * @Date: 2021&#x2F;03&#x2F;14&#x2F;</span><br><span class="line"> * @Description:product服务</span><br><span class="line"> *&#x2F;</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ProductApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ProductApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3 创建配置文件application.yml</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: service-product</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;&#x2F;shop?serverTimezone&#x3D;UTC&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;useSSL&#x3D;true</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">  jpa:</span><br><span class="line">    properties:</span><br><span class="line">      hibernate:</span><br><span class="line">        hbm2ddl:</span><br><span class="line">          auto: update</span><br><span class="line">        dialect: org.hibernate.dialect.MySQL5InnoDBDialect</span><br></pre></td></tr></table></figure><p>4 创建ProductDao接口</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wb.product.dao;</span><br><span class="line"></span><br><span class="line">import com.wb.domain.Product;</span><br><span class="line">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: wbnn</span><br><span class="line"> * @Date: 2021&#x2F;03&#x2F;14&#x2F;</span><br><span class="line"> * @Description:</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface ProductDao extends JpaRepository&lt;Product,Integer&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5 创建ProductService接口和实现类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wb.product.service;</span><br><span class="line"></span><br><span class="line">import com.wb.domain.Product;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: wbnn</span><br><span class="line"> * @Date: 2021&#x2F;03&#x2F;14&#x2F;</span><br><span class="line"> * @Description:</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface ProductService &#123;</span><br><span class="line"></span><br><span class="line">    Product findByPid(Integer pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wb.product.service.impl;</span><br><span class="line"></span><br><span class="line">import com.wb.domain.Product;</span><br><span class="line">import com.wb.product.dao.ProductDao;</span><br><span class="line">import com.wb.product.service.ProductService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: wbnn</span><br><span class="line"> * @Date: 2021&#x2F;03&#x2F;14&#x2F;</span><br><span class="line"> * @Description:</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Service</span><br><span class="line">public class ProductServiceImpl implements ProductService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductDao productDao;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Product findByPid(Integer pid) &#123;</span><br><span class="line">        return productDao.findById(pid).get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>6 创建Controller</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wb.product.controller;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.wb.domain.Product;</span><br><span class="line">import com.wb.product.service.ProductService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: wbnn</span><br><span class="line"> * @Date: 2021&#x2F;03&#x2F;14&#x2F;</span><br><span class="line"> * @Description:</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class ProductController &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductService productService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;product&#x2F;&#123;pid&#125;&quot;)</span><br><span class="line">    public Product findProductById(@PathVariable(&quot;pid&quot;) Integer pid) &#123;</span><br><span class="line">        log.info(&quot;查询的商品id为&#123;&#125;&quot;+pid);</span><br><span class="line">        Product product &#x3D; productService.findByPid(pid);</span><br><span class="line">        log.info(&quot;查询到的商品信息为：&#123;&#125;&quot;+ JSON.toJSONString(product));</span><br><span class="line">        return product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>7 启动工程，等到数据库表创建完毕之后，加入测试数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO shop_product VALUE(NULL,&#39;小米&#39;,&#39;1000&#39;,&#39;5000&#39;);</span><br><span class="line">INSERT INTO shop_product VALUE(NULL,&#39;华为&#39;,&#39;2000&#39;,&#39;5000&#39;); </span><br><span class="line">INSERT INTO shop_product VALUE(NULL,&#39;苹果&#39;,&#39;3000&#39;,&#39;5000&#39;); </span><br><span class="line">INSERT INTO shop_product VALUE(NULL,&#39;OPPO&#39;,&#39;4000&#39;,&#39;5000&#39;);</span><br></pre></td></tr></table></figure><p>8 通过浏览器访问服务</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210314214747.png" alt="image-20210314214747585"></p><h2 id="2-6-创建订单微服务"><a href="#2-6-创建订单微服务" class="headerlink" title="2.6  创建订单微服务"></a>2.6  创建订单微服务</h2><p>步骤如上：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;springCloudAlibaba&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.wb&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;shop-order&lt;&#x2F;artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.wb&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shop-common&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8091</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: service-order</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;&#x2F;shop?serverTimezone&#x3D;UTC&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;useSSL&#x3D;true</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">  jpa:</span><br><span class="line">    properties:</span><br><span class="line">      hibernate:</span><br><span class="line">        hbm2ddl:</span><br><span class="line">          auto: update</span><br><span class="line">        dialect: org.hibernate.dialect.MySQL5InnoDBDialect</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wb;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: wbnn</span><br><span class="line"> * @Date: 2021&#x2F;03&#x2F;14&#x2F;</span><br><span class="line"> * @Description:</span><br><span class="line"> *&#x2F;</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class OrderApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(OrderApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RestTemplate restTemplate()&#123;</span><br><span class="line">        return new RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wb.order.dao;</span><br><span class="line"></span><br><span class="line">import com.wb.domain.Order;</span><br><span class="line">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: wbnn</span><br><span class="line"> * @Date: 2021&#x2F;03&#x2F;14&#x2F;</span><br><span class="line"> * @Description:</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface OrderDao extends JpaRepository&lt;Order,Integer&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wb.order.controller;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.wb.domain.Order;</span><br><span class="line">import com.wb.domain.Product;</span><br><span class="line">import com.wb.order.service.OrderService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: wbnn</span><br><span class="line"> * @Date: 2021&#x2F;03&#x2F;14&#x2F;</span><br><span class="line"> * @Description:</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;order&#x2F;prod&#x2F;&#123;pid&#125;&quot;)</span><br><span class="line">    public Order saveOrder(@PathVariable(&quot;pid&quot;)Integer pid)&#123;</span><br><span class="line">        log.info(&quot;接收到&#123;&#125;号商品下单请求，调用商品微服务查询信息&quot;,pid);</span><br><span class="line">        Product product &#x3D;</span><br><span class="line">                restTemplate.getForObject(&quot;http:&#x2F;&#x2F;localhost:8081&#x2F;product&#x2F;&quot;+pid,Product.class);</span><br><span class="line">        log.info(&quot;查询到的商品为：&#123;&#125;&quot;+ JSON.toJSONString(product));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建订单</span><br><span class="line">        Order order &#x3D; new Order();</span><br><span class="line">        order.setUid(1);</span><br><span class="line">        order.setUsername(&quot;蜡笔小新&quot;);</span><br><span class="line"></span><br><span class="line">        order.setPid(product.getPid());</span><br><span class="line">        order.setPname(product.getPname());</span><br><span class="line">        order.setPprice(product.getPprice());</span><br><span class="line"></span><br><span class="line">        order.setNumber(10);</span><br><span class="line"></span><br><span class="line">        orderService.createOrder(order);</span><br><span class="line"></span><br><span class="line">        log.info(&quot;创建订单成功，订单为：&#123;&#125;&quot;+ JSON.toJSONString(order));</span><br><span class="line"></span><br><span class="line">        return order;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wb.order.service;</span><br><span class="line"></span><br><span class="line">import com.wb.domain.Order;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: wbnn</span><br><span class="line"> * @Date: 2021&#x2F;03&#x2F;14&#x2F;</span><br><span class="line"> * @Description:</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface OrderService &#123;</span><br><span class="line">    void createOrder(Order order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wb.order.service.impl;</span><br><span class="line"></span><br><span class="line">import com.wb.domain.Order;</span><br><span class="line">import com.wb.order.dao.OrderDao;</span><br><span class="line">import com.wb.order.service.OrderService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: wbnn</span><br><span class="line"> * @Date: 2021&#x2F;03&#x2F;14&#x2F;</span><br><span class="line"> * @Description:</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Service</span><br><span class="line">public class OrderServiceImpl implements OrderService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderDao orderDao;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void createOrder(Order order) &#123;</span><br><span class="line">        orderDao.save(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动工程,通过浏览器访问服务进行测试：</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210314215040.png" alt="image-20210314215040604"></p><h1 id="第三章-Nacos-Discovery–服务治理"><a href="#第三章-Nacos-Discovery–服务治理" class="headerlink" title="第三章 Nacos Discovery–服务治理"></a>第三章 Nacos Discovery–服务治理</h1><h2 id="3-1-服务治理介绍"><a href="#3-1-服务治理介绍" class="headerlink" title="3.1  服务治理介绍"></a>3.1  服务治理介绍</h2><h5 id="先来思考一个问题"><a href="#先来思考一个问题" class="headerlink" title="先来思考一个问题"></a>先来思考一个问题</h5><p>通过上一章的操作，我们已经可以实现微服务之间的调用。但是我们把服务提供者的网络地址</p><p>（ip，端口）等硬编码到了代码中，这种做法存在许多问题：</p><ul><li>一旦服务提供者地址变化，就需要手工修改代码</li><li>一旦是多个服务提供者，无法实现负载均衡功能</li><li>一旦服务变得越来越多，人工维护调用关系困难</li></ul><p>那么应该怎么解决呢， 这时候就需要通过注册中心动态的实现<strong>服务治理</strong>。</p><h5 id="什么是服务治理"><a href="#什么是服务治理" class="headerlink" title="什么是服务治理"></a>什么是服务治理</h5><p>服务治理是微服务架构中最核心最基本的模块。用于实现各个微服务的<strong>自动化注册与发现</strong>。</p><ul><li><strong>服务注册：</strong>在服务治理框架中，都会构建一个注册中心，每个服务单元向注册中心登记自己提供服 务的详细信息。并在注册中心形成一张服务的清单，服务注册中心需要以心跳的方式去监测清单中 的服务是否可用，如果不可用，需要在服务清单中剔除不可用的服务。</li><li><strong>服务发现：</strong>服务调用方向服务注册中心咨询服务，并获取所有服务的实例清单，实现对具体服务实例的访问。</li></ul><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210314215317.png" alt="image-20210314215317252"></p><p>通过上面的调用图会发现，除了微服务，还有一个组件是<strong>服务注册中心</strong>，它是微服务架构非常重要 的一个组件，在微服务架构里主要起到了协调者的一个作用。注册中心一般包含如下几个功能：</p><ol><li>服务发现：<ul><li>服务注册：保存服务提供者和服务调用者的信息</li><li>服务订阅：服务调用者订阅服务提供者的信息，注册中心向订阅者推送提供者的信息</li></ul></li><li>服务配置：<ul><li>配置订阅：服务提供者和服务调用者订阅微服务相关的配置</li><li>配置下发：主动将配置推送给服务提供者和服务调用者</li></ul></li><li>服务健康检测：<ul><li>检测服务提供者的健康情况，如果发现异常，执行服务剔除</li></ul></li></ol><h5 id="常见的注册中心"><a href="#常见的注册中心" class="headerlink" title="常见的注册中心"></a>常见的注册中心</h5><ul><li><p><strong>Zookeeper</strong></p><p>zookeeper是一个分布式服务框架，是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用 配置项的管理等。</p></li><li><p>Eureka</p><p>Eureka是Springcloud  Netﬂix中的重要组件，主要作用就是做服务注册和发现。但是现在已经闭源</p></li><li><p>Consul</p><p>Consul是基于GO语言开发的开源工具，主要面向分布式，服务化的系统提供服务注册、服务发现 和配置管理的功能。Consul的功能都很实用，其中包括：服务注册/发现、健康检查、Key/Value  存储、多数据中心和分布式一致性保证等特性。Consul本身只是一个二进制的可执行文件，所以  安装和部署都非常简单，只需要从官网下载后，在执行对应的启动脚本即可。</p></li><li><p>Nacos</p><p>Nacos是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。它是 Spring Cloud Alibaba 组件之一，负责服务注册发现和服务配置，可以这样认为nacos=eureka+conﬁg。</p></li></ul><h2 id="3-2-nacos简介"><a href="#3-2-nacos简介" class="headerlink" title="3.2  nacos简介"></a>3.2  nacos简介</h2><p>Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p><p>从上面的介绍就可以看出，<strong>nacos的作用就是一个注册中心</strong>，用来管理注册上来的各个微服务。</p><h2 id="3-3-nacos实战入门"><a href="#3-3-nacos实战入门" class="headerlink" title="3.3  nacos实战入门"></a>3.3  nacos实战入门</h2><p>接下来，我们就在现有的环境中加入nacos，并将我们的两个微服务注册上去。</p><h3 id="3-3-1-搭建nacos环境"><a href="#3-3-1-搭建nacos环境" class="headerlink" title="3.3.1  搭建nacos环境"></a>3.3.1  搭建nacos环境</h3><p>第1步: 安装nacos-win环境</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下载地址: https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;nacos&#x2F;releases</span><br><span class="line">下载zip格式的安装包，然后进行解压缩操作</span><br></pre></td></tr></table></figure><p>第2步: 启动nacos</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#切换目录</span><br><span class="line">cd nacos&#x2F;bin #命令启动</span><br><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure><p>第3步: 访问nacos</p><p>打开浏览器输入<a href="http://localhost:8848/nacos%EF%BC%8C%E5%8D%B3%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%EF%BC%8C">http://localhost:8848/nacos，即可访问服务，</a> 默认密码是nacos/nacos</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210314220153.png" alt="image-20210314220153642"></p><h3 id="3-3-2-将商品微服务注册到nacos"><a href="#3-3-2-将商品微服务注册到nacos" class="headerlink" title="3.3.2  将商品微服务注册到nacos"></a>3.3.2  将商品微服务注册到nacos</h3><p>接下来开始修改shop-product 模块的代码， 将其注册到nacos服务上</p><p>1 在pom.xml中添加nacos的依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--nacos--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2 在主类上添加**@EnableDiscoveryClient**注解</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class ProductApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ProductApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 在application.yml中添加nacos服务的地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cloud:</span><br><span class="line">  nacos:</span><br><span class="line">    discovery:</span><br><span class="line">      server-addr: localhost:8848</span><br></pre></td></tr></table></figure><p>4 启动服务， 观察nacos的控制面板中是否有注册上来的商品微服务、</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210315231521.png" alt="image-20210315231514626"></p><h3 id="3-3-3-将订单微服务注册到nacos"><a href="#3-3-3-将订单微服务注册到nacos" class="headerlink" title="3.3.3  将订单微服务注册到nacos"></a>3.3.3  将订单微服务注册到nacos</h3><p>接下来开始修改shop_order 模块的代码， 将其注册到nacos服务上</p><p>1 在pom.xml中添加nacos的依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--nacos--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2 在主类上添加**@EnableDiscoveryClient**注解</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class OrderApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(OrderApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 在application.yml中添加nacos服务的地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cloud:</span><br><span class="line">  nacos:</span><br><span class="line">    discovery:</span><br><span class="line">      server-addr: localhost:8848</span><br></pre></td></tr></table></figure><p>4  修改OrderController， 实现微服务调用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     log.info(&quot;接收到&#123;&#125;号商品下单请求，调用商品微服务查询信息&quot;,pid);</span><br><span class="line">List&lt;ServiceInstance&gt; serviceInstances &#x3D; discoveryClient.getInstances(&quot;service-product&quot;);</span><br><span class="line">ServiceInstance instance &#x3D; serviceInstances.get(0);</span><br><span class="line">Product product &#x3D;              restTemplate.getForObject(&quot;http:&#x2F;&#x2F;&quot;+instance.getHost()+&quot;:&quot;+instance.getPort()+&quot;&#x2F;product&#x2F;&quot;+pid,Product.class);</span><br><span class="line">        log.info(&quot;查询到的商品为：&#123;&#125;&quot;+ JSON.toJSONString(product));</span><br><span class="line">        &#x2F;&#x2F;创建订单</span><br><span class="line">        Order order &#x3D; new Order();</span><br><span class="line">        order.setUid(1);</span><br><span class="line">        order.setUsername(&quot;蜡笔小新&quot;);</span><br><span class="line">        order.setPid(product.getPid());</span><br><span class="line">        order.setPname(product.getPname());</span><br><span class="line">        order.setPprice(product.getPprice());</span><br><span class="line">        order.setNumber(10);</span><br><span class="line"></span><br><span class="line">        orderService.createOrder(order);</span><br><span class="line">        log.info(&quot;创建订单成功，订单为：&#123;&#125;&quot;+ JSON.toJSONString(order));</span><br><span class="line">        return order;</span><br></pre></td></tr></table></figure><p>DiscoveryClient是专门负责服务注册和发现的，我们可以通过它获取到注册到注册中心的所有服务</p><p>5 启动服务， 观察nacos的控制面板中是否有注册上来的订单微服务，然后通过访问消费者服务验证调用是否成功</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210315231953.png" alt="image-20210315231952962"></p><h2 id="3-4-实现服务调用的负载均衡"><a href="#3-4-实现服务调用的负载均衡" class="headerlink" title="3.4  实现服务调用的负载均衡"></a>3.4  实现服务调用的负载均衡</h2><h3 id="3-4-1-什么是负载均衡"><a href="#3-4-1-什么是负载均衡" class="headerlink" title="3.4.1  什么是负载均衡"></a>3.4.1  什么是负载均衡</h3><p>通俗的讲， 负载均衡就是将负载（工作任务，访问请求）进行分摊到多个操作单元（服务器,组件）上进行执行。</p><p>根据负载均衡发生位置的不同,一般分为<strong>服务端负载均衡</strong>和<strong>客户端负载均衡</strong>。服务端负载均衡指的是发生在服务提供者一方,比如常见的nginx负载均衡</p><p>而客户端负载均衡指的是发生在服务请求的一方，也就是在发送请求之前已经选好了由哪个实例处理请求。</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210315232046.png" alt="image-20210315232046015"></p><p>我们在微服务调用关系中一般会选择客户端负载均衡，也就是在服务调用的一方来决定服务由哪个提供 者执行。</p><h3 id="3-4-2-自定义实现负载均衡"><a href="#3-4-2-自定义实现负载均衡" class="headerlink" title="3.4.2  自定义实现负载均衡"></a>3.4.2  自定义实现负载均衡</h3><ol><li>通过idea再启动一个shop-product 微服务，设置其端口为8082</li></ol><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210315232148.png" alt="image-20210315232148556"></p><ol start="2"><li>通过nacos查看微服务的启动情况</li></ol><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210315232246.png" alt="image-20210315232246264"></p><ol start="3"><li>修改shop-order 的代码，实现负载均衡</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;自定义负载均衡</span><br><span class="line">      log.info(&quot;接收到&#123;&#125;号商品下单请求，调用商品微服务查询信息&quot;,pid);</span><br><span class="line"></span><br><span class="line">      List&lt;ServiceInstance&gt; serviceInstances &#x3D; discoveryClient.getInstances(&quot;service-product&quot;);</span><br><span class="line">      &#x2F;&#x2F;随机选择</span><br><span class="line">      int nextInt &#x3D; new Random().nextInt(serviceInstances.size());</span><br><span class="line">      ServiceInstance instance &#x3D; serviceInstances.get(nextInt);</span><br><span class="line"></span><br><span class="line">      Product product &#x3D;</span><br><span class="line">              restTemplate.getForObject(&quot;http:&#x2F;&#x2F;&quot;+instance.getHost()+&quot;:&quot;+instance.getPort()+&quot;&#x2F;product&#x2F;&quot;+pid,Product.class);</span><br><span class="line">      log.info(&quot;查询到的商品为：&#123;&#125;&quot;+ JSON.toJSONString(product));</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;创建订单</span><br><span class="line">      Order order &#x3D; new Order();</span><br><span class="line">      order.setUid(1);</span><br><span class="line">      order.setUsername(&quot;蜡笔小新&quot;);</span><br><span class="line"></span><br><span class="line">      order.setPid(product.getPid());</span><br><span class="line">      order.setPname(product.getPname());</span><br><span class="line">      order.setPprice(product.getPprice());</span><br><span class="line"></span><br><span class="line">      order.setNumber(10);</span><br><span class="line"></span><br><span class="line">      orderService.createOrder(order);</span><br><span class="line"></span><br><span class="line">      log.info(&quot;创建订单成功，订单为：&#123;&#125;&quot;+ JSON.toJSONString(order));</span><br><span class="line"></span><br><span class="line">      return order;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-4-3-基于Ribbon实现负载均衡"><a href="#3-4-3-基于Ribbon实现负载均衡" class="headerlink" title="3.4.3  基于Ribbon实现负载均衡"></a>3.4.3  基于Ribbon实现负载均衡</h3><p>Ribbon是Spring Cloud的一个组件， 它可以让我们使用一个注解就能轻松的搞定负载均衡</p><p>第1步：在RestTemplate 的生成方法上添加@LoadBalanced注解</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@LoadBalanced</span><br><span class="line">public RestTemplate restTemplate() &#123; return new RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第2步：修改服务调用的方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Ribbon负载均衡</span><br><span class="line">        log.info(&quot;接收到&#123;&#125;号商品下单请求，调用商品微服务查询信息&quot;,pid);</span><br><span class="line"></span><br><span class="line">        Product product &#x3D;</span><br><span class="line">                restTemplate.getForObject(&quot;http:&#x2F;&#x2F;service-product&#x2F;product&#x2F;&quot;+pid,Product.class);</span><br><span class="line">        log.info(&quot;查询到的商品为：&#123;&#125;&quot;+ JSON.toJSONString(product));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建订单</span><br><span class="line">        Order order &#x3D; new Order();</span><br><span class="line">        order.setUid(1);</span><br><span class="line">        order.setUsername(&quot;蜡笔小新&quot;);</span><br><span class="line"></span><br><span class="line">        order.setPid(product.getPid());</span><br><span class="line">        order.setPname(product.getPname());</span><br><span class="line">        order.setPprice(product.getPprice());</span><br><span class="line"></span><br><span class="line">        order.setNumber(10);</span><br><span class="line"></span><br><span class="line">        orderService.createOrder(order);</span><br><span class="line"></span><br><span class="line">        log.info(&quot;创建订单成功，订单为：&#123;&#125;&quot;+ JSON.toJSONString(order));</span><br><span class="line"></span><br><span class="line">        return order;</span><br></pre></td></tr></table></figure><p>Ribbon支持的负载均衡策略</p><p>Ribbon内置了多种负载均衡策略,内部负载均衡的顶级接口com.netflix.loadbalancer.IRule , 具体的负载策略如下图所示:</p><table><thead><tr><th align="left"><strong>策略名</strong></th><th><strong>策略描述</strong></th><th><strong>实现说明</strong></th></tr></thead><tbody><tr><td align="left">BestAvailableRule</td><td>选择一个最小的并发请求的server</td><td>逐个考察Server，如果Server被tripped了，则忽略，在选择其中ActiveRequestsCount最小的server</td></tr><tr><td align="left">AvailabilityFilteringRule</td><td>过滤掉那些因为一直连接失败的被标记为circuit tripped的后端server，并过滤掉那些高并发的的后端server（active connections 超过配置的阈值）</td><td>使用一个AvailabilityPredicate来包含过滤server的逻辑，其实就就是检查status里记录的各个server的运行状态</td></tr><tr><td align="left">WeightedResponseTimeRule</td><td>根据相应时间分配一个weight，相应时间越长，weight越小，被选中的可能性越低。</td><td>一个后台线程定期的从status里面读取评价响应时间，为每个server计算一个weight。Weight的计算也比较简单responsetime 减去每个server自己平均的responsetime是server的权重。当刚开始运行，没有形成statas 时，使用roubine策略选择server。</td></tr><tr><td align="left">RetryRule</td><td>对选定的负载均衡策略机上重试机制。</td><td>在一个配置时间段内当选择server不成功，则一直尝试使用subRule的方式选择一个可用的server</td></tr><tr><td align="left">RoundRobinRule</td><td>轮询方式轮询选择  server</td><td>轮询index，选择index对应位置的  server</td></tr><tr><td align="left">RandomRule</td><td>随机选择一个server</td><td>在index上随机，选择index对应位置的server</td></tr><tr><td align="left">ZoneAvoidanceRule</td><td>复合判断server所在区域的性能和server 的可用性选择server</td><td>使用ZoneAvoidancePredicate和AvailabilityPredicate来判断是否选择某个server，前一个判断判定一个zone的运行性能是否可用，剔除不可用 的 zone（ 的 所 有 server）， AvailabilityPredicate用于过滤掉连接数过多的Server。</td></tr></tbody></table><p>我们可以通过修改配置来调整Ribbon的负载均衡策略，具体代码如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service-product: # 调用的提供者的名称</span><br><span class="line">  ribbon:</span><br><span class="line">    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule  #策略</span><br></pre></td></tr></table></figure><h2 id="3-5-基于Feign实现服务调用"><a href="#3-5-基于Feign实现服务调用" class="headerlink" title="3.5  基于Feign实现服务调用"></a>3.5  基于Feign实现服务调用</h2><h3 id="3-5-1-什么是Feign"><a href="#3-5-1-什么是Feign" class="headerlink" title="3.5.1  什么是Feign"></a>3.5.1  什么是Feign</h3><p>Feign是Spring Cloud提供的一个声明式的伪Http客户端， 它使得调用远程服务就像调用本地服务一样简单， 只需要创建一个接口并添加一个注解即可。</p><p>Nacos很好的兼容了Feign， Feign默认集成了 Ribbon， 所以在Nacos下使用Fegin默认就实现了负载均衡的效果。</p><h3 id="3-5-2-Feign的使用"><a href="#3-5-2-Feign的使用" class="headerlink" title="3.5.2  Feign的使用"></a>3.5.2  Feign的使用</h3><p>1 加入Fegin的依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--fegin--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2 在主类上添加Fegin的注解</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableFeignClients     &#x2F;&#x2F;开启Fegin</span><br><span class="line">public class OrderApplication &#123; --- &#125;</span><br></pre></td></tr></table></figure><p>3 创建一个接口， 并使用Fegin实现微服务调用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FeignClient(value &#x3D; &quot;service-product&quot;)</span><br><span class="line">public interface ProductFeginService &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;product&#x2F;&#123;pid&#125;&quot;)</span><br><span class="line">    Product findProductById(@PathVariable(&quot;pid&quot;) Integer pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4 修改controller代码，并启动验证</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;&#x2F;Fegin</span><br><span class="line"> log.info(&quot;接收到&#123;&#125;号商品下单请求，调用商品微服务查询信息&quot;,pid);</span><br><span class="line"></span><br><span class="line">   Product product &#x3D;productFeginService.findProductById(pid);</span><br><span class="line"></span><br><span class="line">   log.info(&quot;查询到的商品为：&#123;&#125;&quot;+ JSON.toJSONString(product));</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;创建订单</span><br><span class="line">   Order order &#x3D; new Order();</span><br><span class="line">   order.setUid(1);</span><br><span class="line">   order.setUsername(&quot;蜡笔小新&quot;);</span><br><span class="line"></span><br><span class="line">   order.setPid(product.getPid());</span><br><span class="line">   order.setPname(product.getPname());</span><br><span class="line">   order.setPprice(product.getPprice());</span><br><span class="line"></span><br><span class="line">   order.setNumber(10);</span><br><span class="line"></span><br><span class="line">   orderService.createOrder(order);</span><br><span class="line"></span><br><span class="line">   log.info(&quot;创建订单成功，订单为：&#123;&#125;&quot;+ JSON.toJSONString(order));</span><br><span class="line"></span><br><span class="line">return order;</span><br></pre></td></tr></table></figure><h1 id="第四章-Sentinel–服务容错"><a href="#第四章-Sentinel–服务容错" class="headerlink" title="第四章 Sentinel–服务容错"></a>第四章 Sentinel–服务容错</h1><h2 id="4-1-高并发带来的问题"><a href="#4-1-高并发带来的问题" class="headerlink" title="4.1  高并发带来的问题"></a>4.1  高并发带来的问题</h2><p>在微服务架构中，我们将业务拆分成一个个的服务，服务与服务之间可以相互调用，但是由于网络 原因或者自身的原因，服务并不能保证服务的100%可用，如果单个服务出现问题，调用这个服务就会  出现网络延迟，此时若有大量的网络涌入，会形成任务堆积，最终导致服务瘫痪。</p><p><strong>接下来，我们来模拟一个高并发的场景</strong></p><p>1 编写java代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController2 &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductFeginService productFeginService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;order&#x2F;prod&#x2F;&#123;pid&#125;&quot;)</span><br><span class="line">    public Order saveOrder(@PathVariable(&quot;pid&quot;)Integer pid) &#123;</span><br><span class="line">        &#x2F;&#x2F;Fegin</span><br><span class="line">        log.info(&quot;接收到&#123;&#125;号商品下单请求，调用商品微服务查询信息&quot;, pid);</span><br><span class="line"></span><br><span class="line">        Product product &#x3D; productFeginService.findProductById(pid);</span><br><span class="line"></span><br><span class="line">        log.info(&quot;查询到的商品为：&#123;&#125;&quot; + JSON.toJSONString(product));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建订单</span><br><span class="line">        Order order &#x3D; new Order();</span><br><span class="line">        order.setUid(1);</span><br><span class="line">        order.setUsername(&quot;蜡笔小新&quot;);</span><br><span class="line"></span><br><span class="line">        order.setPid(product.getPid());</span><br><span class="line">        order.setPname(product.getPname());</span><br><span class="line">        order.setPprice(product.getPprice());</span><br><span class="line"></span><br><span class="line">        order.setNumber(10);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        orderService.createOrder(order);</span><br><span class="line"></span><br><span class="line">        log.info(&quot;创建订单成功，订单为：&#123;&#125;&quot; + JSON.toJSONString(order));</span><br><span class="line"></span><br><span class="line">        return order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;测试高并发</span><br><span class="line">    @RequestMapping(&quot;&#x2F;order&#x2F;message&quot;)</span><br><span class="line">    public String msg()&#123;</span><br><span class="line">        return &quot;测试高并发&#x3D;&#x3D;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 修改配置文件中tomcat的并发数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8091</span><br><span class="line">  tomcat:</span><br><span class="line">    max-threads: 10#tomcat的最大并发值修改为10,默认是200</span><br></pre></td></tr></table></figure><ol start="3"><li><p>接下来使用压测工具,对请求进行压力测试</p><p>下载地址<a href="https://jmeter.apache.org/">https://jmeter.apache.org/</a></p></li></ol><p>第一步：修改配置，并启动软件</p><p>进入bin目录,修改jmeter.properties文件中的语言支持为language=zh_CN，然后点击jmeter.bat 启动软件。</p><p>第二步：添加线程组</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210316000840.png" alt="image-20210316000840052"></p><p>第三步：配置线程并发数</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210316000858.png" alt="image-20210316000858514"></p><p>第四步：添加Http取样</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210316000920.png" alt="image-20210316000920784"></p><p>第五步：配置取样，并启动测试</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210316000938.png" alt="image-20210316000938378"></p><ol start="4"><li><p>访问ｍessage方法观察效果</p><p>此时会发现, 由于order方法囤积了大量请求, 导致ｍessage方法的访问出现了问题，这就是<strong>服务雪崩</strong>的雏形。</p></li></ol><h2 id="4-2-服务雪崩效应"><a href="#4-2-服务雪崩效应" class="headerlink" title="4.2  服务雪崩效应"></a>4.2  服务雪崩效应</h2><p>在分布式系统中,由于网络原因或自身的原因,服务一般无法保证 100% 可用。如果一个服务出现了问题，调用这个服务就会出现线程阻塞的情况，此时若有大量的请求涌入，就会出现多条线程阻塞等  待，进而导致服务瘫痪。</p><p>由于服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是 服务故障的 <strong>“雪崩效应</strong>” 。</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210316001115.png" alt="image-20210316001115596"></p><p>雪崩发生的原因多种多样，有不合理的容量设计，或者是高并发下某一个方法响应变慢，亦或是某 台机器的资源耗尽。我们无法完全杜绝雪崩源头的发生，只有做好足够的容错，保证在一个服务发生问 题，不会影响到其它服务的正常运行。也就是＂雪落而不雪崩＂。</p><h2 id="4-3-常见容错方案"><a href="#4-3-常见容错方案" class="headerlink" title="4.3  常见容错方案"></a>4.3  常见容错方案</h2><p>要防止雪崩的扩散，我们就要做好服务的容错，容错说白了就是保护自己不被猪队友拖垮的一些措 施, 下面介绍常见的服务容错思路和组件。</p><h5 id="常见的容错思路"><a href="#常见的容错思路" class="headerlink" title="常见的容错思路"></a>常见的容错思路</h5><p>常见的容错思路有隔离、超时、限流、熔断、降级这几种，下面分别介绍一下。</p><ul><li><p>隔离</p><p>它是指将系统按照一定的原则划分为若干个服务模块，各个模块之间相对独立，无强依赖。当有故 障发生时，能将问题和影响隔离在某个模块内部，而不扩散风险，不波及其它模块，不影响整体的 系统服务。常见的隔离方式有：线程池隔离和信号量隔离．</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210316001225.png" alt="image-20210316001225772"></p></li><li><p>超时</p></li></ul><p>在上游服务调用下游服务的时候，设置一个最大响应时间，如果超过这个时间，下游未作出反应， 就断开请求，释放掉线程。</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210316001256.png" alt="image-20210316001255906"></p><ul><li>限流</li></ul><p>限流就是限制系统的输入和输出流量已达到保护系统的目的。为了保证系统的稳固运行,一旦达到 的需要限制的阈值,就需要限制流量并采取少量措施以完成限制流量的目的。</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210316001320.png" alt="image-20210316001320683"></p><ul><li><strong>熔断</strong> </li></ul><p>在互联网系统中，当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体的可用性，可以暂时切断对下游服务的调用。这种牺牲局部，保全整体的措施就叫做熔断。</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210316001349.png" alt="image-20210316001349562"></p><p>服务熔断一般有三种状态：</p><ol><li>熔断关闭状态（Closed）</li></ol><p>服务没有故障时，熔断器所处的状态，对调用方的调用不做任何限制</p><ol start="2"><li>熔断开启状态（Open）</li></ol><p>后续对该服务接口的调用不再经过网络，直接执行本地的fallback方法</p><ol start="3"><li>半熔断状态（Half-Open）</li></ol><p>尝试恢复服务调用，允许有限的流量调用该服务，并监控调用成功率。如果成功率达到预  期，则说明服务已恢复，进入熔断关闭状态；如果成功率仍旧很低，则重新进入熔断关闭状态。</p><ul><li>降级</li></ul><p>降级其实就是为服务提供一个托底方案，一旦服务无法正常调用，就使用托底方案</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210316001616.png" alt="image-20210316001616481"></p><h5 id="常见的容错组件"><a href="#常见的容错组件" class="headerlink" title="常见的容错组件"></a>常见的容错组件</h5><ul><li><strong>Hystrix</strong></li></ul><p>Hystrix是由Netﬂix开源的一个延迟和容错库，用于隔离访问远程系统、服务或者第三方库，防止  级联失败，从而提升系统的可用性与容错性。</p><ul><li><strong>Resilience4J</strong></li></ul><p>Resilicence4J一款非常轻量、简单，并且文档非常清晰、丰富的熔断工具，这也是Hystrix官方推 荐的替代产品。不仅如此，Resilicence4j还原生支持Spring Boot 1.x/2.x，而且监控也支持和prometheus等多款主流产品进行整合</p><ul><li><strong>Sentinel</strong></li></ul><p>Sentinel  是阿里巴巴开源的一款断路器实现，本身在阿里内部已经被大规模采用，非常稳定。下面是三个组件在各方面的对比：</p><table><thead><tr><th></th><th align="center"><strong>Sentinel</strong></th><th align="center"><strong>Hystrix</strong></th><th align="center"><strong>resilience4j</strong></th></tr></thead><tbody><tr><td>隔离策略</td><td align="center">信号量隔离（并发线程数限流）</td><td align="center">线程池隔离/信号量隔离</td><td align="center">信号量隔离</td></tr><tr><td>熔断降级策略</td><td align="center">基于响应时间、异常比率、异常数</td><td align="center">基于异常比率</td><td align="center">基于异常比率、响应时间</td></tr><tr><td>实时统计实现</td><td align="center">滑动窗口（LeapArray）</td><td align="center">滑动窗口（基于 RxJava）</td><td align="center">Ring Bit Buﬀer</td></tr><tr><td>动态规则配置</td><td align="center">支持多种数据源</td><td align="center">支持多种数据源</td><td align="center">有限支持</td></tr><tr><td>扩展性</td><td align="center">多个扩展点</td><td align="center">插件的形式</td><td align="center">接口的形式</td></tr><tr><td>基于注解的支持</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td>限流</td><td align="center">基于 QPS，支持基于调用关系的限流</td><td align="center">有限的支持</td><td align="center">Rate Limiter</td></tr><tr><td>流量整形</td><td align="center">支持预热模式、匀速器模式、预热排队模式</td><td align="center">不支持</td><td align="center">简单的 Rate Limiter  模式</td></tr><tr><td>系统自适应保护</td><td align="center">支持</td><td align="center">不支持</td><td align="center">不支持</td></tr><tr><td>控制台</td><td align="center">提供开箱即用的控制台，可配置规则、查看秒级监控、机器发现等</td><td align="center">简单的监控查看</td><td align="center">不提供控制台，可对接其它监控系统</td></tr></tbody></table><h2 id="4-4-Sentinel入门"><a href="#4-4-Sentinel入门" class="headerlink" title="4.4  Sentinel入门"></a>4.4  Sentinel入门</h2><h3 id="4-4-1-什么是Sentinel"><a href="#4-4-1-什么是Sentinel" class="headerlink" title="4.4.1  什么是Sentinel"></a>4.4.1  什么是Sentinel</h3><p>Sentinel (分布式系统的流量防卫兵) 是阿里开源的一套用于<strong>服务容错</strong>的综合性解决方案。它以流量为切入点, 从<strong>流量控制、熔断降级、系统负载保护</strong>等多个维度来保护服务的稳定性。</p><h5 id="Sentinel-具有以下特征"><a href="#Sentinel-具有以下特征" class="headerlink" title="Sentinel 具有以下特征:"></a>Sentinel 具有以下特征:</h5><ul><li><p><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景, 例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用 应用等。</p></li><li><p><strong>完备的实时监控</strong>：Sentinel  提供了实时的监控功能。通过控制台可以看到接入应用的单台机器秒级数据, 甚至 500 台以下规模的集群的汇总运行情况。</p></li><li><p><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架/库的整合模块, 例如与 Spring Cloud、Dubbo、gRPC 的整合。只需要引入相应的依赖并进行简单的配置即可快速地接入Sentinel。</p></li><li><p><strong>完善的 SPI 扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</p></li></ul><h5 id="Sentinel-分为两个部分"><a href="#Sentinel-分为两个部分" class="headerlink" title="Sentinel 分为两个部分:"></a>Sentinel 分为两个部分:</h5><ul><li>核心库（Java 客户端）不依赖任何框架/库,能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。</li><li>控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。</li></ul><h3 id="4-4-2-微服务集成Sentinel"><a href="#4-4-2-微服务集成Sentinel" class="headerlink" title="4.4.2  微服务集成Sentinel"></a>4.4.2  微服务集成Sentinel</h3><p>为微服务集成Sentinel非常简单, 只需要加入Sentinel的依赖即可</p><p>1 在pom.xml中加入下面依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- sentinel--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2 编写一个Controller测试使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController3 &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;测试高并发</span><br><span class="line">    @RequestMapping(&quot;&#x2F;order&#x2F;message1&quot;)</span><br><span class="line">    public String msg1()&#123;</span><br><span class="line">        return &quot;message1&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;测试高并发</span><br><span class="line">    @RequestMapping(&quot;&#x2F;order&#x2F;message2&quot;)</span><br><span class="line">    public String msg2()&#123;</span><br><span class="line">        return &quot;message2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-3-安装Sentinel控制台"><a href="#4-4-3-安装Sentinel控制台" class="headerlink" title="4.4.3  安装Sentinel控制台"></a>4.4.3  安装Sentinel控制台</h3><p>Sentinel 提供一个轻量级的控制台, 它提供机器发现、单机资源实时监控以及规则管理等功能。</p><p>1 下载jar包,解压到文件夹</p><p><a href="https://github.com/alibaba/Sentinel/releases">https://github.com/alibaba/Sentinel/releases</a> </p><p>2 启动控制台</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 直接使用jar命令启动项目(控制台本身是一个SpringBoot项目)</span><br><span class="line">java -Dserver.port&#x3D;8080 -Dcsp.sentinel.dashboard.server&#x3D;localhost:8080 -Dproject.name&#x3D;sentinel-dashboard -jar sentinel-dashboard-1.7.0.jar</span><br></pre></td></tr></table></figure><p>3 修改shop-order ,在里面加入有关控制台的配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sentinel:</span><br><span class="line">   transport:</span><br><span class="line">     port: 9999    #跟控制台交流的端口</span><br><span class="line">     dashboard: localhost:8080   #指定控制台服务地址</span><br></pre></td></tr></table></figure><p>第4步: 通过浏览器访问localhost:8080 进入控制台 ( 默认用户名密码是 sentinel/sentinel )</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320140604.png" alt="image-20210320140557640"></p><h5 id="补充：了解控制台的使用原理"><a href="#补充：了解控制台的使用原理" class="headerlink" title="补充：了解控制台的使用原理"></a>补充：了解控制台的使用原理</h5><p>Sentinel的控制台其实就是一个SpringBoot编写的程序。我们需要将我们的微服务程序注册到控制台上,  即在微服务中指定控制台的地址, 并且还要开启一个跟控制台传递数据的端口, 控制台也可以通过此端口调用微服务中的监控程序获取微服务的各种信息。</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320140709.png" alt="image-20210320140709649"></p><h3 id="4-4-4-实现一个接口的限流"><a href="#4-4-4-实现一个接口的限流" class="headerlink" title="4.4.4  实现一个接口的限流"></a>4.4.4  实现一个接口的限流</h3><p>1 通过控制台为message1添加一个流控规则</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320140807.png" alt="image-20210320140807576"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320140846.png" alt="image-20210320140845917"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320140900.png" alt="image-20210320140900169"></p><h2 id="4-5-Sentinel的概念和功能"><a href="#4-5-Sentinel的概念和功能" class="headerlink" title="4.5  Sentinel的概念和功能"></a>4.5  Sentinel的概念和功能</h2><h3 id="4-5-1-基本概念"><a href="#4-5-1-基本概念" class="headerlink" title="4.5.1  基本概念"></a>4.5.1  基本概念</h3><ul><li><p>资源</p><p>资源就是sentinel要保护的东西</p><p>资源是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，可以是一个服务，也可以是一个方法，甚至可以是一段代码。</p></li><li><p>规则</p><p>规则就是用来规定如何保护资源</p><p>作用在资源之上, 定义以什么样的方式保护资源，主要包括流量控制规则、熔断降级规则以及系统保护规则。</p></li></ul><h3 id="4-5-2-重要功能"><a href="#4-5-2-重要功能" class="headerlink" title="4.5.2  重要功能"></a>4.5.2  重要功能</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320141107.png" alt="image-20210320141107398"></p><p>Sentinel的主要功能就是容错，主要体现为下面这三个：</p><ul><li><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4></li></ul><p>流量控制在网络传输中是一个常用的概念，它用于调整网络包的数据。任意时间到来的请求往往是 随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状。</p><ul><li><h4 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h4></li></ul><p>当检测到调用链路中某个资源出现不稳定的表现，例如请求响应时间长或异常比例升高的时候，则 对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联故障。</p><p>Sentinel 对这个问题采取了两种手段: </p><ul><li>通过并发线程数进行限制</li></ul><p>Sentinel  通过限制资源并发线程的数量，来减少不稳定资源对其它资源的影响。当某个资源出现不稳定的情况下，例如响应时间变长，对资源的直接影响就是会造成线程数的逐步堆  积。当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝。堆积的 线程完成任务后才开始继续接收请求。</p><ul><li>通过响应时间对资源进行降级</li></ul><p>除了对并发线程数进行控制以外，Sentinel  还可以通过响应时间来快速降级不稳定的资源。当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的 时间窗口之后才重新恢复。</p><p><strong>Sentinel和Hystrix的区别</strong></p><p>两者的原则是一致的, 都是当一个资源出现问题时, 让其快速失败, 不要波及到其它服务但是在限制的手段上, 确采取了完全不一样的方法:</p><p>Hystrix 采用的是线程池隔离的方式, 优点是做到了资源之间的隔离, 缺点是增加了线程切换的成本。</p><p>Sentinel 采用的是通过并发线程的数量和响应时间来对资源做限制。</p><ul><li><h4 id="系统负载保护"><a href="#系统负载保护" class="headerlink" title="系统负载保护"></a>系统负载保护</h4></li></ul><p>Sentinel 同时提供系统维度的自适应保护能力。当系统负载较高的时候，如果还持续让请求进入可能会导致系统崩溃，无法响应。在集群环境下，会把本应这台机器承载的流量转发到其 它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，Sentinel 提供了对应的保护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请求。</p><p><strong>我们需要做的事情，就是在Sentinel的资源上配置各种各样的规则，来实现各种容错的功能。</strong></p><h2 id="4-6-Sentinel规则"><a href="#4-6-Sentinel规则" class="headerlink" title="4.6  Sentinel规则"></a>4.6  Sentinel规则</h2><h3 id="4-6-1-流控规则"><a href="#4-6-1-流控规则" class="headerlink" title="4.6.1  流控规则"></a>4.6.1  流控规则</h3><p>流量控制，其原理是监控应用流量的QPS(每秒查询率) 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。</p><p>第1步: 点击簇点链路，我们就可以看到访问过的接口地址，然后点击对应的流控按钮，进入流控规则配置页面。新增流控规则界面如下:</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320141613.png" alt="image-20210320141613522"></p><p><strong>资源名</strong>：唯一名称，默认是请求路径，可自定义</p><p><strong>针对来源</strong>：指定对哪个微服务进行限流，默认指default，意思是不区分来源，全部限制</p><p><strong>阈值类型/单机阈值</strong>：</p><ul><li>QPS（每秒请求数量）: 当调用该接口的QPS达到阈值的时候，进行限流</li><li>线程数：当调用该接口的线程数达到阈值的时候，进行限流（服务与服务线程数为请求节点）</li></ul><p><strong>是否集群</strong>：暂不需要集群</p><p>接下来我们以QPS为例来研究限流规则的配置。</p><h4 id="4-6-1-1-简单配置"><a href="#4-6-1-1-简单配置" class="headerlink" title="4.6.1.1 简单配置"></a>4.6.1.1 简单配置</h4><p>我们先做一个简单配置，设置阈值类型为QPS，单机阈值为3。即每秒请求量大于3的时候开始限流。</p><p>接下来，在流控规则页面就可以看到这个配置</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320141849.png" alt="image-20210320141849195"></p><p>然后快速访问/order/message1 接口，观察效果。此时发现，当QPS &gt; 3的时候，服务就不能正常响应，而是返回Blocked by Sentinel (ﬂow limiting)结果。</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320141907.png" alt="image-20210320141907300"></p><h4 id="4-6-1-2-配置流控模式"><a href="#4-6-1-2-配置流控模式" class="headerlink" title="4.6.1.2 配置流控模式"></a>4.6.1.2 配置流控模式</h4><p>点击上面设置流控规则的<strong>编辑</strong>按钮，然后在编辑页面点击<strong>高级选项</strong>，会看到有流控模式一栏。</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320142022.png" alt="image-20210320142022231"></p><p>sentinel共有三种流控模式，分别是：</p><ul><li>直接（默认）：接口达到限流条件时，开启限流</li><li>关联：当关联的资源达到限流条件时，开启限流 [适合做应用让步]</li><li>链路：当从某个接口过来的资源达到限流条件时，开启限流</li></ul><p>下面呢分别演示三种模式：</p><h5 id="直接流控模式"><a href="#直接流控模式" class="headerlink" title="直接流控模式"></a>直接流控模式</h5><p>直接流控模式是最简单的模式，当指定的接口达到限流条件时开启限流。上面案例使用的就是直接流控 模式。</p><h5 id="关联流控模式"><a href="#关联流控模式" class="headerlink" title="关联流控模式"></a>关联流控模式</h5><p>关联流控模式指的是，当指定接口关联的接口达到限流条件时，开启对指定接口开启限流。</p><p>第1步：配置限流规则, 将流控模式设置为关联，关联资源设置为的 /order/message2。</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320142221.png" alt="image-20210320142221070"></p><p>第2步：通过JMeter软件向/order/message2连续发送请求，注意QPS一定要大于3</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320142343.png" alt="image-20210320142343461"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320142406.png" alt="image-20210320142406866"></p><p>第3步：访问/order/message1,会发现已经被限流</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320142430.png" alt="image-20210320142430053"></p><h5 id="链路流控模式"><a href="#链路流控模式" class="headerlink" title="链路流控模式"></a>链路流控模式</h5><p>链路流控模式指的是，当从某个接口过来的资源达到限流条件时，开启限流。它的功能有点类似于针对 来源配置项，区别在于：<strong>针对来源是针对上级微服务，而链路流控是针对上级接口，也就是说它的粒度 更细。</strong></p><p>第1步： 编写一个service，在里面添加一个方法message</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class OrderServiceImpl3 &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;定义资源，指定资源名</span><br><span class="line">    @SentinelResource(&quot;message&quot;)</span><br><span class="line">    public String message()&#123;</span><br><span class="line">        return &quot;message&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第2步： 在Controller中声明两个方法，分别调用service中的方法m</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController3 &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderServiceImpl3 orderServiceImpl3;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;测试高并发</span><br><span class="line">    @RequestMapping(&quot;&#x2F;order&#x2F;message1&quot;)</span><br><span class="line">    public String msg1()&#123;</span><br><span class="line">        orderServiceImpl3.message();</span><br><span class="line">        return &quot;message1&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;测试高并发</span><br><span class="line">    @RequestMapping(&quot;&#x2F;order&#x2F;message2&quot;)</span><br><span class="line">    public String msg2()&#123;</span><br><span class="line">        orderServiceImpl3.message();</span><br><span class="line">        return &quot;message2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第3步: 禁止收敛URL的入口 context</p><p>从1.6.3 版本开始，Sentinel Web ﬁlter默认收敛所有URL的入口context，因此链路限流不生效</p><p>1.7.0 版本开始（对应SCA的2.1.1.RELEASE)，官方在CommonFilter 引入了WEB_CONTEXT_UNIFY参数，用于控制是否收敛context。将其配置为false即可根据不同的URL进行链路限流</p><p>SCA  2.1.1.RELEASE之后的版本,可以通过配置spring.cloud.sentinel.web-context-unify=false即可关闭收敛</p><p>我们当前使用的版本是SpringCloud Alibaba 2.1.0.RELEASE，无法实现链路限流。</p><p>我们当前使用的版本是SpringCloud Alibaba 2.1.0.RELEASE，无法实现链路限流。</p><p><strong>(1)</strong> 暂时将SpringCloud Alibaba的版本调整为2.1.1.RELEASE</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;spring-cloud-alibaba.version&gt;2.1.1.RELEASE&lt;&#x2F;spring-cloud-alibaba.version&gt;</span><br></pre></td></tr></table></figure><p><strong>(2)</strong> 配置文件中关闭sentinel的CommonFilter实例化</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">sentinel:</span><br><span class="line">filter:</span><br><span class="line">enabled: false</span><br></pre></td></tr></table></figure><p><strong>(3)</strong> 添加一个配置类，自己构建CommonFilter实例</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FilterContextConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public FilterRegistrationBean sentinelFilterRegistration() &#123;</span><br><span class="line">        FilterRegistrationBean registration &#x3D; new FilterRegistrationBean();</span><br><span class="line">        registration.setFilter(new CommonFilter());</span><br><span class="line">        registration.addUrlPatterns(&quot;&#x2F;*&quot;);</span><br><span class="line">        &#x2F;&#x2F; 入口资源关闭聚合</span><br><span class="line">        registration.addInitParameter(CommonFilter.WEB_CONTEXT_UNIFY, &quot;false&quot;);</span><br><span class="line">        registration.setName(&quot;sentinelFilter&quot;);</span><br><span class="line">        registration.setOrder(1);</span><br><span class="line">        return registration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第4步: 控制台配置限流规则</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320144729.png" alt="image-20210320144729507"></p><p>第5步: 分别通过/order/message1 和/order/message2 访问, 发现1没问题, 2的被限流了</p><h4 id="4-6-1-3-配置流控效果"><a href="#4-6-1-3-配置流控效果" class="headerlink" title="4.6.1.3 配置流控效果"></a>4.6.1.3 配置流控效果</h4><ul><li><strong>快速失败（默认）</strong>: 直接失败，抛出异常，不做任何额外的处理，是最简单的效果</li><li><strong>Warm Up</strong>：它从开始阈值到最大QPS阈值会有一个缓冲阶段，一开始的阈值是最大QPS阈值的1/3，然后慢慢增长，直到最大阈值，适用于将突然增大的流量转换为缓步增长的场景</li><li><strong>排队等待</strong>：让请求以均匀的速度通过，单机阈值为每秒通过数量，其余的排队等待； 它还会让设置一个超时时间，当请求超过超时间时间还未处理，则会被丢弃</li></ul><h3 id="4-6-2-降级规则"><a href="#4-6-2-降级规则" class="headerlink" title="4.6.2  降级规则"></a>4.6.2  降级规则</h3><p>降级规则就是设置当满足什么条件的时候，对服务进行降级。Sentinel提供了三个衡量条件：</p><p>平均响应时间 ：当资源的平均响应时间超过阈值（以 ms 为单位）之后，资源进入准降级状态。如果接下来 1s 内持续进入 5 个请求，它们的 RT都持续超过这个阈值，那么在接下的时间窗口（以 s 为单位）之内，就会对这个方法进行服务降级。</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320150116.png" alt="image-20210320150116418"></p><p>注意 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt=xxx 来配置。</p><ul><li>异常比例：当资源的每秒异常总数占通过量的比值超过阈值之后，资源进入降级状态，即在接下的 时间窗口（以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 [0.0,1.0]</li></ul><p>第1步: 首先模拟一个异常</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;测试高并发</span><br><span class="line">@RequestMapping(&quot;&#x2F;order&#x2F;message1&quot;)</span><br><span class="line">public String msg1()&#123;</span><br><span class="line"></span><br><span class="line">    i++;</span><br><span class="line">    if (i % 3 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;        orderServiceImpl3.message();</span><br><span class="line">    return &quot;message1&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第2步: 设置异常比例为0.25</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320150242.png" alt="image-20210320150242295"></p><ul><li>异常数：当资源近 1 分钟的异常数目超过阈值之后会进行服务降级。注意由于统计时间窗口是分钟级别的，若时间窗口小于 60s，则结束熔断状态后仍可能再进入熔断状态。</li></ul><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320150428.png" alt="image-20210320150428185"></p><p>问题：</p><p>流控规则和降级规则返回的异常页面是一样的，我们怎么来区分到底是什么原因导致的呢？</p><h3 id="4-6-3-热点规则"><a href="#4-6-3-热点规则" class="headerlink" title="4.6.3  热点规则"></a>4.6.3  热点规则</h3><p>热点参数流控规则是一种更细粒度的流控规则, 它允许将规则具体到参数上。</p><h5 id="热点规则简单使用"><a href="#热点规则简单使用" class="headerlink" title="热点规则简单使用"></a>热点规则简单使用</h5><p>第1步: 编写代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;order&#x2F;message3&quot;)</span><br><span class="line">    @SentinelResource(&quot;message3&quot;)</span><br><span class="line">    public String msg3(String name,Integer age)&#123;</span><br><span class="line">        return &quot;message3&quot;+name+age;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第2步: 配置热点规则</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320152439.png" alt="image-20210320152438916"></p><p>第3步: 分别用两个参数访问,会发现只对第二个参数限流了</p><h5 id="热点规则增强使用"><a href="#热点规则增强使用" class="headerlink" title="热点规则增强使用"></a>热点规则增强使用</h5><p>参数例外项允许对一个参数的具体值进行流控编辑刚才定义的规则,增加参数例外项</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320152541.png" alt="image-20210320152541638"></p><h3 id="4-6-4-授权规则"><a href="#4-6-4-授权规则" class="headerlink" title="4.6.4  授权规则"></a>4.6.4  授权规则</h3><p>很多时候，我们需要根据调用来源来判断该次请求是否允许放行，这时候可以使用 Sentinel 的来源访问控制的功能。来源访问控制根据资源的请求来源（origin）限制资源是否通过：</p><ul><li><p>若配置白名单，则只有请求来源位于白名单内时才可通过</p></li><li><p>若配置黑名单，则请求来源位于黑名单时不通过，其余的请求通过</p></li></ul><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320153517.png" alt="image-20210320153517085"></p><p>上面的资源名和授权类型不难理解，但是流控应用怎么填写呢？</p><p>其实这个位置要填写的是来源标识，Sentinel提供了RequestOriginParser接口来处理来源</p><p>只要Sentinel保护的接口资源被访问，Sentinel就会调用RequestOriginParser的实现类去解析访问来源。</p><p>第1步: 自定义来源处理规则</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RequestOriginParserDefinition implements RequestOriginParser &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;定义区分来源：本质作用是通过request域获取到来源标识</span><br><span class="line">    &#x2F;&#x2F; app pc</span><br><span class="line">    &#x2F;&#x2F;然后交给流控应用 进行匹配</span><br><span class="line">    @Override</span><br><span class="line">    public String parseOrigin(HttpServletRequest httpServletRequest) &#123;</span><br><span class="line">        String serviceName &#x3D; httpServletRequest.getParameter(&quot;serviceName&quot;);</span><br><span class="line">        if (StringUtils.isEmpty(serviceName)) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;serviceName is Empty&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return serviceName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第2步: 授权规则配置</p><p>这个配置的意思是只有serviceName=pc不能访问(黑名单)</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320153714.png" alt="image-20210320153714373"></p><h3 id="4-6-5-系统规则"><a href="#4-6-5-系统规则" class="headerlink" title="4.6.5  系统规则"></a>4.6.5  系统规则</h3><p>系统保护规则是从应用级别的入口流量进行控制，从单台机器的总体 Load、RT、入口 QPS 、CPU 使用率和线程数五个维度监控应用数据，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p><p>系统保护规则是应用整体维度的，而不是资源维度的，并且仅对入口流量 (进入应用的流量) 生效。</p><ul><li>Load（仅对 Linux/Unix-like 机器生效）：当系统 load1 超过阈值，且系统当前的并发线程数超过系统容量时才会触发系统保护。系统容量由系统的 maxQps * minRt 计算得出。设定参考值一般 是 CPU cores * 2.5。</li><li>RT：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</li><li>线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护</li><li>入口 QPS：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护</li><li>CPU使用率：当单台机器上所有入口流量的 CPU使用率达到阈值即触发系统保护</li></ul><p><strong>扩展</strong>:自定义异常返回</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: wbnn</span><br><span class="line"> * @Date: 2021&#x2F;03&#x2F;20&#x2F;</span><br><span class="line"> * @Description:自定义异常处理页面</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">public class ExceptionHandlerPage implements UrlBlockHandler &#123;</span><br><span class="line">    &#x2F;&#x2F;BlockException 异常接口,包含Sentinel的五个异常</span><br><span class="line">    &#x2F;&#x2F; FlowException 限流异常</span><br><span class="line">    &#x2F;&#x2F; DegradeException 降级异常</span><br><span class="line">    &#x2F;&#x2F; ParamFlowException 参数限流异常</span><br><span class="line">    &#x2F;&#x2F; AuthorityException 授权异常</span><br><span class="line">    &#x2F;&#x2F; SystemBlockException 系统负载异常</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void blocked(HttpServletRequest request, HttpServletResponse response, BlockException e) throws IOException &#123;</span><br><span class="line">        response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">        ResponseData responseData &#x3D; null;</span><br><span class="line">        if (e instanceof FlowException) &#123;</span><br><span class="line">            responseData &#x3D; new ResponseData(-1,&quot;接口限流&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        &#125; else if (e instanceof DegradeException) &#123;</span><br><span class="line">            responseData &#x3D; new ResponseData(-2,&quot;接口降级&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        response.getWriter().write(JSON.toJSONString(responseData));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">class ResponseData &#123;</span><br><span class="line">    private int code;</span><br><span class="line">    private String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-7-SentinelResource的使用"><a href="#4-7-SentinelResource的使用" class="headerlink" title="4.7  @SentinelResource的使用"></a>4.7  @SentinelResource的使用</h2><p>在定义了资源点之后，我们可以通过Dashboard来设置限流和降级策略来对资源点进行保护。同时还能  通过@SentinelResource来指定出现异常时的处理策略。</p><p>@SentinelResource用于定义资源，并提供可选的异常处理和 fallback 配置项。其主要参数如下：</p><table><thead><tr><th><strong>属性</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>value</td><td>资源名称</td></tr><tr><td>entryType</td><td>entry类型，标记流量的方向，取值IN/OUT，默认是OUT</td></tr><tr><td>blockHandler</td><td>处理BlockException的函数名称,函数要求：  1. 必须是 public  2.返回类型 参数与原方法一致  3. 默认需和原方法在同一个类中。若希望使用其他类的函数，可配置  blockHandlerClass ，并指定blockHandlerClass里面的方法。</td></tr><tr><td>blockHandlerClass</td><td>存放blockHandler的类,对应的处理函数必须static修饰。</td></tr><tr><td>fallback</td><td>用于在抛出异常的时候提供fallback处理逻辑。fallback函数可以针对所有类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。函数要求：  1. 返回类型与原方法一致  2. 参数类型需要和原方法相匹配  3. 默认需和原方法在同一个类中。若希望使用其他类的函数，可配置  fallbackClass ，并指定fallbackClass里面的方法。</td></tr><tr><td>fallbackClass</td><td>存放fallback的类。对应的处理函数必须static修饰。</td></tr><tr><td>defaultFallback</td><td>用于通用的 fallback 逻辑。默认fallback函数可以针对所有类型的异常进行处理。若同时配置了 fallback 和 defaultFallback，以fallback为准。函数要求：  1. 返回类型与原方法一致  2. 方法参数列表为空，或者有一个 Throwable 类型的参数。  3. 默认需要和原方法在同一个类中。若希望使用其他类的函数，可配置  fallbackClass ，并指定 fallbackClass 里面的方法。</td></tr><tr><td>exceptionsToIgnore</td><td>指定排除掉哪些异常。排除的异常不会计入异常统计，也不会进入  fallback逻辑，而是原样抛出。</td></tr><tr><td>exceptionsToTrace</td><td>需要trace的异常</td></tr></tbody></table><h3 id="定义限流和降级后的处理方法"><a href="#定义限流和降级后的处理方法" class="headerlink" title="定义限流和降级后的处理方法"></a>定义限流和降级后的处理方法</h3><p>方式一：直接将限流和降级方法定义在方法中</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderServiceImpl3 &#123;</span><br><span class="line"></span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;定义资源，指定资源名</span><br><span class="line">    &#x2F;&#x2F;定义当资源内部发生异常的时候的处理逻辑</span><br><span class="line">    &#x2F;&#x2F;blockHandler 定义当资源内部发生了BlockException应该进入的方法【捕获的是sentinel的异常】</span><br><span class="line">    &#x2F;&#x2F;fallback 定义当资源内部发生了Throwable应该进入的方法</span><br><span class="line">    @SentinelResource(value &#x3D; &quot;message&quot;,</span><br><span class="line">            blockHandler &#x3D; &quot;blockHandler&quot;,</span><br><span class="line">            fallback &#x3D; &quot;fallback&quot;</span><br><span class="line">    )</span><br><span class="line">    public String message(String name)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        if (i % 3 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            throw new RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;message&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;blockHandler</span><br><span class="line">    &#x2F;&#x2F;要求：</span><br><span class="line">    &#x2F;&#x2F;1.当前方法的返回值和参数要跟原方法一致</span><br><span class="line">    &#x2F;&#x2F;2.但是允许在参数列表的最后加入一个参数BlockException,用来接收原方法中发生的异常</span><br><span class="line">    public  String blockHandler(String name, BlockException e)&#123;</span><br><span class="line">        &#x2F;&#x2F;自定义异常逻辑</span><br><span class="line">        log.error(&quot;触发了BlockException，为&#123;&#125;&quot;,e);</span><br><span class="line">        return &quot;BlockException&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      &#x2F;&#x2F;fallback</span><br><span class="line">    &#x2F;&#x2F;要求：</span><br><span class="line">    &#x2F;&#x2F;1.当前方法的返回值和参数要跟原方法一致</span><br><span class="line">    &#x2F;&#x2F;2.但是允许在参数列表的最后加入一个参数Throwable,用来接收原方法中发生的异常</span><br><span class="line">    public  String fallback(String name, Throwable e)&#123;</span><br><span class="line">        &#x2F;&#x2F;自定义异常逻辑</span><br><span class="line">        log.error(&quot;触发了Throwable，为&#123;&#125;&quot;,e);</span><br><span class="line">        return &quot;Throwable&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二: 将限流和降级方法外置到单独的类中</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderServiceImpl3 &#123;</span><br><span class="line"></span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;定义资源，指定资源名</span><br><span class="line">    &#x2F;&#x2F;定义当资源内部发生异常的时候的处理逻辑</span><br><span class="line">    &#x2F;&#x2F;blockHandler 定义当资源内部发生了BlockException应该进入的方法【捕获的是sentinel的异常】</span><br><span class="line">    &#x2F;&#x2F;fallback 定义当资源内部发生了Throwable应该进入的方法</span><br><span class="line">    @SentinelResource(value &#x3D; &quot;message&quot;,</span><br><span class="line">            blockHandlerClass &#x3D; OrderServiceImpl3BlockHandler.class,</span><br><span class="line">            blockHandler &#x3D; &quot;blockHandler&quot;,</span><br><span class="line">            fallbackClass &#x3D; OrderServiceImpl3Fallback.class,</span><br><span class="line">            fallback &#x3D; &quot;fallback&quot;</span><br><span class="line">    )</span><br><span class="line">    public String message(String name)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        if (i % 3 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            throw new RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;message&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderServiceImpl3BlockHandler &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;blockHandler</span><br><span class="line">    &#x2F;&#x2F;要求：</span><br><span class="line">    &#x2F;&#x2F;1.当前方法的返回值和参数要跟原方法一致</span><br><span class="line">    &#x2F;&#x2F;2.但是允许在参数列表的最后加入一个参数BlockException,用来接收原方法中发生的异常</span><br><span class="line">    public static String blockHandler(String name, BlockException e)&#123;</span><br><span class="line">        &#x2F;&#x2F;自定义异常逻辑</span><br><span class="line">        log.error(&quot;触发了BlockException，为&#123;&#125;&quot;,e);</span><br><span class="line">        return &quot;BlockException&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderServiceImpl3Fallback &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;fallback</span><br><span class="line">    &#x2F;&#x2F;要求：</span><br><span class="line">    &#x2F;&#x2F;1.当前方法的返回值和参数要跟原方法一致</span><br><span class="line">    &#x2F;&#x2F;2.但是允许在参数列表的最后加入一个参数Throwable,用来接收原方法中发生的异常</span><br><span class="line">    public static String fallback(String name, Throwable e)&#123;</span><br><span class="line">        &#x2F;&#x2F;自定义异常逻辑</span><br><span class="line">        log.error(&quot;触发了Throwable，为&#123;&#125;&quot;,e);</span><br><span class="line">        return &quot;Throwable&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-8-Sentinel规则持久化"><a href="#4-8-Sentinel规则持久化" class="headerlink" title="4.8  Sentinel规则持久化"></a>4.8  Sentinel规则持久化</h2><p>通过前面的讲解，我们已经知道，可以通过Dashboard来为每个Sentinel客户端设置各种各样的规  则，但是这里有一个问题，就是这些规则默认是存放在内存中，极不稳定，所以需要将其持久化。</p><p>本地文件数据源会定时轮询文件的变更，读取规则。这样我们既可以在应用本地直接修改文件来更 新规则，也可以通过 Sentinel 控制台推送规则。以本地文件数据源为例，推送过程如下图所示：</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320213421.png" alt="image-20210320213421590"></p><p>首先 Sentinel 控制台通过 API 将规则推送至客户端并更新到内存中，接着注册的写数据源会将新的规则保存到本地的文件中。</p><p>1 编写处理类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wb.order.config;</span><br><span class="line"></span><br><span class="line">import com.alibaba.csp.sentinel.command.handler.ModifyParamFlowRulesCommandHandler;</span><br><span class="line">import com.alibaba.csp.sentinel.datasource.*;</span><br><span class="line">import com.alibaba.csp.sentinel.init.InitFunc;</span><br><span class="line">import com.alibaba.csp.sentinel.slots.block.authority.AuthorityRule;</span><br><span class="line">import com.alibaba.csp.sentinel.slots.block.authority.AuthorityRuleManager;</span><br><span class="line">import com.alibaba.csp.sentinel.slots.block.degrade.DegradeRule;</span><br><span class="line">import com.alibaba.csp.sentinel.slots.block.degrade.DegradeRuleManager;</span><br><span class="line">import com.alibaba.csp.sentinel.slots.block.flow.FlowRule;</span><br><span class="line">import com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;</span><br><span class="line">import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowRule;</span><br><span class="line">import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowRuleManager;</span><br><span class="line">import com.alibaba.csp.sentinel.slots.system.SystemRule;</span><br><span class="line">import com.alibaba.csp.sentinel.slots.system.SystemRuleManager;</span><br><span class="line">import com.alibaba.csp.sentinel.transport.util.WritableDataSourceRegistry;</span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.TypeReference;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: wbnn</span><br><span class="line"> * @Date: 2021&#x2F;03&#x2F;20&#x2F;</span><br><span class="line"> * @Description: 规则持久化</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class FilePersistence implements InitFunc &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;spring.application.name&quot;)</span><br><span class="line">    private String appcationName;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init() throws Exception &#123;</span><br><span class="line">        String ruleDir &#x3D; System.getProperty(&quot;user.home&quot;) + &quot;&#x2F;sentinel-rules&#x2F;&quot; + appcationName;</span><br><span class="line">        String flowRulePath &#x3D; ruleDir + &quot;&#x2F;flow-rule.json&quot;;</span><br><span class="line">        String degradeRulePath &#x3D; ruleDir + &quot;&#x2F;degrade-rule.json&quot;;</span><br><span class="line">        String systemRulePath &#x3D; ruleDir + &quot;&#x2F;system-rule.json&quot;;</span><br><span class="line">        String authorityRulePath &#x3D; ruleDir + &quot;&#x2F;authority-rule.json&quot;;</span><br><span class="line">        String paramFlowRulePath &#x3D; ruleDir + &quot;&#x2F;param-flow-rule.json&quot;;</span><br><span class="line"></span><br><span class="line">        this.mkdirIfNotExits(ruleDir);</span><br><span class="line">        this.createFileIfNotExits(flowRulePath);</span><br><span class="line">        this.createFileIfNotExits(degradeRulePath);</span><br><span class="line">        this.createFileIfNotExits(systemRulePath);</span><br><span class="line">        this.createFileIfNotExits(authorityRulePath);</span><br><span class="line">        this.createFileIfNotExits(paramFlowRulePath);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 流控规则</span><br><span class="line">        ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; flowRuleRDS &#x3D; new FileRefreshableDataSource&lt;&gt;(</span><br><span class="line">                flowRulePath,</span><br><span class="line">                flowRuleListParser</span><br><span class="line">        );</span><br><span class="line">        FlowRuleManager.register2Property(flowRuleRDS.getProperty());</span><br><span class="line">        WritableDataSource&lt;List&lt;FlowRule&gt;&gt; flowRuleWDS &#x3D; new FileWritableDataSource&lt;&gt;(</span><br><span class="line">                flowRulePath,</span><br><span class="line">                this::encodeJson</span><br><span class="line">        );</span><br><span class="line">        WritableDataSourceRegistry.registerFlowDataSource(flowRuleWDS);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 降级规则</span><br><span class="line">        ReadableDataSource&lt;String, List&lt;DegradeRule&gt;&gt; degradeRuleRDS &#x3D; new FileRefreshableDataSource&lt;&gt;(</span><br><span class="line">                degradeRulePath,</span><br><span class="line">                degradeRuleListParser</span><br><span class="line">        );</span><br><span class="line">        DegradeRuleManager.register2Property(degradeRuleRDS.getProperty());</span><br><span class="line">        WritableDataSource&lt;List&lt;DegradeRule&gt;&gt; degradeRuleWDS &#x3D; new FileWritableDataSource&lt;&gt;(</span><br><span class="line">                degradeRulePath,</span><br><span class="line">                this::encodeJson</span><br><span class="line">        );</span><br><span class="line">        WritableDataSourceRegistry.registerDegradeDataSource(degradeRuleWDS);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 系统规则</span><br><span class="line">        ReadableDataSource&lt;String, List&lt;SystemRule&gt;&gt; systemRuleRDS &#x3D; new FileRefreshableDataSource&lt;&gt;(</span><br><span class="line">                systemRulePath,</span><br><span class="line">                systemRuleListParser</span><br><span class="line">        );</span><br><span class="line">        SystemRuleManager.register2Property(systemRuleRDS.getProperty());</span><br><span class="line">        WritableDataSource&lt;List&lt;SystemRule&gt;&gt; systemRuleWDS &#x3D; new FileWritableDataSource&lt;&gt;(</span><br><span class="line">                systemRulePath,</span><br><span class="line">                this::encodeJson</span><br><span class="line">        );</span><br><span class="line">        WritableDataSourceRegistry.registerSystemDataSource(systemRuleWDS);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 授权规则</span><br><span class="line">        ReadableDataSource&lt;String, List&lt;AuthorityRule&gt;&gt; authorityRuleRDS &#x3D; new FileRefreshableDataSource&lt;&gt;(</span><br><span class="line">                authorityRulePath,</span><br><span class="line">                authorityRuleListParser</span><br><span class="line">        );</span><br><span class="line">        AuthorityRuleManager.register2Property(authorityRuleRDS.getProperty());</span><br><span class="line">        WritableDataSource&lt;List&lt;AuthorityRule&gt;&gt; authorityRuleWDS &#x3D; new FileWritableDataSource&lt;&gt;(</span><br><span class="line">                authorityRulePath,</span><br><span class="line">                this::encodeJson</span><br><span class="line">        );</span><br><span class="line">        WritableDataSourceRegistry.registerAuthorityDataSource(authorityRuleWDS);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 热点参数规则</span><br><span class="line">        ReadableDataSource&lt;String, List&lt;ParamFlowRule&gt;&gt; paramFlowRuleRDS &#x3D; new FileRefreshableDataSource&lt;&gt;(</span><br><span class="line">                paramFlowRulePath,</span><br><span class="line">                paramFlowRuleListParser</span><br><span class="line">        );</span><br><span class="line">        ParamFlowRuleManager.register2Property(paramFlowRuleRDS.getProperty());</span><br><span class="line">        WritableDataSource&lt;List&lt;ParamFlowRule&gt;&gt; paramFlowRuleWDS &#x3D; new FileWritableDataSource&lt;&gt;(</span><br><span class="line">                paramFlowRulePath,</span><br><span class="line">                this::encodeJson</span><br><span class="line">        );</span><br><span class="line">        ModifyParamFlowRulesCommandHandler.setWritableDataSource(paramFlowRuleWDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Converter&lt;String, List&lt;FlowRule&gt;&gt; flowRuleListParser &#x3D; source -&gt; JSON.parseObject(</span><br><span class="line">            source,</span><br><span class="line">            new TypeReference&lt;List&lt;FlowRule&gt;&gt;() &#123;</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line">    private Converter&lt;String, List&lt;DegradeRule&gt;&gt; degradeRuleListParser &#x3D; source -&gt; JSON.parseObject(</span><br><span class="line">            source,</span><br><span class="line">            new TypeReference&lt;List&lt;DegradeRule&gt;&gt;() &#123;</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line">    private Converter&lt;String, List&lt;SystemRule&gt;&gt; systemRuleListParser &#x3D; source -&gt; JSON.parseObject(</span><br><span class="line">            source,</span><br><span class="line">            new TypeReference&lt;List&lt;SystemRule&gt;&gt;() &#123;</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    private Converter&lt;String, List&lt;AuthorityRule&gt;&gt; authorityRuleListParser &#x3D; source -&gt; JSON.parseObject(</span><br><span class="line">            source,</span><br><span class="line">            new TypeReference&lt;List&lt;AuthorityRule&gt;&gt;() &#123;</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    private Converter&lt;String, List&lt;ParamFlowRule&gt;&gt; paramFlowRuleListParser &#x3D; source -&gt; JSON.parseObject(</span><br><span class="line">            source,</span><br><span class="line">            new TypeReference&lt;List&lt;ParamFlowRule&gt;&gt;() &#123;</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    private void mkdirIfNotExits(String filePath) throws IOException &#123;</span><br><span class="line">        File file &#x3D; new File(filePath);</span><br><span class="line">        if (!file.exists()) &#123;</span><br><span class="line">            file.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void createFileIfNotExits(String filePath) throws IOException &#123;</span><br><span class="line">        File file &#x3D; new File(filePath);</span><br><span class="line">        if (!file.exists()) &#123;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private &lt;T&gt; String encodeJson(T t) &#123;</span><br><span class="line">        return JSON.toJSONString(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2 添加配置</p><p>在resources下创建配置目录META-INF/services,然后添加文件</p><p>com.alibaba.csp.sentinel.init.InitFunc</p><p>在文件中添加配置类的全路径: com.wb.order.config.FilePersistence</p><h2 id="4-9-Feign整合Sentinel"><a href="#4-9-Feign整合Sentinel" class="headerlink" title="4.9  Feign整合Sentinel"></a>4.9  Feign整合Sentinel</h2><p>第1步: 引入sentinel的依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--sentinel客户端--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>第2步: 在配置文件中开启Feign对Sentinel的支持</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feign:</span><br><span class="line">sentinel:</span><br><span class="line">enabled: true</span><br></pre></td></tr></table></figure><p> 第3步: 创建容错类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: wbnn</span><br><span class="line"> * @Date: 2021&#x2F;03&#x2F;20&#x2F;</span><br><span class="line"> * @Description: 这是一个容错类，需要实现fegin所在的接口及其中的方法</span><br><span class="line"> * fegin远程调用出问题，就会进入此类中对应的方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Service</span><br><span class="line">public class ProductFeginFallback implements ProductFeginService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Product findProductById(Integer pid) &#123;</span><br><span class="line">        &#x2F;&#x2F;容错逻辑</span><br><span class="line">        Product product &#x3D; new Product();</span><br><span class="line">        product.setPid(-100);</span><br><span class="line">        product.setPname(&quot;远程调用失败&quot;);</span><br><span class="line">        return product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第4步: 为被容器的接口指定容错类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: wbnn</span><br><span class="line"> * @Date: 2021&#x2F;03&#x2F;15&#x2F;</span><br><span class="line"> * @Description:</span><br><span class="line"> * value指定调用nacos哪个服务</span><br><span class="line"> * fallback指定当前接口的容错类</span><br><span class="line"> *&#x2F;</span><br><span class="line">@FeignClient(value &#x3D; &quot;service-product&quot;,fallback &#x3D; ProductFeginFallback.class)</span><br><span class="line">public interface ProductFeginService &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;product&#x2F;&#123;pid&#125;&quot;)</span><br><span class="line">    Product findProductById(@PathVariable(&quot;pid&quot;) Integer pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第5步: 修改controller</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: wbnn</span><br><span class="line"> * @Date: 2021&#x2F;03&#x2F;14&#x2F;</span><br><span class="line"> * @Description:</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DiscoveryClient discoveryClient;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductFeginService productFeginService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;order&#x2F;prod&#x2F;&#123;pid&#125;&quot;)</span><br><span class="line">    public Order saveOrder(@PathVariable(&quot;pid&quot;)Integer pid)&#123;</span><br><span class="line">        &#x2F;&#x2F;Fegin</span><br><span class="line">        log.info(&quot;接收到&#123;&#125;号商品下单请求，调用商品微服务查询信息&quot;,pid);</span><br><span class="line"></span><br><span class="line">        Product product &#x3D;productFeginService.findProductById(pid);</span><br><span class="line"></span><br><span class="line">        if (product.getPid() &#x3D;&#x3D; -100) &#123;</span><br><span class="line">            Order order &#x3D; new Order();</span><br><span class="line">            order.setPid(-100);</span><br><span class="line">            order.setPname(&quot;下单失败&quot;);</span><br><span class="line">            return order;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(&quot;查询到的商品为：&#123;&#125;&quot;+ JSON.toJSONString(product));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建订单</span><br><span class="line">        Order order &#x3D; new Order();</span><br><span class="line">        order.setUid(1);</span><br><span class="line">        order.setUsername(&quot;蜡笔小新&quot;);</span><br><span class="line"></span><br><span class="line">        order.setPid(product.getPid());</span><br><span class="line">        order.setPname(product.getPname());</span><br><span class="line">        order.setPprice(product.getPprice());</span><br><span class="line"></span><br><span class="line">        order.setNumber(10);</span><br><span class="line"></span><br><span class="line">        orderService.createOrder(order);</span><br><span class="line"></span><br><span class="line">        log.info(&quot;创建订单成功，订单为：&#123;&#125;&quot;+ JSON.toJSONString(order));</span><br><span class="line"></span><br><span class="line">        return order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第6步: 停止所有shop-product服务，访问/order/prod/{pid}，观察容错效果</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320220503.png" alt="image-20210320220503077"></p><p><strong>扩展</strong>: 如果想在容错类中拿到具体的错误,可以使用下面的方式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Service</span><br><span class="line">public class ProductFeginFallbackFactory implements FallbackFactory&lt;ProductFeginService&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ProductFeginService create(Throwable cause) &#123;</span><br><span class="line">        return new ProductFeginService() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Product findProductById(Integer pid) &#123;</span><br><span class="line"></span><br><span class="line">                log.error(&quot;&#123;&#125;&quot;,cause);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;容错逻辑</span><br><span class="line">                Product product &#x3D; new Product();</span><br><span class="line">                product.setPid(-100);</span><br><span class="line">                product.setPname(&quot;远程调用失败&quot;);</span><br><span class="line">                return product;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FeignClient(value &#x3D; &quot;service-product&quot;,</span><br><span class="line">&#x2F;&#x2F;        fallback &#x3D; ProductFeginFallback.class,</span><br><span class="line">        fallbackFactory &#x3D; ProductFeginFallbackFactory.class</span><br><span class="line">)</span><br><span class="line">public interface ProductFeginService &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;product&#x2F;&#123;pid&#125;&quot;)</span><br><span class="line">    Product findProductById(@PathVariable(&quot;pid&quot;) Integer pid);</span><br><span class="line">&#125;</span><br><span class="line">注意: fallback和fallbackFactory只能使用其中一种方式</span><br></pre></td></tr></table></figure><h1 id="第五章-Gateway–服务网关"><a href="#第五章-Gateway–服务网关" class="headerlink" title="第五章 Gateway–服务网关"></a>第五章 Gateway–服务网关</h1><h2 id="5-1-网关简介"><a href="#5-1-网关简介" class="headerlink" title="5.1  网关简介"></a>5.1  网关简介</h2><p>大家都都知道在微服务架构中，一个系统会被拆分为很多个微服务。那么作为客户端要如何去调用 这么多的微服务呢？如果没有网关的存在，我们只能在客户端记录每个微服务的地址，然后分别去调用。</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320221453.png" alt="image-20210320221453421"></p><p>这样的架构，会存在着诸多的问题：</p><ul><li>客户端多次请求不同的微服务，增加客户端代码或配置编写的复杂性</li><li>认证复杂，每个服务都需要独立认证</li><li>存在跨域请求，在一定场景下处理相对复杂</li></ul><p>上面的这些问题可以借助<strong>API网关</strong>来解决</p><p>所谓的API网关，就是指系统的<strong>统一入口</strong>，它封装了应用程序的内部结构，为客户端提供统一服务，一些与业务本身功能无关的公共逻辑可以在这里实现，诸如认证、鉴权、监控、路由转发等等。 添加上API网关之后，系统的架构图变成了如下所示：</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320221602.png" alt="image-20210320221602637"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210320221619.png" alt="image-20210320221618960"></p><p>在业界比较流行的网关，有下面这些：</p><ul><li><strong>Ngnix+lua</strong></li></ul><p>使用nginx的反向代理和负载均衡可实现对api服务器的负载均衡及高可用</p><p>lua是一种脚本语言,可以来编写一些简单的逻辑, nginx支持lua脚本</p><ul><li><strong>Kong</strong></li></ul><p>基于Nginx+Lua开发，性能高，稳定，有多个可用的插件(限流、鉴权等等)可以开箱即用。 问题： 只支持Http协议；二次开发，自由扩展困难；提供管理API，缺乏更易用的管控、配置方式。</p><ul><li><strong>Zuul</strong> </li></ul><p>Netﬂix开源的网关，功能丰富，使用JAVA开发，易于二次开发 问题：缺乏管控，无法动态配置；依赖组件较多；处理Http请求依赖的是Web容器，性能不如Nginx</p><ul><li><strong>Spring Cloud Gateway</strong></li></ul><p>Spring公司为了替换Zuul而开发的网关服务，将在下面具体介绍</p><p>注意：SpringCloud alibaba技术栈中并没有提供自己的网关，我们可以采用Spring Cloud Gateway来做网关</p><h2 id="5-2-Gateway简介"><a href="#5-2-Gateway简介" class="headerlink" title="5.2  Gateway简介"></a>5.2  Gateway简介</h2><p>Spring Cloud Gateway是Spring公司基于Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。它的目标是替代Netﬂix Zuul，其不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控和限流。</p><p><strong>优点</strong></p><ul><li>性能强劲：是第一代网关Zuul的1.6倍</li><li>功能强大：内置了很多实用的功能，例如转发、监控、限流等</li><li>设计优雅，容易扩展</li></ul><p><strong>缺点</strong></p><p>其实现依赖Netty与WebFlux，不是传统的Servlet编程模型，学习成本高</p><p>不能将其部署在Tomcat、Jetty等Servlet容器里，只能打成jar包执行</p><p>需要Spring Boot 2.0及以上的版本，才支持</p><h2 id="5-3-Gateway快速入门"><a href="#5-3-Gateway快速入门" class="headerlink" title="5.3  Gateway快速入门"></a>5.3  Gateway快速入门</h2><p>要求: 通过浏览器访问api网关,然后通过网关将请求转发到商品微服务</p><h3 id="5-3-1-基础版"><a href="#5-3-1-基础版" class="headerlink" title="5.3.1  基础版"></a>5.3.1  基础版</h3><p>第1步：创建一个api-gateway的模块,导入相关依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;springCloudAlibaba&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.wb&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;api-gateway&lt;&#x2F;artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--gateway网关，不能跟webstarter同时存在--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><p>第二步：创建启动类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wb;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: wbnn</span><br><span class="line"> * @Date: 2021&#x2F;03&#x2F;31&#x2F;</span><br><span class="line"> * @Description: 网关服务</span><br><span class="line"> *&#x2F;</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class GatewayApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(GatewayApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第3步: 添加配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 7000</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: api-gateway</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:  #路由数组【路由就是指当请求满足对应条件时则转发到对应的微服务上】</span><br><span class="line">        - id: product_route  #当前路由标识，唯一，默认UUID</span><br><span class="line">          uri: http:&#x2F;&#x2F;localhost:8081 #请求最终转发地址</span><br><span class="line">          order: 1 #路由的优先级，数字越小，优先级越大</span><br><span class="line">          predicates: #断言（条件判断，返回值boolean，转发请求要满足的条件）</span><br><span class="line">            - Path&#x3D;&#x2F;product-serv&#x2F;** #当请求路径满足path指定的规则，才生效</span><br><span class="line">          filters: #过滤器（请求传递过程中，对请求做一些手脚）</span><br><span class="line">            - StripPrefix&#x3D;1 #请求转发之前去掉一层路径</span><br></pre></td></tr></table></figure><p>第4步: 启动项目, 并通过网关去访问微服务</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210331233635.png" alt="image-20210331233635739"></p><h3 id="5-3-2-增强版"><a href="#5-3-2-增强版" class="headerlink" title="5.3.2  增强版"></a>5.3.2  增强版</h3><p>现在在配置文件中写死了转发路径的地址, 前面我们已经分析过地址写死带来的问题, 接下来我们从注册中心获取此地址。</p><p>第1步：加入nacos依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--nacos--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>第2步：在主类上添加注解</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class GatewayApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(GatewayApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第3步：修改配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 7000</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: api-gateway</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:8848</span><br><span class="line">    gateway:</span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          enabled: true   #让gateway可以发现nacos中的微服务</span><br><span class="line">      routes:  #路由数组【路由就是指当请求满足对应条件时则转发到对应的微服务上】</span><br><span class="line">        - id: product_route  #当前路由标识，唯一，默认UUID</span><br><span class="line">#          uri: http:&#x2F;&#x2F;localhost:8081 #请求最终转发地址</span><br><span class="line">          uri: lb:&#x2F;&#x2F;service-product # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略</span><br><span class="line">          order: 1 #路由的优先级，数字越小，优先级越大</span><br><span class="line">          predicates: #断言（条件判断，返回值boolean，转发请求要满足的条件）</span><br><span class="line">            - Path&#x3D;&#x2F;product-serv&#x2F;** #当请求路径满足path指定的规则，才生效</span><br><span class="line">          filters: #过滤器（请求传递过程中，对请求做一些手脚）</span><br><span class="line">            - StripPrefix&#x3D;1 #请求转发之前去掉一层路径</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210407220351.png" alt="image-20210407220351295"></p><h3 id="5-3-3-简写版"><a href="#5-3-3-简写版" class="headerlink" title="5.3.3  简写版"></a>5.3.3  简写版</h3><p>第1步: 去掉关于路由的配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 7000</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: api-gateway</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:8848</span><br><span class="line">    gateway:</span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          enabled: true   #让gateway可以发现nacos中的微服务</span><br></pre></td></tr></table></figure><p>第2步: 启动项目，并通过网关去访问微服务</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210407220651.png" alt="image-20210407220650888"></p><h2 id="5-4-Gateway核心架构"><a href="#5-4-Gateway核心架构" class="headerlink" title="5.4  Gateway核心架构"></a>5.4  Gateway核心架构</h2><h3 id="5-4-1基本概念"><a href="#5-4-1基本概念" class="headerlink" title="5.4.1基本概念"></a>5.4.1基本概念</h3><p>路由(Route) 是 gateway 中最基本的组件之一，表示一个具体的路由信息载体。主要定义了下面的几个信息:</p><ul><li><strong>id</strong>，路由标识符，区别于其他 Route</li><li><strong>uri</strong>，路由指向的目的地       uri，即客户端请求最终被转发到的微服务</li><li><strong>order</strong>，用于多个 Route 之间的排序，数值越小排序越靠前，匹配优先级越高</li><li><strong>predicate</strong>，断言的作用是进行条件判断，只有断言都返回真，才会真正的执行路由</li><li><strong>ﬁlter</strong>，过滤器用于修改请求和响应信息。</li></ul><h3 id="5-4-2-执行流程"><a href="#5-4-2-执行流程" class="headerlink" title="5.4.2  执行流程"></a>5.4.2  执行流程</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210407220939.png" alt="image-20210407220939286"></p><p>执行流程大体如下：</p><ol><li><p>Gateway Client向Gateway Server发送请求</p></li><li><p>请求首先会被HttpWebHandlerAdapter进行提取组装成网关上下文</p></li><li><p>然后网关的上下文会传递到DispatcherHandler，它负责将请求分发给RoutePredicateHandlerMapping</p></li><li><p>RoutePredicateHandlerMapping负责路由查找，并根据路由断言判断路由是否可用</p></li><li><p>如果过断言成功，由FilteringWebHandler创建过滤器链并调用</p></li><li><p>请求会一次经过PreFilter–微服务–PostFilter的方法，最终返回响应</p></li></ol><h2 id="5-5-断言"><a href="#5-5-断言" class="headerlink" title="5.5  断言"></a>5.5  断言</h2><p>Predicate(断言, 谓词) 用于进行条件判断，只有断言都返回真，才会真正的执行路由。断言就是说: 在 <strong>什么条件下</strong> 才能进行路由转发</p><h3 id="5-5-1-内置路由断言工厂"><a href="#5-5-1-内置路由断言工厂" class="headerlink" title="5.5.1  内置路由断言工厂"></a>5.5.1  内置路由断言工厂</h3><p>SpringCloud  Gateway包括许多内置的断言工厂，所有这些断言都与HTTP请求的不同属性匹配。具体如下：</p><ul><li>基于Datetime类型的断言工厂</li></ul><p>此类型的断言根据时间做判断，主要有三个：</p><p>AfterRoutePredicateFactory： 接收一个日期参数，判断请求日期是否晚于指定日期</p><p>BeforeRoutePredicateFactory： 接收一个日期参数，判断请求日期是否早于指定日期</p><p>BetweenRoutePredicateFactory： 接收两个日期参数，判断请求日期是否在指定时间段内</p><p>-After=2019-12-31T23:59:59.789+08:00[Asia/Shanghai]</p><ul><li>基于远程地址的断言工厂  RemoteAddrRoutePredicateFactory：接收一个IP地址段，判断请求主机地址是否在地址段中</li></ul><p>-RemoteAddr=192.168.1.1/24</p><ul><li>基于Cookie的断言工厂</li></ul><p>CookieRoutePredicateFactory：接收两个参数，cookie 名字和一个正则表达式。 判断请求cookie是否具有给定名称且值与正则表达式匹配。</p><p>-Cookie=chocolate, ch</p><ul><li>基于Header的断言工厂</li></ul><p>HeaderRoutePredicateFactory：接收两个参数，标题名称和正则表达式。  判断请求Header是否具有给定名称且值与正则表达式匹配。</p><p>-Header=X-Request-Id, \d+</p><ul><li>基于Host的断言工厂</li></ul><p>HostRoutePredicateFactory：接收一个参数，主机名模式。判断请求的Host是否满足匹配规则。</p><p>-Host=**.testhost.org</p><ul><li>基于Method请求方法的断言工厂</li></ul><p>MethodRoutePredicateFactory：接收一个参数，判断请求类型是否跟指定的类型匹配</p><p>-Method=GET</p><ul><li>基于Path请求路径的断言工厂</li></ul><p>PathRoutePredicateFactory：接收一个参数，判断请求的URI部分是否满足路径规则</p><p>-Path=/foo/{segment}</p><ul><li>基于Query请求参数的断言工厂</li></ul><p>QueryRoutePredicateFactory ：接收两个参数，请求param和正则表达式， 判断请求参数是否具有给定名称且值与正则表达式匹配。</p><p>-Query=baz, ba</p><ul><li>基于路由权重的断言工厂</li></ul><p>WeightRoutePredicateFactory：接收一个[组名,权重], 然后对于同一个组内的路由按照权重转发</p><p>routes:</p><p>-id: weight_route1 uri: host1 predicates:</p><p>-Path=/product/**</p><p>-Weight=group3, 1</p><p>-id: weight_route2 uri: host2 predicates:</p><p>-Path=/product/**</p><p>-Weight= group3, 9</p><h5 id="内置路由断言工厂的使用"><a href="#内置路由断言工厂的使用" class="headerlink" title="内置路由断言工厂的使用"></a>内置路由断言工厂的使用</h5><p>接下来我们验证几个内置断言的使用:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 7000</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: api-gateway</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:8848</span><br><span class="line">    gateway:</span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          enabled: true   #让gateway可以发现nacos中的微服务</span><br><span class="line">      routes:  #路由数组【路由就是指当请求满足对应条件时则转发到对应的微服务上】</span><br><span class="line">        - id: product_route  #当前路由标识，唯一，默认UUID</span><br><span class="line">#          uri: http:&#x2F;&#x2F;localhost:8081 #请求最终转发地址</span><br><span class="line">          uri: lb:&#x2F;&#x2F;service-product # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略</span><br><span class="line">          order: 1 #路由的优先级，数字越小，优先级越大</span><br><span class="line">          predicates: #断言（条件判断，返回值boolean，转发请求要满足的条件）</span><br><span class="line">            - Path&#x3D;&#x2F;product-serv&#x2F;** #当请求路径满足path指定的规则，才生效</span><br><span class="line">            - Before&#x3D;2021-11-28T00:00:00.000+08:00 #限制请求时间在2021-11-28之前</span><br><span class="line">            - Method&#x3D;POST #限制请求方式为POST</span><br><span class="line">          filters: #过滤器（请求传递过程中，对请求做一些手脚）</span><br><span class="line">            - StripPrefix&#x3D;1 #请求转发之前去掉一层路径</span><br></pre></td></tr></table></figure><h3 id="5-5-2-自定义路由断言工"><a href="#5-5-2-自定义路由断言工" class="headerlink" title="5.5.2  自定义路由断言工"></a>5.5.2  自定义路由断言工</h3><p>我们来设定一个场景: 假设我们的应用仅仅让age在(min,max)之间的人来访问。</p><p>第1步：在配置文件中,添加一个Age的断言配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 7000</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: api-gateway</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:8848</span><br><span class="line">    gateway:</span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          enabled: true   #让gateway可以发现nacos中的微服务</span><br><span class="line">      routes:  #路由数组【路由就是指当请求满足对应条件时则转发到对应的微服务上】</span><br><span class="line">        - id: product_route  #当前路由标识，唯一，默认UUID</span><br><span class="line">#          uri: http:&#x2F;&#x2F;localhost:8081 #请求最终转发地址</span><br><span class="line">          uri: lb:&#x2F;&#x2F;service-product # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略</span><br><span class="line">          order: 1 #路由的优先级，数字越小，优先级越大</span><br><span class="line">          predicates: #断言（条件判断，返回值boolean，转发请求要满足的条件）</span><br><span class="line">            - Path&#x3D;&#x2F;product-serv&#x2F;** #当请求路径满足path指定的规则，才生效</span><br><span class="line">            - Age&#x3D;18,60   #让Age在18-60之间的访问</span><br><span class="line">#            - Before&#x3D;2021-11-28T00:00:00.000+08:00 #限制请求时间在2021-11-28之前</span><br><span class="line">#            - Method&#x3D;POST #限制请求方式为POST</span><br><span class="line">          filters: #过滤器（请求传递过程中，对请求做一些手脚）</span><br><span class="line">            - StripPrefix&#x3D;1 #请求转发之前去掉一层路径</span><br></pre></td></tr></table></figure><p>第2步：自定义一个断言工厂, 实现断言方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wb.gateway.predicates;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line">import lombok.NoArgsConstructor;</span><br><span class="line">import org.apache.commons.lang3.StringUtils;</span><br><span class="line">import org.springframework.cloud.gateway.handler.predicate.AbstractRoutePredicateFactory;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.web.server.ServerWebExchange;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: wbnn</span><br><span class="line"> * @Date: 2021&#x2F;04&#x2F;07&#x2F;</span><br><span class="line"> * @Description:这是一个自定义路由断言工厂 1.名字必须是 配置+RoutePredicateFactory</span><br><span class="line"> * 2.必须继承AbstractRoutePredicateFactory&lt;配置类&gt;</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">public class AgeRoutePredicateFactory extends AbstractRoutePredicateFactory&lt;AgeRoutePredicateFactory.Config&gt; &#123;</span><br><span class="line">    public static final String DATETIME_KEY &#x3D; &quot;datetime&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;    构造函数</span><br><span class="line">    public AgeRoutePredicateFactory() &#123;</span><br><span class="line">        super(AgeRoutePredicateFactory.Config.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;    读取配置文件中的参数值，赋值到配置类的属性上</span><br><span class="line">    public List&lt;String&gt; shortcutFieldOrder() &#123;</span><br><span class="line">&#x2F;&#x2F;        这个位置的顺序必须跟配置文件顺序一样</span><br><span class="line">        return Arrays.asList(&quot;minAge&quot;, &quot;maxAge&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;断言逻辑</span><br><span class="line">    public Predicate&lt;ServerWebExchange&gt; apply(AgeRoutePredicateFactory.Config config) &#123;</span><br><span class="line">        return new Predicate&lt;ServerWebExchange&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean test(ServerWebExchange serverWebExchange) &#123;</span><br><span class="line">                &#x2F;&#x2F;1.接收前台传入的数据</span><br><span class="line">                String age &#x3D; serverWebExchange.getRequest().getQueryParams().getFirst(&quot;age&quot;);</span><br><span class="line">                &#x2F;&#x2F;2.判断是否为空</span><br><span class="line">                if (StringUtils.isNotEmpty(age)) &#123;</span><br><span class="line">                    int anInt &#x3D; Integer.parseInt(age);</span><br><span class="line">                    if (anInt &lt; config.getMaxAge() &amp;&amp; anInt &gt; config.getMinAge()) &#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Data</span><br><span class="line">    @NoArgsConstructor</span><br><span class="line">    public static class Config &#123;</span><br><span class="line">        private int minAge;</span><br><span class="line">        private int maxAge;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210407225849.png" alt="image-20210407225849619"></p><h2 id="5-6-过滤"><a href="#5-6-过滤" class="headerlink" title="5.6  过滤"></a>5.6  过滤</h2><p>三个知识点:</p><p>1 作用: 过滤器就是在请求的传递过程中,对请求和响应做一些手脚</p><p>2 生命周期: Pre Post</p><p>3 分类: 局部过滤器(作用在某一个路由上) 全局过滤器(作用全部路由上) </p><p>在Gateway中, Filter的生命周期只有两个：“pre” 和 “post”。</p><ul><li>PRE： 这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。 </li><li>POST：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。</li></ul><p>Gateway 的Filter从作用范围可分为两种: GatewayFilter与GlobalFilter。</p><ul><li>GatewayFilter：应用到单个路由或者一个分组的路由上</li><li>GlobalFilter：应用到所有的路由上</li></ul><h3 id="5-6-1-局部过滤器"><a href="#5-6-1-局部过滤器" class="headerlink" title="5.6.1  局部过滤器"></a>5.6.1  局部过滤器</h3><p>局部过滤器是针对单个路由的过滤器。</p><h4 id="5-6-1-1-内置局部过滤器"><a href="#5-6-1-1-内置局部过滤器" class="headerlink" title="5.6.1.1 内置局部过滤器"></a>5.6.1.1 内置局部过滤器</h4><p>在SpringCloud Gateway中内置了很多不同类型的网关路由过滤器。具体如下：</p><table><thead><tr><th align="center"><strong>过滤器工厂</strong></th><th><strong>作用</strong></th><th align="center"><strong>参数</strong></th></tr></thead><tbody><tr><td align="center">AddRequestHeader</td><td>为原始请求添加Header</td><td align="center">Header的名称及值</td></tr><tr><td align="center">AddRequestParameter</td><td>为原始请求添加请求参数</td><td align="center">参数名称及值</td></tr><tr><td align="center">AddResponseHeader</td><td>为原始响应添加Header</td><td align="center">Header的名称及值</td></tr><tr><td align="center">DedupeResponseHeader</td><td>剔除响应头中重复的值</td><td align="center">需要去重的Header名称及去重策略</td></tr><tr><td align="center">Hystrix</td><td>为路由引入Hystrix的断路器保护</td><td align="center">HystrixCommand 的名称</td></tr><tr><td align="center">FallbackHeaders</td><td>为fallbackUri的请求头中添加具体的异常信息</td><td align="center">Header的名称</td></tr><tr><td align="center">PreﬁxPath</td><td>为原始请求路径添加前缀</td><td align="center">前缀路径</td></tr><tr><td align="center">PreserveHostHeader</td><td>为请求添加一个preserveHostHeader=true的属性，路由过滤器会检查该属性以决定是否要发送原始的Host</td><td align="center">无</td></tr><tr><td align="center">RequestRateLimiter</td><td>用于对请求限流，限流算法为令牌桶</td><td align="center">keyResolver、rateLimiter、statusCode、denyEmptyKey、emptyKeyStatus</td></tr><tr><td align="center">RedirectTo</td><td>将原始请求重定向到指定的URL</td><td align="center">http状态码及重定向的url</td></tr><tr><td align="center">RemoveHopByHopHeadersFilter</td><td>为原始请求删除IETF组织规定的一系列Header</td><td align="center">默认就会启用，可以通过配置指定仅删除哪些Header</td></tr><tr><td align="center">RemoveRequestHeader</td><td>为原始请求删除某个Header</td><td align="center">Header名称</td></tr><tr><td align="center">RemoveResponseHeader</td><td>为原始响应删除某个Header</td><td align="center">Header名称</td></tr><tr><td align="center">RewritePath</td><td>重写原始的请求路径</td><td align="center">原始路径正则表达式以及重写后路径的正则表达式</td></tr><tr><td align="center">RewriteResponseHeader</td><td>重写原始响应中的某个Header</td><td align="center">Header名称，值的正则表达式，重写后的值</td></tr><tr><td align="center">SaveSession</td><td>在转发请求之前，强制执行  WebSession::save 操作</td><td align="center">无</td></tr><tr><td align="center">secureHeaders</td><td>为原始响应添加一系列起安全作用的响应头</td><td align="center">无，支持修改这些安全响应头的值</td></tr><tr><td align="center">SetPath</td><td>修改原始的请求路径</td><td align="center">修改后的路径</td></tr></tbody></table><table><thead><tr><th><strong>过滤器工厂</strong></th><th><strong>作用</strong></th><th><strong>参数</strong></th></tr></thead><tbody><tr><td>SetResponseHeader</td><td>修改原始响应中某个Header的值</td><td>Header名称，修改后的值</td></tr><tr><td>SetStatus</td><td>修改原始响应的状态码</td><td>HTTP 状态码，可以是数字，也可以是字符串</td></tr><tr><td>StripPreﬁx</td><td>用于截断原始请求的路径</td><td>使用数字表示要截断的路径的数量</td></tr><tr><td>Retry</td><td>针对不同的响应进行重试</td><td>retries、statuses、methods、series</td></tr><tr><td>RequestSize</td><td>设置允许接收最大请求包的大 小。如果请求包大小超过设置的值，则返回 413 Payload Too  Large</td><td>请求包大小，单位为字节，默认值为5M</td></tr><tr><td>ModifyRequestBody</td><td>在转发请求之前修改原始请求体内容</td><td>修改后的请求体内容</td></tr><tr><td>ModifyResponseBody</td><td>修改原始响应体的内容</td><td>修改后的响应体内容</td></tr></tbody></table><p><strong>内置局部过滤器的使用</strong></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">api-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span>   <span class="comment">#让gateway可以发现nacos中的微服务</span></span><br><span class="line">      <span class="attr">routes:</span>  <span class="comment">#路由数组【路由就是指当请求满足对应条件时则转发到对应的微服务上】</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">product_route</span>  <span class="comment">#当前路由标识，唯一，默认UUID</span></span><br><span class="line"><span class="comment">#          uri: http://localhost:8081 #请求最终转发地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://service-product</span> <span class="comment"># lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略</span></span><br><span class="line">          <span class="attr">order:</span> <span class="number">1</span> <span class="comment">#路由的优先级，数字越小，优先级越大</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment">#断言（条件判断，返回值boolean，转发请求要满足的条件）</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/product-serv/**</span> <span class="comment">#当请求路径满足path指定的规则，才生效</span></span><br><span class="line"><span class="comment">#            - Age=18,60   #让Age在18-60之间的访问</span></span><br><span class="line"><span class="comment">#            - Before=2021-11-28T00:00:00.000+08:00 #限制请求时间在2021-11-28之前</span></span><br><span class="line"><span class="comment">#            - Method=POST #限制请求方式为POST</span></span><br><span class="line">          <span class="attr">filters:</span> <span class="comment">#过滤器（请求传递过程中，对请求做一些手脚）</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=1</span> <span class="comment">#请求转发之前去掉一层路径</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">SetStatus=2000</span></span><br></pre></td></tr></table></figure><h4 id="5-6-1-2-自定义局部过滤器"><a href="#5-6-1-2-自定义局部过滤器" class="headerlink" title="5.6.1.2 自定义局部过滤器"></a>5.6.1.2 自定义局部过滤器</h4><p>第1步：在配置文件中,添加一个Log的过滤器配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">api-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span>   <span class="comment">#让gateway可以发现nacos中的微服务</span></span><br><span class="line">      <span class="attr">routes:</span>  <span class="comment">#路由数组【路由就是指当请求满足对应条件时则转发到对应的微服务上】</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">product_route</span>  <span class="comment">#当前路由标识，唯一，默认UUID</span></span><br><span class="line"><span class="comment">#          uri: http://localhost:8081 #请求最终转发地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://service-product</span> <span class="comment"># lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略</span></span><br><span class="line">          <span class="attr">order:</span> <span class="number">1</span> <span class="comment">#路由的优先级，数字越小，优先级越大</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment">#断言（条件判断，返回值boolean，转发请求要满足的条件）</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/product-serv/**</span> <span class="comment">#当请求路径满足path指定的规则，才生效</span></span><br><span class="line"><span class="comment">#            - Age=18,60   #让Age在18-60之间的访问</span></span><br><span class="line"><span class="comment">#            - Before=2021-11-28T00:00:00.000+08:00 #限制请求时间在2021-11-28之前</span></span><br><span class="line"><span class="comment">#            - Method=POST #限制请求方式为POST</span></span><br><span class="line">          <span class="attr">filters:</span> <span class="comment">#过滤器（请求传递过程中，对请求做一些手脚）</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=1</span> <span class="comment">#请求转发之前去掉一层路径</span></span><br><span class="line"><span class="comment">#            - SetStatus=2000</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Log=true,false</span> <span class="comment">#控制日志是否开启</span></span><br></pre></td></tr></table></figure><p>第2步：自定义一个过滤器工厂,实现方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wb.gateway.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: wbnn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/01/03/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 自定义的局部过滤器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogGatewayFilterFactory</span> <span class="keyword">extends</span> <span class="title">AbstractGatewayFilterFactory</span>&lt;<span class="title">LogGatewayFilterFactory</span>.<span class="title">Config</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogGatewayFilterFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(LogGatewayFilterFactory.Config.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取配置文件中的参数 赋值到配置类中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">shortcutFieldOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="string">&quot;consoleLog&quot;</span>,<span class="string">&quot;cacheLog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//过滤器逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GatewayFilter <span class="title">apply</span><span class="params">(LogGatewayFilterFactory.Config config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GatewayFilter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (config.cacheLog) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;cacheLog已经开启了---&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (config.consoleLog) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;consoleLog已经开启了---&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置类 接收配置参数</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Boolean consoleLog;</span><br><span class="line">        <span class="keyword">private</span> Boolean cacheLog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-6-2-全局过滤器"><a href="#5-6-2-全局过滤器" class="headerlink" title="5.6.2  全局过滤器"></a>5.6.2  全局过滤器</h3><p>全局过滤器作用于所有路由, 无需配置。通过全局过滤器可以实现对权限的统一校验，安全性验证等功能.</p><h4 id="5-6-2-1-内置全局过滤器"><a href="#5-6-2-1-内置全局过滤器" class="headerlink" title="5.6.2.1 内置全局过滤器"></a>5.6.2.1 内置全局过滤器</h4><p>SpringCloud Gateway内部也是通过一系列的内置全局过滤器对整个路由转发进行处理如下：</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20220103172419.png" alt="image-20220103172412344"></p><h4 id="5-6-2-2-自定义全局过滤器"><a href="#5-6-2-2-自定义全局过滤器" class="headerlink" title="5.6.2.2 自定义全局过滤器"></a>5.6.2.2 自定义全局过滤器</h4><p>内置的过滤器已经可以完成大部分的功能，但是对于企业开发的一些业务功能处理，还是需要我们 自己编写过滤器来实现的，那么我们一起通过代码的形式自定义一个过滤器，去完成统一的权限校验。</p><p>开发中的鉴权逻辑：</p><ul><li>当客户端第一次请求服务时，服务端对用户进行信息认证（登录）</li><li>认证通过，将用户信息进行加密形成token，返回给客户端，作为登录凭证 </li><li>以后每次请求，客户端都携带认证的token</li><li>服务端对token进行解密，判断是否有效</li></ul><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20220103172553.png" alt="image-20220103172553249"></p><p>如上图，对于验证用户是否已经登录鉴权的过程可以在网关统一检验。检验的标准就是请求中是否携带token凭证以及token的正确性。</p><p>下面的我们自定义一个GlobalFilter，去校验所有请求的请求参数中是否包含“token”，如何不包含请求</p><p>参数“token”则不转发路由，否则执行正常的逻辑。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wb.gateway.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: wbnn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/01/03/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 自定义全局过滤器 实现统一鉴权</span></span><br><span class="line"><span class="comment"> *  必须实现GlobalFilter，Ordered</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthGlobaFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//过滤器逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//统一鉴权</span></span><br><span class="line">        String token = exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.equals(<span class="string">&quot;admin&quot;</span>,token)) &#123;</span><br><span class="line">          log.info(<span class="string">&quot;认证失败---&quot;</span>);</span><br><span class="line">          exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">          <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标识当前过滤器的优先级，返回值越小，优先级越高</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-7-网关限流"><a href="#5-7-网关限流" class="headerlink" title="5.7 网关限流"></a>5.7 网关限流</h2><p>网关是所有请求的公共入口，所以可以在网关进行限流，而且限流的方式也很多，我们本次采用前 面学过的Sentinel组件来实现网关的限流。Sentinel支持对SpringCloud Gateway、Zuul等主流网关进行限流。</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/mysql/20220116150925.png" alt="image-20220116150918304"></p><p>从1.6.0版本开始，Sentinel提供了SpringCloud Gateway的适配模块，可以提供两种资源维度的限流：</p><ul><li>route维度：即在Spring配置文件中配置的路由条目，资源名为对应的touteId</li><li>自定义API维度：用户可以利用Sentinel提供的API来自定义一些API分组</li></ul><h5 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1 导入依赖"></a>1 导入依赖</h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;dependency&gt;</span></span><br><span class="line">    <span class="string">&lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span></span><br><span class="line">    <span class="string">&lt;artifactId&gt;sentinel-spring-cloud-gateway-adapter&lt;/artifactId&gt;</span></span><br><span class="line"> <span class="string">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-编写配置类"><a href="#2-编写配置类" class="headerlink" title="2 编写配置类"></a><strong>2</strong> <strong>编写配置类</strong></h5><p>基于Sentinel 的Gateway限流是通过其提供的Filter来完成的，使用时只需注入对应的SentinelGatewayFilter实例以及 SentinelGatewayBlockExceptionHandler 实例即可.</p>]]></content>
      
      
      <categories>
          
          <category> springCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springCloudAlibaba </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程-Stream流</title>
      <link href="2021/03/14/han-shu-shi-bian-cheng/"/>
      <url>2021/03/14/han-shu-shi-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="函数式编程-Stream流"><a href="#函数式编程-Stream流" class="headerlink" title="函数式编程-Stream流"></a>函数式编程-Stream流</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="1-1-为什么学？"><a href="#1-1-为什么学？" class="headerlink" title="1.1 为什么学？"></a>1.1 为什么学？</h3><ul><li>能够看懂公司里的代码</li><li>大数量下处理集合效率高</li><li>代码可读性高</li><li>消灭嵌套地狱</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询未成年作家的评分在70以上的书籍 由于洋流影响所以作家和书籍可能出现重复，需要进行去重</span></span><br><span class="line">List&lt;Book&gt; bookList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Set&lt;Book&gt; uniqueBookValues = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">Set&lt;Author&gt; uniqueAuthorValues = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Author author : authors) &#123;</span><br><span class="line">    <span class="keyword">if</span> (uniqueAuthorValues.add(author)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (author.getAge() &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            List&lt;Book&gt; books = author.getBooks();</span><br><span class="line">            <span class="keyword">for</span> (Book book : books) &#123;</span><br><span class="line">                <span class="keyword">if</span> (book.getScore() &gt; <span class="number">70</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (uniqueBookValues.add(book)) &#123;</span><br><span class="line">                        bookList.add(book);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(bookList);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Book&gt; collect = authors.stream()</span><br><span class="line">    .distinct()</span><br><span class="line">    .filter(author -&gt; author.getAge() &lt; <span class="number">18</span>)</span><br><span class="line">    .map(author -&gt; author.getBooks())</span><br><span class="line">    .flatMap(Collection::stream)</span><br><span class="line">    .filter(book -&gt; book.getScore() &gt; <span class="number">70</span>)</span><br><span class="line">    .distinct()</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">System.out.println(collect);</span><br></pre></td></tr></table></figure><h3 id="1-2-函数式编程思想"><a href="#1-2-函数式编程思想" class="headerlink" title="1.2 函数式编程思想"></a>1.2 函数式编程思想</h3><h4 id="1-2-1-概念"><a href="#1-2-1-概念" class="headerlink" title="1.2.1 概念"></a>1.2.1 概念</h4><p>​    面向对象思想需要关注用什么对象完成什么事情。而函数式编程思想就类似于我们数学中的函数。它主要关注的是对数据进行了什么操作。</p><h4 id="1-2-2-优点"><a href="#1-2-2-优点" class="headerlink" title="1.2.2 优点"></a>1.2.2 优点</h4><ul><li>代码简洁，开发快速</li><li>接近自然语言，易于理解</li><li>易于”并发编程”</li></ul><h2 id="2-Lambda表达式"><a href="#2-Lambda表达式" class="headerlink" title="2. Lambda表达式"></a>2. Lambda表达式</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>​    Lambda是JDK8中一个语法糖。他可以对某些匿名内部类的写法进行简化。它是函数式编程思想的一个重要体现。让我们不用关注是什么对象。而是更关注我们对数据进行了什么操作。</p><h3 id="2-2-核心原则"><a href="#2-2-核心原则" class="headerlink" title="2.2 核心原则"></a>2.2 核心原则</h3><blockquote><p>可推导可省略</p></blockquote><h3 id="2-3-基本格式"><a href="#2-3-基本格式" class="headerlink" title="2. 3 基本格式"></a>2. 3 基本格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(参数列表)-&gt;&#123;代码&#125;</span><br></pre></td></tr></table></figure><h4 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h4><p>我们在创建线程并启动时可以使用匿名内部类的写法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你知道吗 我比你想象的 更想在你身边&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>可以使用Lambda的格式对其进行修改。修改后如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;你知道吗 我比你想象的 更想在你身边&quot;</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><h4 id="例二"><a href="#例二" class="headerlink" title="例二:"></a>例二:</h4><p>现有方法定义如下，其中IntBinaryOperator是一个接口。先使用匿名内部类的写法调用该方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateNum</span><span class="params">(IntBinaryOperator operator)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> operator.applyAsInt(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = calculateNum(<span class="keyword">new</span> IntBinaryOperator() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">applyAsInt</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> left + right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lambda写法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = calculateNum((<span class="keyword">int</span> left, <span class="keyword">int</span> right)-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> left + right;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例三："><a href="#例三：" class="headerlink" title="例三："></a>例三：</h4><p>现有方法定义如下，其中IntPredicate是一个接口。先使用匿名内部类的写法调用该方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNum</span><span class="params">(IntPredicate predicate)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span>(predicate.test(i))&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    printNum(<span class="keyword">new</span> IntPredicate() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value%<span class="number">2</span>==<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lambda写法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    printNum((<span class="keyword">int</span> value)-&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> value%<span class="number">2</span>==<span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNum</span><span class="params">(IntPredicate predicate)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span>(predicate.test(i))&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例四："><a href="#例四：" class="headerlink" title="例四："></a>例四：</h4><p>现有方法定义如下，其中Function是一个接口。先使用匿名内部类的写法调用该方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;R&gt; <span class="function">R <span class="title">typeConver</span><span class="params">(Function&lt;String,R&gt; function)</span></span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;1235&quot;</span>;</span><br><span class="line">    R result = function.apply(str);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer result = typeConver(<span class="keyword">new</span> Function&lt;String, Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.valueOf(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lambda写法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer result = typeConver((String s)-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.valueOf(s);</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="例五："><a href="#例五：" class="headerlink" title="例五："></a>例五：</h4><p>现有方法定义如下，其中IntConsumer是一个接口。先使用匿名内部类的写法调用该方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foreachArr</span><span class="params">(IntConsumer consumer)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">        consumer.accept(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    foreachArr(<span class="keyword">new</span> IntConsumer() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lambda写法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    foreachArr((<span class="keyword">int</span> value)-&gt;&#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-省略规则"><a href="#2-4-省略规则" class="headerlink" title="2.4 省略规则"></a>2.4 省略规则</h3><ul><li>参数类型可以省略</li><li>方法体只有一句代码时大括号return和唯一一句代码的分号可以省略</li><li>方法只有一个参数时小括号可以省略</li><li>以上这些规则都记不住也可以省略不记</li></ul><h2 id="3-Stream流"><a href="#3-Stream流" class="headerlink" title="3. Stream流"></a>3. Stream流</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>​    Java8的Stream使用的是函数式编程模式，如同它的名字一样，它可以被用来对集合或数组进行链状流式的操作。可以更方便的让我们对集合或数组操作。</p><h3 id="3-2-案例数据准备"><a href="#3-2-案例数据准备" class="headerlink" title="3.2 案例数据准备"></a>3.2 案例数据准备</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span><span class="comment">//用于后期的去重使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Author</span> </span>&#123;</span><br><span class="line">    <span class="comment">//id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//简介</span></span><br><span class="line">    <span class="keyword">private</span> String intro;</span><br><span class="line">    <span class="comment">//作品</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Book&gt; books;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span><span class="comment">//用于后期的去重使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="comment">//id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">//书名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分类</span></span><br><span class="line">    <span class="keyword">private</span> String category;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//评分</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//简介</span></span><br><span class="line">    <span class="keyword">private</span> String intro;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Author&gt; <span class="title">getAuthors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数据初始化</span></span><br><span class="line">    Author author = <span class="keyword">new</span> Author(<span class="number">1L</span>,<span class="string">&quot;蒙多&quot;</span>,<span class="number">33</span>,<span class="string">&quot;一个从菜刀中明悟哲理的祖安人&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">    Author author2 = <span class="keyword">new</span> Author(<span class="number">2L</span>,<span class="string">&quot;亚拉索&quot;</span>,<span class="number">15</span>,<span class="string">&quot;狂风也追逐不上他的思考速度&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">    Author author3 = <span class="keyword">new</span> Author(<span class="number">3L</span>,<span class="string">&quot;易&quot;</span>,<span class="number">14</span>,<span class="string">&quot;是这个世界在限制他的思维&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">    Author author4 = <span class="keyword">new</span> Author(<span class="number">3L</span>,<span class="string">&quot;易&quot;</span>,<span class="number">14</span>,<span class="string">&quot;是这个世界在限制他的思维&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//书籍列表</span></span><br><span class="line">    List&lt;Book&gt; books1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Book&gt; books2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Book&gt; books3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    books1.add(<span class="keyword">new</span> Book(<span class="number">1L</span>,<span class="string">&quot;刀的两侧是光明与黑暗&quot;</span>,<span class="string">&quot;哲学,爱情&quot;</span>,<span class="number">88</span>,<span class="string">&quot;用一把刀划分了爱恨&quot;</span>));</span><br><span class="line">    books1.add(<span class="keyword">new</span> Book(<span class="number">2L</span>,<span class="string">&quot;一个人不能死在同一把刀下&quot;</span>,<span class="string">&quot;个人成长,爱情&quot;</span>,<span class="number">99</span>,<span class="string">&quot;讲述如何从失败中明悟真理&quot;</span>));</span><br><span class="line"></span><br><span class="line">    books2.add(<span class="keyword">new</span> Book(<span class="number">3L</span>,<span class="string">&quot;那风吹不到的地方&quot;</span>,<span class="string">&quot;哲学&quot;</span>,<span class="number">85</span>,<span class="string">&quot;带你用思维去领略世界的尽头&quot;</span>));</span><br><span class="line">    books2.add(<span class="keyword">new</span> Book(<span class="number">3L</span>,<span class="string">&quot;那风吹不到的地方&quot;</span>,<span class="string">&quot;哲学&quot;</span>,<span class="number">85</span>,<span class="string">&quot;带你用思维去领略世界的尽头&quot;</span>));</span><br><span class="line">    books2.add(<span class="keyword">new</span> Book(<span class="number">4L</span>,<span class="string">&quot;吹或不吹&quot;</span>,<span class="string">&quot;爱情,个人传记&quot;</span>,<span class="number">56</span>,<span class="string">&quot;一个哲学家的恋爱观注定很难把他所在的时代理解&quot;</span>));</span><br><span class="line"></span><br><span class="line">    books3.add(<span class="keyword">new</span> Book(<span class="number">5L</span>,<span class="string">&quot;你的剑就是我的剑&quot;</span>,<span class="string">&quot;爱情&quot;</span>,<span class="number">56</span>,<span class="string">&quot;无法想象一个武者能对他的伴侣这么的宽容&quot;</span>));</span><br><span class="line">    books3.add(<span class="keyword">new</span> Book(<span class="number">6L</span>,<span class="string">&quot;风与剑&quot;</span>,<span class="string">&quot;个人传记&quot;</span>,<span class="number">100</span>,<span class="string">&quot;两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢？&quot;</span>));</span><br><span class="line">    books3.add(<span class="keyword">new</span> Book(<span class="number">6L</span>,<span class="string">&quot;风与剑&quot;</span>,<span class="string">&quot;个人传记&quot;</span>,<span class="number">100</span>,<span class="string">&quot;两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢？&quot;</span>));</span><br><span class="line"></span><br><span class="line">    author.setBooks(books1);</span><br><span class="line">    author2.setBooks(books2);</span><br><span class="line">    author3.setBooks(books3);</span><br><span class="line">    author4.setBooks(books3);</span><br><span class="line"></span><br><span class="line">    List&lt;Author&gt; authorList = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(author,author2,author3,author4));</span><br><span class="line">    <span class="keyword">return</span> authorList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-快速入门"><a href="#3-3-快速入门" class="headerlink" title="3.3 快速入门"></a>3.3 快速入门</h3><h4 id="3-3-1-需求"><a href="#3-3-1-需求" class="headerlink" title="3.3.1 需求"></a>3.3.1 需求</h4><p>​    我们可以调用getAuthors方法获取到作家的集合。现在需要打印所有年龄小于18的作家的名字，并且要注意去重。</p><h4 id="3-3-2-实现"><a href="#3-3-2-实现" class="headerlink" title="3.3.2 实现"></a>3.3.2 实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印所有年龄小于18的作家的名字，并且要注意去重</span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.</span><br><span class="line">        stream()<span class="comment">//把集合转换成流</span></span><br><span class="line">        .distinct()<span class="comment">//先去除重复的作家</span></span><br><span class="line">        .filter(author -&gt; author.getAge()&lt;<span class="number">18</span>)<span class="comment">//筛选年龄小于18的</span></span><br><span class="line">        .forEach(author -&gt; System.out.println(author.getName()));<span class="comment">//遍历打印名字</span></span><br></pre></td></tr></table></figure><h3 id="3-4-常用操作"><a href="#3-4-常用操作" class="headerlink" title="3.4 常用操作"></a>3.4 常用操作</h3><h4 id="3-4-1-创建流"><a href="#3-4-1-创建流" class="headerlink" title="3.4.1 创建流"></a>3.4.1 创建流</h4><p>单列集合： <code>集合对象.stream()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">Stream&lt;Author&gt; stream = authors.stream();</span><br></pre></td></tr></table></figure><p>数组：<code>Arrays.stream(数组) </code>或者使用<code>Stream.of</code>来创建</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Stream&lt;Integer&gt; stream = Arrays.stream(arr);</span><br><span class="line">Stream&lt;Integer&gt; stream2 = Stream.of(arr);</span><br></pre></td></tr></table></figure><p>双列集合：转换成单列集合后再创建</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;蜡笔小新&quot;</span>,<span class="number">19</span>);</span><br><span class="line">map.put(<span class="string">&quot;黑子&quot;</span>,<span class="number">17</span>);</span><br><span class="line">map.put(<span class="string">&quot;日向翔阳&quot;</span>,<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; stream = map.entrySet().stream();</span><br></pre></td></tr></table></figure><h4 id="3-4-2-中间操作"><a href="#3-4-2-中间操作" class="headerlink" title="3.4.2 中间操作"></a>3.4.2 中间操作</h4><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><p>​    可以对流中的元素进行条件过滤，符合过滤条件的才能继续留在流中。</p><p>例如：</p><p>​    打印所有姓名长度大于1的作家的姓名</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.stream()</span><br><span class="line">        .filter(author -&gt; author.getName().length()&gt;<span class="number">1</span>)</span><br><span class="line">        .forEach(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure><h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><p>​    可以把对流中的元素进行计算或转换。</p><p>例如：</p><p>​    打印所有作家的姓名</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">authors</span><br><span class="line">        .stream()</span><br><span class="line">        .map(author -&gt; author.getName())</span><br><span class="line">        .forEach(name-&gt;System.out.println(name));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        打印所有作家的姓名</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        authors.stream()</span></span><br><span class="line"><span class="comment">//                .map(author -&gt; author.getName())</span></span><br><span class="line"><span class="comment">//                .forEach(s -&gt; System.out.println(s));</span></span><br><span class="line"></span><br><span class="line">        authors.stream()</span><br><span class="line">                .map(author -&gt; author.getAge())</span><br><span class="line">                .map(age-&gt;age+<span class="number">10</span>)</span><br><span class="line">                .forEach(age-&gt; System.out.println(age));</span><br></pre></td></tr></table></figure><h5 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h5><p>​    可以去除流中的重复元素。</p><p>例如：</p><p>​    打印所有作家的姓名，并且要求其中不能有重复元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.stream()</span><br><span class="line">        .distinct()</span><br><span class="line">        .forEach(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure><p><strong>注意：distinct方法是依赖Object的equals方法来判断是否是相同对象的。所以需要注意重写equals方法。</strong></p><h5 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h5><p>​    可以对流中的元素进行排序。</p><p>例如：</p><p>​    对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"><span class="comment">//        对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。</span></span><br><span class="line">        authors.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted()</span><br><span class="line">                .forEach(author -&gt; System.out.println(author.getAge()));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"><span class="comment">//        对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。</span></span><br><span class="line">        authors.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted((o1, o2) -&gt; o2.getAge()-o1.getAge())</span><br><span class="line">                .forEach(author -&gt; System.out.println(author.getAge()));</span><br></pre></td></tr></table></figure><p><strong>注意：如果调用空参的sorted()方法，需要流中的元素是实现了Comparable。</strong></p><p>​        </p><h5 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h5><p>​    可以设置流的最大长度，超出的部分将被抛弃。</p><p>例如：</p><p>​    对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素,然后打印其中年龄最大的两个作家的姓名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.stream()</span><br><span class="line">        .distinct()</span><br><span class="line">        .sorted()</span><br><span class="line">        .limit(<span class="number">2</span>)</span><br><span class="line">        .forEach(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure><h5 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h5><p>​    跳过流中的前n个元素，返回剩下的元素</p><p>例如：</p><p>​    打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序。</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        authors.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted()</span><br><span class="line">                .skip(<span class="number">1</span>)</span><br><span class="line">                .forEach(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure><h5 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h5><p>​    map只能把一个对象转换成另一个对象来作为流中的元素。而flatMap可以把一个对象转换成多个对象作为流中的元素。</p><p>例一：</p><p>​    打印所有书籍的名字。要求对重复的元素进行去重。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        打印所有书籍的名字。要求对重复的元素进行去重。</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">        authors.stream()</span><br><span class="line">                .flatMap(author -&gt; author.getBooks().stream())</span><br><span class="line">                .distinct()</span><br><span class="line">                .forEach(book -&gt; System.out.println(book.getName()));</span><br></pre></td></tr></table></figure><p>例二：</p><p>​    打印现有数据的所有分类。要求对分类进行去重。不能出现这种格式：哲学,爱情</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        打印现有数据的所有分类。要求对分类进行去重。不能出现这种格式：哲学,爱情     爱情</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        authors.stream()</span><br><span class="line">                .flatMap(author -&gt; author.getBooks().stream())</span><br><span class="line">                .distinct()</span><br><span class="line">                .flatMap(book -&gt; Arrays.stream(book.getCategory().split(<span class="string">&quot;,&quot;</span>)))</span><br><span class="line">                .distinct()</span><br><span class="line">                .forEach(category-&gt; System.out.println(category));</span><br></pre></td></tr></table></figure><h4 id="3-4-3-终结操作"><a href="#3-4-3-终结操作" class="headerlink" title="3.4.3 终结操作"></a>3.4.3 终结操作</h4><h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h5><p>​    对流中的元素进行遍历操作，我们通过传入的参数去指定对遍历到的元素进行什么具体操作。</p><p>例子：</p><p>​    输出所有作家的名字</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        输出所有作家的名字</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">        authors.stream()</span><br><span class="line">                .map(author -&gt; author.getName())</span><br><span class="line">                .distinct()</span><br><span class="line">                .forEach(name-&gt; System.out.println(name));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="count"><a href="#count" class="headerlink" title="count"></a>count</h5><p>​    可以用来获取当前流中元素的个数。</p><p>例子：</p><p>​    打印这些作家的所出书籍的数目，注意删除重复元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        打印这些作家的所出书籍的数目，注意删除重复元素。</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> count = authors.stream()</span><br><span class="line">                .flatMap(author -&gt; author.getBooks().stream())</span><br><span class="line">                .distinct()</span><br><span class="line">                .count();</span><br><span class="line">        System.out.println(count);</span><br></pre></td></tr></table></figure><h5 id="max-amp-min"><a href="#max-amp-min" class="headerlink" title="max&amp;min"></a>max&amp;min</h5><p>​    可以用来或者流中的最值。</p><p>例子：</p><p>​    分别获取这些作家的所出书籍的最高分和最低分并打印。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        分别获取这些作家的所出书籍的最高分和最低分并打印。</span></span><br><span class="line">        <span class="comment">//Stream&lt;Author&gt;  -&gt; Stream&lt;Book&gt; -&gt;Stream&lt;Integer&gt;  -&gt;求值</span></span><br><span class="line"></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        Optional&lt;Integer&gt; max = authors.stream()</span><br><span class="line">                .flatMap(author -&gt; author.getBooks().stream())</span><br><span class="line">                .map(book -&gt; book.getScore())</span><br><span class="line">                .max((score1, score2) -&gt; score1 - score2);</span><br><span class="line"></span><br><span class="line">        Optional&lt;Integer&gt; min = authors.stream()</span><br><span class="line">                .flatMap(author -&gt; author.getBooks().stream())</span><br><span class="line">                .map(book -&gt; book.getScore())</span><br><span class="line">                .min((score1, score2) -&gt; score1 - score2);</span><br><span class="line">        System.out.println(max.get());</span><br><span class="line">        System.out.println(min.get());</span><br></pre></td></tr></table></figure><h5 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h5><p>​    把当前流转换成一个集合。</p><p>例子：</p><p>​    获取一个存放所有作者名字的List集合。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        获取一个存放所有作者名字的List集合。</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        List&lt;String&gt; nameList = authors.stream()</span><br><span class="line">                .map(author -&gt; author.getName())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(nameList);</span><br></pre></td></tr></table></figure><p>​    获取一个所有书名的Set集合。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        获取一个所有书名的Set集合。</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        Set&lt;Book&gt; books = authors.stream()</span><br><span class="line">                .flatMap(author -&gt; author.getBooks().stream())</span><br><span class="line">                .collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">        System.out.println(books);</span><br></pre></td></tr></table></figure><p>​    获取一个Map集合，map的key为作者名，value为List<Book></Book></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        获取一个Map集合，map的key为作者名，value为List&lt;Book&gt;</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, List&lt;Book&gt;&gt; map = authors.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .collect(Collectors.toMap(author -&gt; author.getName(), author -&gt; author.getBooks()));</span><br><span class="line"></span><br><span class="line">        System.out.println(map);</span><br></pre></td></tr></table></figure><h5 id="查找与匹配"><a href="#查找与匹配" class="headerlink" title="查找与匹配"></a>查找与匹配</h5><h6 id="anyMatch"><a href="#anyMatch" class="headerlink" title="anyMatch"></a>anyMatch</h6><p>​    可以用来判断是否有任意符合匹配条件的元素，结果为boolean类型。</p><p>例子：</p><p>​    判断是否有年龄在29以上的作家</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        判断是否有年龄在29以上的作家</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        <span class="keyword">boolean</span> flag = authors.stream()</span><br><span class="line">                .anyMatch(author -&gt; author.getAge() &gt; <span class="number">29</span>);</span><br><span class="line">        System.out.println(flag);</span><br></pre></td></tr></table></figure><h6 id="allMatch"><a href="#allMatch" class="headerlink" title="allMatch"></a>allMatch</h6><p>​    可以用来判断是否都符合匹配条件，结果为boolean类型。如果都符合结果为true，否则结果为false。</p><p>例子：</p><p>​    判断是否所有的作家都是成年人</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        判断是否所有的作家都是成年人</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        <span class="keyword">boolean</span> flag = authors.stream()</span><br><span class="line">                .allMatch(author -&gt; author.getAge() &gt;= <span class="number">18</span>);</span><br><span class="line">        System.out.println(flag);</span><br></pre></td></tr></table></figure><h6 id="noneMatch"><a href="#noneMatch" class="headerlink" title="noneMatch"></a>noneMatch</h6><p>​    可以判断流中的元素是否都不符合匹配条件。如果都不符合结果为true，否则结果为false</p><p>例子：</p><p>​    判断作家是否都没有超过100岁的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        判断作家是否都没有超过100岁的。</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b = authors.stream()</span><br><span class="line">                .noneMatch(author -&gt; author.getAge() &gt; <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(b);</span><br></pre></td></tr></table></figure><h6 id="findAny"><a href="#findAny" class="headerlink" title="findAny"></a>findAny</h6><p>​    获取流中的任意一个元素。该方法没有办法保证获取的一定是流中的第一个元素。</p><p>例子：</p><p>​    获取任意一个年龄大于18的作家，如果存在就输出他的名字</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        获取任意一个年龄大于18的作家，如果存在就输出他的名字</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        Optional&lt;Author&gt; optionalAuthor = authors.stream()</span><br><span class="line">                .filter(author -&gt; author.getAge()&gt;<span class="number">18</span>)</span><br><span class="line">                .findAny();</span><br><span class="line"></span><br><span class="line">        optionalAuthor.ifPresent(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure><h6 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h6><p>​    获取流中的第一个元素。</p><p>例子：</p><p>​    获取一个年龄最小的作家，并输出他的姓名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        获取一个年龄最小的作家，并输出他的姓名。</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        Optional&lt;Author&gt; first = authors.stream()</span><br><span class="line">                .sorted((o1, o2) -&gt; o1.getAge() - o2.getAge())</span><br><span class="line">                .findFirst();</span><br><span class="line"></span><br><span class="line">        first.ifPresent(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure><h5 id="reduce归并"><a href="#reduce归并" class="headerlink" title="reduce归并"></a>reduce归并</h5><p>​    对流中的数据按照你指定的计算方式计算出一个结果。（缩减操作）</p><p>​    reduce的作用是把stream中的元素给组合起来，我们可以传入一个初始值，它会按照我们的计算方式依次拿流中的元素和初始化值进行计算，计算结果再和后面的元素计算。</p><p>​    reduce两个参数的重载形式内部的计算方式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T result = identity;</span><br><span class="line"><span class="keyword">for</span> (T element : <span class="keyword">this</span> stream)</span><br><span class="line">result = accumulator.apply(result, element)</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>​    其中identity就是我们可以通过方法参数传入的初始值，accumulator的apply具体进行什么计算也是我们通过方法参数来确定的。</p><p>例子：</p><p>​    使用reduce求所有作者年龄的和</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        使用reduce求所有作者年龄的和</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        Integer sum = authors.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .map(author -&gt; author.getAge())</span><br><span class="line">                .reduce(<span class="number">0</span>, (result, element) -&gt; result + element);</span><br><span class="line">        System.out.println(sum);</span><br></pre></td></tr></table></figure><p>​    使用reduce求所有作者中年龄的最大值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        使用reduce求所有作者中年龄的最大值</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        Integer max = authors.stream()</span><br><span class="line">                .map(author -&gt; author.getAge())</span><br><span class="line">                .reduce(Integer.MIN_VALUE, (result, element) -&gt; result &lt; element ? element : result);</span><br><span class="line"></span><br><span class="line">        System.out.println(max);</span><br></pre></td></tr></table></figure><p>​    使用reduce求所有作者中年龄的最小值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        使用reduce求所有作者中年龄的最小值</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        Integer min = authors.stream()</span><br><span class="line">                .map(author -&gt; author.getAge())</span><br><span class="line">                .reduce(Integer.MAX_VALUE, (result, element) -&gt; result &gt; element ? element : result);</span><br><span class="line">        System.out.println(min);</span><br></pre></td></tr></table></figure><p>​    reduce一个参数的重载形式内部的计算</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> foundAny = <span class="keyword">false</span>;</span><br><span class="line">  T result = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (T element : <span class="keyword">this</span> stream) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!foundAny) &#123;</span><br><span class="line">          foundAny = <span class="keyword">true</span>;</span><br><span class="line">          result = element;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          result = accumulator.apply(result, element);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> foundAny ? Optional.of(result) : Optional.empty();</span><br></pre></td></tr></table></figure><p>​    如果用一个参数的重载方法去求最小值代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        使用reduce求所有作者中年龄的最小值</span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">Optional&lt;Integer&gt; minOptional = authors.stream()</span><br><span class="line">        .map(author -&gt; author.getAge())</span><br><span class="line">        .reduce((result, element) -&gt; result &gt; element ? element : result);</span><br><span class="line">minOptional.ifPresent(age-&gt; System.out.println(age));</span><br></pre></td></tr></table></figure><h3 id="3-5-注意事项"><a href="#3-5-注意事项" class="headerlink" title="3.5 注意事项"></a>3.5 注意事项</h3><ul><li>惰性求值（如果没有终结操作，没有中间操作是不会得到执行的）</li><li>流是一次性的（一旦一个流对象经过一个终结操作后。这个流就不能再被使用）</li><li>不会影响原数据（我们在流中可以多数据做很多处理。但是正常情况下是不会影响原来集合中的元素的。这往往也是我们期望的）</li></ul><h2 id="4-Optional"><a href="#4-Optional" class="headerlink" title="4. Optional"></a>4. Optional</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>​    我们在编写代码的时候出现最多的就是空指针异常。所以在很多情况下我们需要做各种非空的判断。</p><p>​    例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Author author = getAuthor();</span><br><span class="line"><span class="keyword">if</span>(author!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    System.out.println(author.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    尤其是对象中的属性还是一个对象的情况下。这种判断会更多。    </p><p>​    而过多的判断语句会让我们的代码显得臃肿不堪。</p><p>​    所以在JDK8中引入了Optional,养成使用Optional的习惯后你可以写出更优雅的代码来避免空指针异常。</p><p>​    并且在很多函数式编程相关的API中也都用到了Optional，如果不会使用Optional也会对函数式编程的学习造成影响。</p><h3 id="4-2-使用"><a href="#4-2-使用" class="headerlink" title="4.2 使用"></a>4.2 使用</h3><h4 id="4-2-1-创建对象"><a href="#4-2-1-创建对象" class="headerlink" title="4.2.1 创建对象"></a>4.2.1 创建对象</h4><p>​    Optional就好像是包装类，可以把我们的具体数据封装Optional对象内部。然后我们去使用Optional中封装好的方法操作封装进去的数据就可以非常优雅的避免空指针异常。</p><p>​    我们一般使用<strong>Optional</strong>的<strong>静态方法ofNullable</strong>来把数据封装成一个Optional对象。无论传入的参数是否为null都不会出现问题。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Author author = getAuthor();</span><br><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(author);</span><br></pre></td></tr></table></figure><p>​    你可能会觉得还要加一行代码来封装数据比较麻烦。但是如果改造下getAuthor方法，让其的返回值就是封装好的Optional的话，我们在使用时就会方便很多。</p><p>​    而且在实际开发中我们的数据很多是从数据库获取的。Mybatis从3.5版本可以也已经支持Optional了。我们可以直接把dao方法的返回值类型定义成Optional类型，MyBastis会自己把数据封装成Optional对象返回。封装的过程也不需要我们自己操作。</p><p>​    如果你<strong>确定一个对象不是空</strong>的则可以使用<strong>Optional</strong>的<strong>静态方法of</strong>来把数据封装成Optional对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Author author = <span class="keyword">new</span> Author();</span><br><span class="line">Optional&lt;Author&gt; authorOptional = Optional.of(author);</span><br></pre></td></tr></table></figure><p>​    但是一定要注意，如果使用of的时候传入的参数必须不为null。（尝试下传入null会出现什么结果）</p><p>​    如果一个方法的返回值类型是Optional类型。而如果我们经判断发现某次计算得到的返回值为null，这个时候就需要把null封装成Optional对象返回。这时则可以使用<strong>Optional</strong>的<strong>静态方法empty</strong>来进行封装。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional.empty()</span><br></pre></td></tr></table></figure><p>​    </p><p>​    所以最后你觉得哪种方式会更方便呢？<strong>ofNullable</strong></p><h4 id="4-2-2-安全消费值"><a href="#4-2-2-安全消费值" class="headerlink" title="4.2.2 安全消费值"></a>4.2.2 安全消费值</h4><p>​    我们获取到一个Optional对象后肯定需要对其中的数据进行使用。这时候我们可以使用其<strong>ifPresent</strong>方法对来消费其中的值。</p><p>​    这个方法会判断其内封装的数据是否为空，不为空时才会执行具体的消费代码。这样使用起来就更加安全了。</p><p>​    例如,以下写法就优雅的避免了空指针异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());</span><br><span class="line"></span><br><span class="line">authorOptional.ifPresent(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure><h4 id="4-2-3-获取值"><a href="#4-2-3-获取值" class="headerlink" title="4.2.3 获取值"></a>4.2.3 获取值</h4><p>​    如果我们想获取值自己进行处理可以使用get方法获取，但是不推荐。因为当Optional内部的数据为空的时候会出现异常。</p><h4 id="4-2-4-安全获取值"><a href="#4-2-4-安全获取值" class="headerlink" title="4.2.4 安全获取值"></a>4.2.4 安全获取值</h4><p>​    如果我们期望安全的获取值。我们不推荐使用get方法，而是使用Optional提供的以下方法。</p><ul><li><p>orElseGet</p><p>获取数据并且设置数据为空时的默认值。如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建对象作为默认值返回。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());</span><br><span class="line">Author author1 = authorOptional.orElseGet(() -&gt; <span class="keyword">new</span> Author());</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>orElseThrow</p><p>获取数据，如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建异常抛出。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Author author = authorOptional.orElseThrow((Supplier&lt;Throwable&gt;) () -&gt; <span class="keyword">new</span> RuntimeException(<span class="string">&quot;author为空&quot;</span>));</span><br><span class="line">    System.out.println(author.getName());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">    throwable.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-2-5-过滤"><a href="#4-2-5-过滤" class="headerlink" title="4.2.5 过滤"></a>4.2.5 过滤</h4><p>​    我们可以使用filter方法对数据进行过滤。如果原本是有数据的，但是不符合判断，也会变成一个无数据的Optional对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());</span><br><span class="line">authorOptional.filter(author -&gt; author.getAge()&gt;<span class="number">100</span>).ifPresent(author -&gt; System.out.println(author.getName()));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-2-6-判断"><a href="#4-2-6-判断" class="headerlink" title="4.2.6 判断"></a>4.2.6 判断</h4><p>​    我们可以使用isPresent方法进行是否存在数据的判断。如果为空返回值为false,如果不为空，返回值为true。但是这种方式并不能体现Optional的好处，<strong>更推荐使用ifPresent方法</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (authorOptional.isPresent()) &#123;</span><br><span class="line">    System.out.println(authorOptional.get().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-7-数据转换"><a href="#4-2-7-数据转换" class="headerlink" title="4.2.7 数据转换"></a>4.2.7 数据转换</h4><p>​    Optional还提供了map可以让我们的对数据进行转换，并且转换得到的数据也还是被Optional包装好的，保证了我们的使用安全。</p><p>例如我们想获取作家的书籍集合。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;Author&gt; authorOptional = getAuthorOptional();</span><br><span class="line">    Optional&lt;List&lt;Book&gt;&gt; optionalBooks = authorOptional.map(author -&gt; author.getBooks());</span><br><span class="line">    optionalBooks.ifPresent(books -&gt; System.out.println(books));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-函数式接口"><a href="#5-函数式接口" class="headerlink" title="5. 函数式接口"></a>5. 函数式接口</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>​    <strong>只有一个抽象方法</strong>的接口我们称之为函数接口。</p><p>​    JDK的函数式接口都加上了**@FunctionalInterface** 注解进行标识。但是无论是否加上该注解只要接口中只有一个抽象方法，都是函数式接口。</p><h3 id="5-2-常见函数式接口"><a href="#5-2-常见函数式接口" class="headerlink" title="5.2 常见函数式接口"></a>5.2 常见函数式接口</h3><ul><li><p>​    Consumer 消费接口</p><p>根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数进行消费。</p><p><img src="/2021/03/14/han-shu-shi-bian-cheng/image-20211028145622163-16354041894551.png" alt="image-20211028145622163"></p></li><li><p>​    Function 计算转换接口</p><p>根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数计算或转换，把结果返回</p><p><img src="/2021/03/14/han-shu-shi-bian-cheng/image-20211028145707862-16354042291112.png" alt="image-20211028145707862"></p></li><li><p>​    Predicate 判断接口</p><p>根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数条件判断，返回判断结果</p><p><img src="/2021/03/14/han-shu-shi-bian-cheng/image-20211028145818743-16354043004393.png" alt="image-20211028145818743"></p></li><li><p>​    Supplier 生产型接口</p><p>根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中创建对象，把创建好的对象返回</p></li></ul><p><img src="/2021/03/14/han-shu-shi-bian-cheng/image-20211028145843368-16354043246954.png" alt="image-20211028145843368"></p><h3 id="5-3-常用的默认方法"><a href="#5-3-常用的默认方法" class="headerlink" title="5.3 常用的默认方法"></a>5.3 常用的默认方法</h3><ul><li><p>and</p><p>我们在使用Predicate接口时候可能需要进行判断条件的拼接。而and方法相当于是使用&amp;&amp;来拼接两个判断条件</p><p>例如：</p><p>打印作家中年龄大于17并且姓名的长度大于1的作家。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line">authorStream.filter(<span class="keyword">new</span> Predicate&lt;Author&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Author author)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> author.getAge()&gt;<span class="number">17</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.and(<span class="keyword">new</span> Predicate&lt;Author&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Author author)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> author.getName().length()&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)).forEach(author -&gt; System.out.println(author));</span><br></pre></td></tr></table></figure></li><li><p>or </p><p>我们在使用Predicate接口时候可能需要进行判断条件的拼接。而or方法相当于是使用||来拼接两个判断条件。</p><p>例如：</p><p>打印作家中年龄大于17或者姓名的长度小于2的作家。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        打印作家中年龄大于17或者姓名的长度小于2的作家。</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        authors.stream()</span><br><span class="line">                .filter(<span class="keyword">new</span> Predicate&lt;Author&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Author author)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> author.getAge()&gt;<span class="number">17</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.or(<span class="keyword">new</span> Predicate&lt;Author&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Author author)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> author.getName().length()&lt;<span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)).forEach(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>negate</p><p>Predicate接口中的方法。negate方法相当于是在判断添加前面加了个! 表示取反</p><p>例如：</p><p>打印作家中年龄不大于17的作家。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        打印作家中年龄不大于17的作家。</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        authors.stream()</span><br><span class="line">                .filter(<span class="keyword">new</span> Predicate&lt;Author&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Author author)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> author.getAge()&gt;<span class="number">17</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.negate()).forEach(author -&gt; System.out.println(author.getAge()));</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-方法引用"><a href="#6-方法引用" class="headerlink" title="6. 方法引用"></a>6. 方法引用</h2><p>​    我们在使用lambda时，如果方法体中只有一个方法的调用的话（包括构造方法）,我们可以用方法引用进一步简化代码。</p><h3 id="6-1-推荐用法"><a href="#6-1-推荐用法" class="headerlink" title="6.1 推荐用法"></a>6.1 推荐用法</h3><p>​    我们在使用lambda时不需要考虑什么时候用方法引用，用哪种方法引用，方法引用的格式是什么。我们只需要在写完lambda方法发现方法体只有一行代码，并且是方法的调用时使用快捷键尝试是否能够转换成方法引用即可。</p><p>​    当我们方法引用使用的多了慢慢的也可以直接写出方法引用。</p><h3 id="6-2-基本格式"><a href="#6-2-基本格式" class="headerlink" title="6.2 基本格式"></a>6.2 基本格式</h3><p>​    类名或者对象名::方法名</p><h3 id="6-3-语法详解-了解"><a href="#6-3-语法详解-了解" class="headerlink" title="6.3 语法详解(了解)"></a>6.3 语法详解(了解)</h3><h4 id="6-3-1-引用类的静态方法"><a href="#6-3-1-引用类的静态方法" class="headerlink" title="6.3.1 引用类的静态方法"></a>6.3.1 引用类的静态方法</h4><p>​    其实就是引用类的静态方法</p><h5 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名::方法名</span><br></pre></td></tr></table></figure><h5 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a>使用前提</h5><p>​    如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是<strong>调用了某个类的静态方法</strong>，并且我们把要重写的<strong>抽象方法中所有的参数都按照顺序传入了这个静态方法中</strong>，这个时候我们就可以引用类的静态方法。</p><p>​    </p><p>例如：</p><p>如下代码就可以用方法引用进行简化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line"></span><br><span class="line">authorStream.map(author -&gt; author.getAge())</span><br><span class="line">        .map(age-&gt;String.valueOf(age));</span><br></pre></td></tr></table></figure><p>注意，如果我们所重写的方法是没有参数的，调用的方法也是没有参数的也相当于符合以上规则。</p><p>优化后如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line"></span><br><span class="line">authorStream.map(author -&gt; author.getAge())</span><br><span class="line">        .map(String::valueOf);</span><br></pre></td></tr></table></figure><h4 id="6-3-2-引用对象的实例方法"><a href="#6-3-2-引用对象的实例方法" class="headerlink" title="6.3.2 引用对象的实例方法"></a>6.3.2 引用对象的实例方法</h4><h5 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象名::方法名</span><br></pre></td></tr></table></figure><h5 id="使用前提-1"><a href="#使用前提-1" class="headerlink" title="使用前提"></a>使用前提</h5><p>​    如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是<strong>调用了某个对象的成员方法</strong>，并且我们把要重写的<strong>抽象方法中所有的参数都按照顺序传入了这个成员方法中</strong>，这个时候我们就可以引用对象的实例方法</p><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">authorStream.map(author -&gt; author.getName())</span><br><span class="line">        .forEach(name-&gt;sb.append(name));</span><br></pre></td></tr></table></figure><p>优化后：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">authorStream.map(author -&gt; author.getName())</span><br><span class="line">        .forEach(sb::append);</span><br></pre></td></tr></table></figure><h4 id="6-3-4-引用类的实例方法"><a href="#6-3-4-引用类的实例方法" class="headerlink" title="6.3.4 引用类的实例方法"></a>6.3.4 引用类的实例方法</h4><h5 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a>格式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名::方法名</span><br></pre></td></tr></table></figure><h5 id="使用前提-2"><a href="#使用前提-2" class="headerlink" title="使用前提"></a>使用前提</h5><p>​    如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是<strong>调用了第一个参数的成员方法</strong>，并且我们把要<strong>重写的抽象方法中剩余的所有的参数都按照顺序传入了这个成员方法中</strong>，这个时候我们就可以引用类的实例方法。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">interface</span> <span class="title">UseString</span></span>&#123;</span><br><span class="line">       <span class="function">String <span class="title">use</span><span class="params">(String str,<span class="keyword">int</span> start,<span class="keyword">int</span> length)</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">subAuthorName</span><span class="params">(String str, UseString useString)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> useString.use(str,start,length);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       subAuthorName(<span class="string">&quot;三更草堂&quot;</span>, <span class="keyword">new</span> UseString() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> String <span class="title">use</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> str.substring(start,length);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    subAuthorName(<span class="string">&quot;三更草堂&quot;</span>, String::substring);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-3-5-构造器引用"><a href="#6-3-5-构造器引用" class="headerlink" title="6.3.5 构造器引用"></a>6.3.5 构造器引用</h4><p>​    如果方法体中的一行代码是构造器的话就可以使用构造器引用。</p><h5 id="格式-3"><a href="#格式-3" class="headerlink" title="格式"></a>格式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名::<span class="keyword">new</span></span><br></pre></td></tr></table></figure><h5 id="使用前提-3"><a href="#使用前提-3" class="headerlink" title="使用前提"></a>使用前提</h5><p>​    如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是<strong>调用了某个类的构造方法</strong>，并且我们把<strong>要重写的抽象方法中的所有的参数都按照顺序传入了这个构造方法中</strong>，这个时候我们就可以引用构造器。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.stream()</span><br><span class="line">        .map(author -&gt; author.getName())</span><br><span class="line">        .map(name-&gt;<span class="keyword">new</span> StringBuilder(name))</span><br><span class="line">        .map(sb-&gt;sb.append(<span class="string">&quot;-三更&quot;</span>).toString())</span><br><span class="line">        .forEach(str-&gt; System.out.println(str));</span><br></pre></td></tr></table></figure><p>优化后：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.stream()</span><br><span class="line">        .map(author -&gt; author.getName())</span><br><span class="line">        .map(StringBuilder::<span class="keyword">new</span>)</span><br><span class="line">        .map(sb-&gt;sb.append(<span class="string">&quot;-三更&quot;</span>).toString())</span><br><span class="line">        .forEach(str-&gt; System.out.println(str));</span><br></pre></td></tr></table></figure><h2 id="7-高级用法"><a href="#7-高级用法" class="headerlink" title="7. 高级用法"></a>7. 高级用法</h2><h3 id="基本数据类型优化"><a href="#基本数据类型优化" class="headerlink" title="基本数据类型优化"></a>基本数据类型优化</h3><p>​    我们之前用到的很多Stream的方法由于都使用了泛型。所以涉及到的参数和返回值都是引用数据类型。</p><p>​    即使我们操作的是整数小数，但是实际用的都是他们的包装类。JDK5中引入的自动装箱和自动拆箱让我们在使用对应的包装类时就好像使用基本数据类型一样方便。但是你一定要知道装箱和拆箱肯定是要消耗时间的。虽然这个时间消耗很下。但是在大量的数据不断的重复装箱拆箱的时候，你就不能无视这个时间损耗了。</p><p>​    所以为了让我们能够对这部分的时间消耗进行优化。Stream还提供了很多专门针对基本数据类型的方法。</p><p>​    例如：mapToInt,mapToLong,mapToDouble,flatMapToInt,flatMapToDouble等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test27</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">    authors.stream()</span><br><span class="line">            .map(author -&gt; author.getAge())</span><br><span class="line">            .map(age -&gt; age + <span class="number">10</span>)</span><br><span class="line">            .filter(age-&gt;age&gt;<span class="number">18</span>)</span><br><span class="line">            .map(age-&gt;age+<span class="number">2</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    authors.stream()</span><br><span class="line">            .mapToInt(author -&gt; author.getAge())</span><br><span class="line">            .map(age -&gt; age + <span class="number">10</span>)</span><br><span class="line">            .filter(age-&gt;age&gt;<span class="number">18</span>)</span><br><span class="line">            .map(age-&gt;age+<span class="number">2</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h3><p>​    当流中有大量元素时，我们可以使用并行流去提高操作的效率。其实并行流就是把任务分配给多个线程去完全。如果我们自己去用代码实现的话其实会非常的复杂，并且要求你对并发编程有足够的理解和认识。而如果我们使用Stream的话，我们只需要修改一个方法的调用就可以使用并行流来帮我们实现，从而提高效率。</p><p>​    parallel方法可以把串行流转换成并行流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test28</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">    Integer sum = stream.parallel()</span><br><span class="line">            .peek(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">                    System.out.println(num+Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .filter(num -&gt; num &gt; <span class="number">5</span>)</span><br><span class="line">            .reduce((result, ele) -&gt; result + ele)</span><br><span class="line">            .get();</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    也可以通过parallelStream直接获取并行流对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.parallelStream()</span><br><span class="line">        .map(author -&gt; author.getAge())</span><br><span class="line">        .map(age -&gt; age + <span class="number">10</span>)</span><br><span class="line">        .filter(age-&gt;age&gt;<span class="number">18</span>)</span><br><span class="line">        .map(age-&gt;age+<span class="number">2</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java8 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker常用命令</title>
      <link href="2021/01/25/docker-chang-yong-ming-ling/"/>
      <url>2021/01/25/docker-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h1><h2 id="1、Docker容器信息"><a href="#1、Docker容器信息" class="headerlink" title="1、Docker容器信息"></a>1、Docker容器信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##查看docker容器版本</span><br><span class="line">docker version</span><br><span class="line">##查看docker容器信息</span><br><span class="line">docker info</span><br><span class="line">##查看docker容器帮助</span><br><span class="line">docker --help</span><br></pre></td></tr></table></figure><h2 id="2、镜像操作"><a href="#2、镜像操作" class="headerlink" title="2、镜像操作"></a>2、镜像操作</h2><p>提示：对于镜像的操作可使用镜像名、镜像长ID和短ID。</p><h3 id="2-1、镜像查看"><a href="#2-1、镜像查看" class="headerlink" title="2.1、镜像查看"></a>2.1、镜像查看</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##列出本地images</span><br><span class="line">docker images</span><br><span class="line">##含中间映像层</span><br><span class="line">docker images -a</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/Docker/20210125173048.png" alt="image-20210125173048887"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##只显示镜像ID</span><br><span class="line">docker images -q</span><br><span class="line">##含中间映像层</span><br><span class="line">docker images -qa   </span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/Docker/20210125173111.png" alt="image-20210125173111671"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##显示镜像摘要信息(DIGEST列)</span><br><span class="line">docker images --digests</span><br><span class="line">##显示镜像完整信息</span><br><span class="line">docker images --no-trunc</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/Docker/20210125173137.png" alt="image-20210125173137749"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##搜索仓库MySQL镜像</span><br><span class="line">docker search mysql</span><br><span class="line">## --filter&#x3D;stars&#x3D;600：只显示 starts&gt;&#x3D;600 的镜像</span><br><span class="line">docker search --filter&#x3D;stars&#x3D;600 mysql</span><br><span class="line">## --no-trunc 显示镜像完整 DESCRIPTION 描述</span><br><span class="line">docker search --no-trunc mysql</span><br><span class="line">## --automated ：只列出 AUTOMATED&#x3D;OK 的镜像</span><br><span class="line">docker search  --automated mysql</span><br></pre></td></tr></table></figure><h3 id="2-2、镜像搜索"><a href="#2-2、镜像搜索" class="headerlink" title="2.2、镜像搜索"></a>2.2、镜像搜索</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##搜索仓库MySQL镜像</span><br><span class="line">docker search mysql</span><br><span class="line">## --filter&#x3D;stars&#x3D;600：只显示 starts&gt;&#x3D;600 的镜像</span><br><span class="line">docker search --filter&#x3D;stars&#x3D;600 mysql</span><br><span class="line">## --no-trunc 显示镜像完整 DESCRIPTION 描述</span><br><span class="line">docker search --no-trunc mysql</span><br><span class="line">## --automated ：只列出 AUTOMATED&#x3D;OK 的镜像</span><br><span class="line">docker search  --automated mysql</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/Docker/20210125173222.png" alt="image-20210125173222656"></p><h3 id="2-3、镜像下载"><a href="#2-3、镜像下载" class="headerlink" title="2.3、镜像下载"></a>2.3、镜像下载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##下载Redis官方最新镜像，相当于：docker pull redis:latest</span><br><span class="line">docker pull redis</span><br><span class="line">##下载仓库所有Redis镜像</span><br><span class="line">docker pull -a redis</span><br><span class="line">##下载私人仓库镜像</span><br><span class="line">docker pull bitnami&#x2F;redis</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/Docker/20210125173253.png" alt="image-20210125173253458"></p><h3 id="2-4、镜像删除"><a href="#2-4、镜像删除" class="headerlink" title="2.4、镜像删除"></a>2.4、镜像删除</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##单个镜像删除，相当于：docker rmi redis:latest</span><br><span class="line">docker rmi redis</span><br><span class="line">##强制删除(针对基于镜像有运行的容器进程)</span><br><span class="line">docker rmi -f redis</span><br><span class="line">##多个镜像删除，不同镜像间以空格间隔</span><br><span class="line">docker rmi -f redis tomcat nginx</span><br><span class="line">##删除本地全部镜像</span><br><span class="line">docker rmi -f $(docker images -q)</span><br></pre></td></tr></table></figure><h3 id="2-5、镜像构建"><a href="#2-5、镜像构建" class="headerlink" title="2.5、镜像构建"></a>2.5、镜像构建</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##（1）编写dockerfile</span><br><span class="line">cd &#x2F;docker&#x2F;dockerfile</span><br><span class="line">vim mycentos</span><br><span class="line">##（2）构建docker镜像</span><br><span class="line">docker build -f &#x2F;docker&#x2F;dockerfile&#x2F;mycentos -t mycentos:1.1</span><br></pre></td></tr></table></figure><h2 id="3、容器操作"><a href="#3、容器操作" class="headerlink" title="3、容器操作"></a>3、容器操作</h2><p>提示：对于容器的操作可使用CONTAINER ID 或 NAMES。</p><h3 id="3-1、容器启动"><a href="#3-1、容器启动" class="headerlink" title="3.1、容器启动"></a>3.1、容器启动</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##新建并启动容器，参数：-i  以交互模式运行容器；-t  为容器重新分配一个伪输入终端；--name  为容器指定一个名称</span><br><span class="line">docker run -i -t --name mycentos</span><br><span class="line">##后台启动容器，参数：-d  已守护方式启动容器</span><br><span class="line">docker run -d mycentos</span><br></pre></td></tr></table></figure><p>注意：此时使用”docker ps -a”会发现容器已经退出。这是docker的机制：要使Docker容器后台运行，就必须有一个前台进程。解决方案：将你要运行的程序以前台进程的形式运行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##启动一个或多个已经被停止的容器</span><br><span class="line">docker start redis</span><br><span class="line">##重启容器</span><br><span class="line">docker restart redis</span><br></pre></td></tr></table></figure><h3 id="3-2、容器进程"><a href="#3-2、容器进程" class="headerlink" title="3.2、容器进程"></a>3.2、容器进程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##top支持 ps 命令参数，格式：docker top [OPTIONS] CONTAINER [ps OPTIONS]</span><br><span class="line">##列出redis容器中运行进程</span><br><span class="line">docker top redis</span><br><span class="line">##查看所有运行容器的进程信息</span><br><span class="line">for i in  &#96;docker ps |grep Up|awk &#39;&#123;print $1&#125;&#39;&#96;;do echo \ &amp;&amp;docker top $i; done</span><br></pre></td></tr></table></figure><h3 id="3-3、容器日志"><a href="#3-3、容器日志" class="headerlink" title="3.3、容器日志"></a>3.3、容器日志</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##查看redis容器日志，默认参数</span><br><span class="line">docker logs rabbitmq</span><br><span class="line">##查看redis容器日志，参数：-f  跟踪日志输出；-t   显示时间戳；--tail  仅列出最新N条容器日志；</span><br><span class="line">docker logs -f -t --tail&#x3D;20 redis</span><br><span class="line">##查看容器redis从2019年05月21日后的最新10条日志。</span><br><span class="line">docker logs --since&#x3D;&quot;2019-05-21&quot; --tail&#x3D;10 redis</span><br></pre></td></tr></table></figure><h3 id="3-4、容器的进入与退出"><a href="#3-4、容器的进入与退出" class="headerlink" title="3.4、容器的进入与退出"></a>3.4、容器的进入与退出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##使用run方式在创建时进入</span><br><span class="line">docker run -it centos &#x2F;bin&#x2F;bash</span><br><span class="line">##关闭容器并退出</span><br><span class="line">exit</span><br><span class="line">##仅退出容器，不关闭</span><br><span class="line">快捷键：Ctrl + P + Q</span><br><span class="line">##直接进入centos 容器启动命令的终端，不会启动新进程，多个attach连接共享容器屏幕，参数：--sig-proxy&#x3D;false  确保CTRL-D或CTRL-C不会关闭容器</span><br><span class="line">docker attach --sig-proxy&#x3D;false centos </span><br><span class="line">##在 centos 容器中打开新的交互模式终端，可以启动新进程，参数：-i  即使没有附加也保持STDIN 打开；-t  分配一个伪终端</span><br><span class="line">docker exec -i -t  centos &#x2F;bin&#x2F;bash</span><br><span class="line">##以交互模式在容器中执行命令，结果返回到当前终端屏幕</span><br><span class="line">docker exec -i -t centos ls -l &#x2F;tmp</span><br><span class="line">##以分离模式在容器中执行命令，程序后台运行，结果不会反馈到当前终端</span><br><span class="line">docker exec -d centos  touch cache.txt </span><br></pre></td></tr></table></figure><h3 id="3-5、查看容器"><a href="#3-5、查看容器" class="headerlink" title="3.5、查看容器"></a>3.5、查看容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##查看正在运行的容器</span><br><span class="line">docker ps</span><br><span class="line">##查看正在运行的容器的ID</span><br><span class="line">docker ps -q</span><br><span class="line">##查看正在运行+历史运行过的容器</span><br><span class="line">docker ps -a</span><br><span class="line">##显示运行容器总文件大小</span><br><span class="line">docker ps -s</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/Docker/20210125173610.png" alt="image-20210125173610320"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##显示最近创建容器</span><br><span class="line">docker ps -l</span><br><span class="line">##显示最近创建的3个容器</span><br><span class="line">docker ps -n 3</span><br><span class="line">##不截断输出</span><br><span class="line">docker ps --no-trunc </span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/Docker/20210125173629.png" alt="image-20210125173629716"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##获取镜像redis的元信息</span><br><span class="line">docker inspect redis</span><br><span class="line">##获取正在运行的容器redis的 IP</span><br><span class="line">docker inspect --format&#x3D;&#39;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#39; redis</span><br></pre></td></tr></table></figure><h3 id="3-6、容器的停止与删除"><a href="#3-6、容器的停止与删除" class="headerlink" title="3.6、容器的停止与删除"></a>3.6、容器的停止与删除</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##停止一个运行中的容器</span><br><span class="line">docker stop redis</span><br><span class="line">##杀掉一个运行中的容器</span><br><span class="line">docker kill redis</span><br><span class="line">##删除一个已停止的容器</span><br><span class="line">docker rm redis</span><br><span class="line">##删除一个运行中的容器</span><br><span class="line">docker rm -f redis</span><br><span class="line">##删除多个容器</span><br><span class="line">docker rm -f $(docker ps -a -q)</span><br><span class="line">docker ps -a -q | xargs docker rm</span><br><span class="line">## -l 移除容器间的网络连接，连接名为 db</span><br><span class="line">docker rm -l db </span><br><span class="line">## -v 删除容器，并删除容器挂载的数据卷</span><br><span class="line">docker rm -v redis</span><br></pre></td></tr></table></figure><h3 id="3-7、生成镜像"><a href="#3-7、生成镜像" class="headerlink" title="3.7、生成镜像"></a>3.7、生成镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##基于当前redis容器创建一个新的镜像；参数：-a 提交的镜像作者；-c 使用Dockerfile指令来创建镜像；-m :提交时的说明文字；-p :在commit时，将容器暂停</span><br><span class="line">docker commit -a&#x3D;&quot;DeepInThought&quot; -m&#x3D;&quot;my redis&quot; [redis容器ID]  myredis:v1.1</span><br></pre></td></tr></table></figure><h3 id="3-8、容器与主机间的数据拷贝"><a href="#3-8、容器与主机间的数据拷贝" class="headerlink" title="3.8、容器与主机间的数据拷贝"></a>3.8、容器与主机间的数据拷贝</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##将rabbitmq容器中的文件copy至本地路径</span><br><span class="line">docker cp rabbitmq:&#x2F;[container_path] [local_path]</span><br><span class="line">##将主机文件copy至rabbitmq容器</span><br><span class="line">docker cp [local_path] rabbitmq:&#x2F;[container_path]&#x2F;</span><br><span class="line">##将主机文件copy至rabbitmq容器，目录重命名为[container_path]（注意与非重命名copy的区别）</span><br><span class="line">docker cp [local_path] rabbitmq:&#x2F;[container_path]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 虚拟容器 </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springCloud全家桶</title>
      <link href="2021/01/14/springcloud-quan-jia-tong/"/>
      <url>2021/01/14/springcloud-quan-jia-tong/</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>注：以下内容摘自个人日常笔记+收集笔记</p></div><h1 id="SpringCloud全家桶"><a href="#SpringCloud全家桶" class="headerlink" title="SpringCloud全家桶"></a>SpringCloud全家桶</h1><h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><ul><li>官网: <a href="https://www.martinfowler.com/articles/microservices.html">https://www.martinfowler.com/articles/microservices.html</a></li></ul><p>In short, the microservice architectural style is an approach to developing a single application as <code>a suite of small services</code>, each <code>running in its own process</code> and communicating with lightweight mechanisms, often an HTTP resource API. These services are <code>built around business capabilities</code> and <code>independently deployable</code> by fully automated deployment machinery. <code>There is a bare minimum of centralized management of these services</code>, which may be written in different programming languages and use different data storage technologies.                        —–[摘自官网]</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> a suite of small services                      --一系列微小服务</span><br><span class="line"><span class="bullet">-</span> running in its own process                                    --运行在自己的进程里</span><br><span class="line"><span class="bullet">-</span> built around business capabilities                            --围绕自己的业务开发</span><br><span class="line"><span class="bullet">-</span> independently deployable                                      --独立部署</span><br><span class="line"><span class="bullet">-</span> bare minimum of centralized management of these services      --基于分布式管理</span><br></pre></td></tr></table></figure><ul><li><p>官方定义:<strong>微服务就是由一系列围绕自己业务开发的微小服务构成,他们独立部署运行在自己的进程里,基于分布式的管理</strong></p><p>App 应学项目  分类模块   视频模块 评论模块  用户模块  统计模块…    单体应用</p><p>分类服务     独立应用  —&gt; 计算进程里面 —&gt;  独立部署   </p><p>视频服务                                                                                     基于分布式服务管理</p><p>评论服务</p><p>用户服务</p><p>….服务</p></li><li><p>通俗定义:<strong>微服务是一种架构，这种架构是将单个的整体应用程序分割成更小的项目关联的独立的服务。一个服务通常实现一组独立的特性或功能，包含自己的业务逻辑和适配器。各个微服务之间的关联通过暴露api来实现。这些独立的微服务不需要部署在同一个虚拟机，同一个系统和同一个应用服务器中。</strong></p></li></ul><h2 id="为什么是微服务"><a href="#为什么是微服务" class="headerlink" title="为什么是微服务?"></a>为什么是微服务?</h2><h3 id="单体应用"><a href="#单体应用" class="headerlink" title="单体应用"></a>单体应用</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150347.png" alt="image-20200708224716035"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.优点</span></span><br><span class="line"><span class="bullet">-</span>单一架构模式在项目初期很小的时候开发方便，测试方便，部署方便，运行良好。</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.缺点</span></span><br><span class="line"><span class="bullet">-</span> 应用随着时间的推进，加入的功能越来越多，最终会变得巨大，一个项目中很有可能数百万行的代码，互相之间繁琐的jar包。</span><br><span class="line"><span class="bullet">-</span> 久而久之，开发效率低，代码维护困难</span><br><span class="line"><span class="bullet">-</span> 还有一个如果想整体应用采用新的技术，新的框架或者语言，那是不可能的。</span><br><span class="line"><span class="bullet">-</span> 任意模块的漏洞或者错误都会影响这个应用，降低系统的可靠性</span><br></pre></td></tr></table></figure><h3 id="微服务架构应用"><a href="#微服务架构应用" class="headerlink" title="微服务架构应用"></a>微服务架构应用</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150353.png" alt="image-20200723155352063"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.优点</span></span><br><span class="line"><span class="bullet">-</span> 将服务拆分成多个单一职责的小的服务，进行单独部署，服务之间通过网络进行通信</span><br><span class="line"><span class="bullet">-</span> 每个服务应该有自己单独的管理团队，高度自治</span><br><span class="line"><span class="bullet">-</span> 服务各自有自己单独的职责，服务之间松耦合，避免因一个模块的问题导致服务崩溃</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.缺点</span></span><br><span class="line"><span class="bullet">-</span> 开发人员要处理分布式系统的复杂性</span><br><span class="line"><span class="bullet">-</span> 多服务运维难度，随着服务的增加，运维的压力也在增大</span><br><span class="line"><span class="bullet">-</span> 服务治理 和 服务监控 关键</span><br></pre></td></tr></table></figure><h3 id="架构的演变"><a href="#架构的演变" class="headerlink" title="架构的演变"></a>架构的演变</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.架构的演变过程</span></span><br><span class="line"><span class="bullet">-</span> [单一应用架构] <span class="code">`===&gt;`</span> [垂直应用架构] <span class="code">`===&gt;`</span> [分布式服务架构] <span class="code">`===&gt;`</span> [流动计算架构]||[微服务架构] <span class="code">`===&gt;`</span> [未知]</span><br></pre></td></tr></table></figure><ul><li>dubbo官网:<a href="http://dubbo.apache.org/zh-cn/docs/user/preface/background.html">http://dubbo.apache.org/zh-cn/docs/user/preface/background.html</a></li></ul><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150359.png" alt="image-20200318082336122"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1. All in One Application 单一架构</span></span><br><span class="line"><span class="bullet">-</span> 起初当网站流量很小时,将所有功能都写在一个应用里面,对整个应用进行部署,以减少部署节点和成本。对于这个架构简化增删改查的工作量的数据访问框架（ORM）是关键。</span><br><span class="line"></span><br><span class="line"><span class="section"># 2. Vertical Application 垂直架构</span></span><br><span class="line"><span class="bullet">-</span> 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，提升效率的方法之一是将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</span><br><span class="line"></span><br><span class="line"><span class="section"># 3. Distributed Service    分布式服务架构</span></span><br><span class="line"><span class="bullet">-</span> 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</span><br><span class="line"></span><br><span class="line"><span class="section"># 4. Elastic Computing流动计算架构即微服务架构</span></span><br><span class="line"><span class="bullet">-</span> 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键</span><br></pre></td></tr></table></figure><ul><li>友情提醒: <strong>好的架构并不是设计出来的,一定是进化来的!!!</strong></li></ul><h2 id="什么是SpringCloud"><a href="#什么是SpringCloud" class="headerlink" title="什么是SpringCloud"></a>什么是SpringCloud</h2><h3 id="官方定义"><a href="#官方定义" class="headerlink" title="官方定义"></a>官方定义</h3><ul><li>官方网址: <a href="https://cloud.spring.io/spring-cloud-static/Hoxton.SR5/reference/html/">https://cloud.spring.io/spring-cloud-static/Hoxton.SR5/reference/html/</a></li></ul><p><strong>Spring Cloud provides tools for developers to quickly build some of the common patterns in distributed systems</strong> (e.g. <code>configuration management</code>,<code> service discovery</code>, <code>circuit breakers, intelligent routing, micro-proxy, control bus</code>). Coordination of distributed systems leads to boiler plate patterns, and using Spring Cloud developers can quickly stand up services and applications that implement those patterns.  ——-[摘自官网]</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.翻译</span></span><br><span class="line"><span class="bullet">-</span> springcloud为开发人员提供了在分布式系统中快速构建一些通用模式的工具（例如配置管理、服务发现、断路器、智能路由、微代理、控制总线）。分布式系统的协调导致了锅炉板模式，使用springcloud开发人员可以快速地建立实现这些模式的服务和应用程序。</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.通俗理解</span></span><br><span class="line"><span class="bullet">-</span> springcloud是一个含概多个子项目的开发工具集,集合了众多的开源框架,他利用了Spring Boot开发的便利性实现了很多功能,如服务注册,服务注册发现,负载均衡等.SpringCloud在整合过程中主要是针对Netflix(耐非)开源组件的封装.SpringCloud的出现真正的简化了分布式架构的开发。</span><br><span class="line"><span class="bullet">-</span> NetFlix 是美国的一个在线视频网站,微服务业的翘楚,他是公认的大规模生产级微服务的杰出实践者,NetFlix的开源组件已经在他大规模分布式微服务环境中经过多年的生产实战验证,因此Spring Cloud中很多组件都是基于NetFlix组件的封装。</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.微服务架构下所存在问题?</span></span><br><span class="line"><span class="bullet">-</span>   基于独立业务拆分成一个微小的服务  每个服务独立部署 运行在自己的进程里面   服务之间使用http rest的方式进行通信</span><br><span class="line"><span class="bullet">-</span>   单体应用  分类模块  视频模块  用户模块    产生  测试    前端 pc  app  统一入口 localhost:8989</span><br><span class="line"><span class="bullet">-</span>   微服务架构应用   分类服务 8080  视频服务 8081  用户服务 8082 8083  .....</span><br><span class="line"><span class="bullet">-</span>   问题</span><br><span class="line"><span class="code">1.要有个组件帮助我们记录服务,监控服务,服务发现  服务注册和发现组件  注册中心</span></span><br><span class="line"><span class="code">2.服务调用问题http rest方式调用  --- 如何调用? 服务调用时如何实现服务负载均衡 ?</span></span><br><span class="line"><span class="code">3.服务雪崩效应?  </span></span><br><span class="line"><span class="code">4.服务配置文件管理?   </span></span><br><span class="line"><span class="code">5.网关组件?    </span></span><br></pre></td></tr></table></figure><h3 id="核心架构及其组件"><a href="#核心架构及其组件" class="headerlink" title="核心架构及其组件"></a>核心架构及其组件</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.核心组件说明</span></span><br><span class="line"><span class="bullet">-</span> eurekaserver、consul、nacos    服务注册中心组件</span><br><span class="line"><span class="bullet">-</span> rabbion &amp; openfeign      服务负载均衡 和 服务调用组件</span><br><span class="line"><span class="bullet">-</span> hystrix &amp; hystrix dashboard   服务断路器  和  服务监控组件</span><br><span class="line"><span class="bullet">-</span> zuul、gateway 服务网关组件</span><br><span class="line"><span class="bullet">-</span> config 统一配置中心组件</span><br><span class="line"><span class="bullet">-</span> bus                           消息总线组件</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150444.png" alt="image-20200724161314786"></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="版本命名"><a href="#版本命名" class="headerlink" title="版本命名"></a>版本命名</h3><ul><li>官网地址:<a href="https://spring.io/projects/spring-cloud">https://spring.io/projects/spring-cloud</a></li></ul><p>Spring Cloud is an umbrella(伞) project consisting of independent projects with, in principle, different release cadences. To manage the portfolio a BOM (Bill of Materials) is published with a curated set of dependencies on the individual project (see below). The release trains have names, not versions, to avoid confusion with the sub-projects. The names are an alphabetic sequence (so you can sort them chronologically) with names of London Tube stations (“Angel” is the first release, “Brixton” is the second). When point releases of the individual projects accumulate to a critical mass, or if there is a critical bug in one of them that needs to be available to everyone, the release train will push out “service releases” with names ending “.SRX”, where “X” is a number.     —[摘自官网]</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.翻译</span></span><br><span class="line"><span class="bullet">-</span> springcloud 版本管理方式: 命名方式  Angel.SR1~6 Brixton.SR1~6 Camden.SR1~6</span><br><span class="line"><span class="bullet">-</span> springcloud是一个由众多独立子项目组成的大型综合项目，原则每个子项目上有不同的发布节奏,都维护自己发布版本号。为了更好的管理springcloud的版本,通过一个资源清单BOM(Bill of Materials),为避免与子项目的发布号混淆，所以没有采用版本号的方式，而是通过命名的方式。这些名字是按字母顺序排列的。如伦敦地铁站的名称（“天使”是第一个版本，“布里斯顿”是第二个版本,&quot;卡姆登&quot;是第三个版本）。当单个项目的点发布累积到一个临界量，或者其中一个项目中有一个关键缺陷需要每个人都可以使用时，发布序列将推出名称以“.SRX”结尾的“服务发布”，其中“X”是一个数字。</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.伦敦地铁站名称 [了解]</span></span><br><span class="line"><span class="bullet">-</span> Angel、Brixton、Camden、Dalston、Edgware、Finchley、Greenwich、Hoxton、</span><br></pre></td></tr></table></figure><h3 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.版本选择官方建议 https://spring.io/projects/spring-cloud</span></span><br><span class="line"><span class="bullet">-</span> Angel 版本基于springboot1.2.x版本构建与1.3版本不兼容</span><br><span class="line"><span class="bullet">-</span> Brixton版本基于springboot1.3.x版本构建与1.2版本不兼容</span><br><span class="line"><span class="code">`2017年Brixton and Angel release官方宣布报废</span></span><br><span class="line"><span class="code">- Camden      版本基于springboot1.4.x版本构建并在1.5版本通过测试</span></span><br><span class="line"><span class="code">`2018年Camden release官方宣布报废</span></span><br><span class="line"><span class="code">- Dalston、Edgware  版本基于springboot1.5.x版本构建目前不能再springboot2.0.x版本中使用</span></span><br><span class="line"><span class="code">`Dalston(达尔斯顿)将于2018年12月官方宣布报废。Edgware将遵循Spring Boot 1.5.x的生命周期结束。</span></span><br><span class="line"><span class="code">- Finchley 版本基于springboot2.0.x版本进行构建,不能兼容1.x版本</span></span><br><span class="line"><span class="code">- Greenwich版本基于springboot2.1.x版本进行构建,不能兼容1.x版本</span></span><br><span class="line"><span class="code">- Hoxton版本基于springboot2.2.x版本进行构建</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150452.png" alt="image-20200709112427684"></p><h3 id="环境搭建-1"><a href="#环境搭建-1" class="headerlink" title="环境搭建"></a>环境搭建</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> springboot 2.2.x.RELEASE+</span><br><span class="line"><span class="bullet">-</span> springcloud Hoxton SR1~6</span><br><span class="line"><span class="bullet">-</span> java8+</span><br><span class="line"><span class="bullet">-</span> maven 3.3.6+</span><br><span class="line"><span class="bullet">-</span> idea 2018.3.5+</span><br><span class="line"></span><br><span class="line"><span class="section"># 1.创建springboot项目 指定版本为 2.2.5版本</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150455.png" alt="image-20200709115802270"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.引入springcloud的版本管理</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义springcloud使用版本号--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Hoxton.SR6<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--全局管理springcloud版本,并不会引入具体依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150504.png" alt="image-20200709120120478"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150500.png" alt="image-20200709120209047"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.完成上述操作springboot与springcloud环境搭建完成</span></span><br><span class="line"><span class="bullet">-</span> 接下来就是使用到具体的springcloud组件,在项目中引入具体的组件即可</span><br></pre></td></tr></table></figure><hr><h2 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h2><h3 id="什么服务注册中心"><a href="#什么服务注册中心" class="headerlink" title="什么服务注册中心"></a>什么服务注册中心</h3><p>所谓服务注册中心就是在整个的微服务架构中单独提出一个服务，这个服务不完成系统的任何的业务功能，仅仅用来完成对整个微服务系统的服务注册和服务发现，以及对服务健康状态的监控和管理功能。</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150558.png" alt="image-20200709124952525"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.服务注册中心</span></span><br><span class="line"><span class="bullet">-</span> 可以对所有的微服务的信息进行存储，如微服务的名称、IP、端口等</span><br><span class="line"><span class="bullet">-</span> 可以在进行服务调用时通过服务发现查询可用的微服务列表及网络地址进行服务调用</span><br><span class="line"><span class="bullet">-</span> 可以对所有的微服务进行心跳检测，如发现某实例长时间无法访问，就会从服务注册表移除该实例。</span><br></pre></td></tr></table></figure><h3 id="常用的注册中心"><a href="#常用的注册中心" class="headerlink" title="常用的注册中心"></a>常用的注册中心</h3><p>springcloud支持的多种注册中心Eureka(netflix)、Consul、Zookeeper、以及阿里巴巴推出Nacos组件。这些注册中心在本质上都是用来管理服务的注册和发现以及服务状态的检查的。</p><h4 id="1-Eureka"><a href="#1-Eureka" class="headerlink" title="1.Eureka"></a>1.Eureka</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.简介</span></span><br><span class="line"><span class="bullet">-</span> https://github.com/Netflix/eureka/wiki</span><br><span class="line"><span class="bullet">-</span> Eureka是Netflix开发的服务发现框架，本身是一个基于REST的服务。SpringCloud将它集成在其子项目spring-cloud-netflix中，以实现SpringCloud的服务注册和发现功能。</span><br><span class="line"><span class="code">Eureka包含两个组件：Eureka Server和Eureka Client。</span></span><br></pre></td></tr></table></figure><p>单体应用  ——&gt;  分类服务   商品服务  订单服务 用户服务……</p><p>Eureka Server 组件 :  服务注册中心组件    管理所有服务  支持所有服务注册</p><p>Eureka Client 组件 :   分类服务  商品服务  订单服务(微服务)</p><h5 id="开发Eureka-Server"><a href="#开发Eureka-Server" class="headerlink" title="开发Eureka Server"></a>开发Eureka Server</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.创建项目并引入eureka server依赖</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入 eureka server--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150620.png" alt="image-20200709160918779"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.编写配置application.properties</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8761#执行服务端口</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">eurekaserver #指定服务名称 唯一标识</span></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:8761/eureka  #指定服务注册中心的地址</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.开启Eureka Server,入口类加入注解</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Eurekaserver8761Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Eurekaserver8761Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150623.png" alt="image-20200709162043210"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.访问Eureka的服务注册页面</span></span><br><span class="line"><span class="bullet">-</span> http://localhost:8761</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150626.png" alt="image-20200709161916871"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 5.虽然能看到管理界面为什么项目启动控制台报错? eureka server 服务注册中心 &amp; client 微服务</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150632.png" alt="image-20200709162307608"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 出现上述问题原因:eureka组件包含 eurekaserver 和 eurekaclient。server是一个服务注册中心,用来接受客户端的注册。client的特性会让当前启动的服务把自己作为eureka的客户端进行服务中心的注册,当项目启动时服务注册中心还没有创建好,所以找我不到服务的客户端组件就直接报错了，当启动成功服务注册中心创建好了，日后client也能进行注册，就不再报错啦！</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 6.关闭Eureka自己注册自己</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8761</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">eurekaserver</span></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:8761/eureka</span></span><br><span class="line"><span class="meta">eureka.client.register-with-eureka</span>=<span class="string">false    #不再将自己同时作为客户端进行注册  </span></span><br><span class="line"><span class="meta">eureka.client.fetch-registry</span>=<span class="string">false#关闭作为客户端时从eureka server获取服务信息</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150637.png" alt="image-20200709163511121"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 7.再次启动,当前应用就是一个单纯Eureka Server,控制器也不再报错</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150641.png" alt="image-20200709163630273"></p><h5 id="开发Eureka-Client"><a href="#开发Eureka-Client" class="headerlink" title="开发Eureka Client"></a>开发Eureka Client</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.创建项目并引入eureka client依赖</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入eureka client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150645.png" alt="image-20200709164110003"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.编写配置application.properties</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8888#服务端口号</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">eurekaclient8888#服务名称唯一标识</span></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:8761/eureka #eureka注册中心地址</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150650.png" alt="image-20200709164404396"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.开启eureka客户端加入注解</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Eurekaclient8888Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Eurekaclient8888Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150655.png" alt="image-20200709164505482"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.启动之前的8761的服务注册中心,在启动eureka客户端服务</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150659.png" alt="image-20200709164622017"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 5.查看eureka server的服务注册情况</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150704.png" alt="image-20200709164729870"></p><h5 id="eureka自我保护机制"><a href="#eureka自我保护机制" class="headerlink" title="eureka自我保护机制"></a>eureka自我保护机制</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.服务频繁启动时 EurekaServer出现警告</span></span><br><span class="line"><span class="bullet">-</span> EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&#x27;RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150711.png" alt="image-20200709171532408"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.自我保护机制</span></span><br><span class="line"><span class="bullet">-</span> 官网地址: https://github.com/Netflix/eureka/wiki/Server-Self-Preservation-Mode</span><br><span class="line"><span class="bullet">-</span> 默认情况下，如果Eureka Server在一定时间内（默认90秒）没有接收到某个微服务实例的心跳，Eureka Server将会移除该实例。但是当网络分区故障发生时，微服务与Eureka Server之间无法正常通信，而微服务本身是正常运行的，此时不应该移除这个微服务，所以引入了自我保护机制。Eureka Server在运行期间会去统计心跳失败比例在 15 分钟之内是否低于 85%，如果低于 85%，Eureka Server 会将这些实例保护起来，让这些实例不会过期。这种设计的哲学原理就是&quot;宁可信其有不可信其无!&quot;。自我保护模式正是一种针对网络异常波动的安全保护措施，使用自我保护模式能使Eureka集群更加的健壮、稳定的运行。</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.在eureka server端关闭自我保护机制</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">eureka.server.enable-self-preservation</span>=<span class="string">false  #关闭自我保护</span></span><br><span class="line"><span class="meta">eureka.server.eviction-interval-timer-in-ms</span>=<span class="string">3000 #超时3s自动清除</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150720.png" alt="image-20200709231727148"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.微服务修改减短服务心跳的时间</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">eureka.instance.lease-expiration-duration-in-seconds</span>=<span class="string">10 #用来修改eureka server默认接受心跳的最大时间 默认是90s</span></span><br><span class="line"><span class="meta">eureka.instance.lease-renewal-interval-in-seconds</span>=<span class="string">5     #指定客户端多久向eureka server发送一次心跳 默认是30s</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.尽管如此关闭自我保护机制还是会出现警告</span></span><br><span class="line"><span class="bullet">-</span> THE SELF PRESERVATION MODE IS TURNED OFF. THIS MAY NOT PROTECT INSTANCE EXPIRY IN CASE OF NETWORK/OTHER PROBLEMS.</span><br><span class="line"><span class="bullet">-</span> `官方并不建议在生产情况下关闭</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150726.png" alt="image-20200709232933894"></p><h5 id="eureka-停止更新"><a href="#eureka-停止更新" class="headerlink" title="eureka 停止更新"></a>eureka 停止更新</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.官方停止更新说明</span></span><br><span class="line"><span class="bullet">-</span> https://github.com/Netflix/eureka/wiki</span><br><span class="line"><span class="bullet">-</span> 在1.x版本项目还是活跃的,但是在2.x版本中停止维护,出现问题后果自负!!!</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150735.png" alt="image-20200709233215860"></p><p>consul  服务注册中心  启动consul服务注册中心  运行 </p><p>consul 客户端 将springcloud 客户端(微服务)</p><h4 id="2-Consul"><a href="#2-Consul" class="headerlink" title="2.Consul"></a>2.Consul</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.consul 简介</span></span><br><span class="line"><span class="bullet">-</span> https://www.consul.io</span><br><span class="line"><span class="bullet">-</span> consul是一个可以提供服务发现，健康检查，多数据中心，Key/Value存储等功能的分布式服务框架，用于实现分布式系统的服务发现与配置。与其他分布式服务注册与发现的方案，使用起来也较为简单。Consul用Golang实现，因此具有天然可移植性(支持Linux、Windows和Mac OS X)；安装包仅包含一个可执行文件，方便部署。</span><br></pre></td></tr></table></figure><h5 id="安装consul"><a href="#安装consul" class="headerlink" title="安装consul"></a>安装consul</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.下载consul</span></span><br><span class="line"><span class="bullet">-</span> https://www.consul.io/downloads</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150821.png" alt="image-20200710103539186"></p><p><img src="/2021/01/14/springcloud-quan-jia-tong/dowlond\study\MDMDMD\java笔记\springCloud\springCloud全家桶.assets\image-20200710104357091.png" alt="image-20200710104357091"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.安装consul</span></span><br><span class="line"><span class="bullet">-</span> 官方安装视频地址: https://learn.hashicorp.com/consul/getting-started/install.html</span><br><span class="line"><span class="bullet">-</span> 1.解压之后发现consul只有一个脚本文件</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150828.png" alt="image-20200710105007805"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.根据解压缩目录配置环境变量</span></span><br><span class="line"><span class="bullet">-</span> 根据安装目录进行环境变量配置 [这里是macos和linux系统配置]</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150834.png" alt="image-20200710105305439"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.查看consul环境变量是否配置成功,执行命令出现如下信息代表成功</span></span><br><span class="line"><span class="bullet">-</span> consul -v</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150840.png" alt="image-20200710105449741"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 5.启动consul服务</span></span><br><span class="line"><span class="bullet">-</span> consul agent -dev</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150845.png" alt="image-20200710105654356"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 6.访问consul的web服务端口</span></span><br><span class="line"><span class="bullet">-</span> http://localhost:8500</span><br><span class="line"><span class="code">`consul默认服务端口是8500</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150851.png" alt="image-20200710105912943"></p><h5 id="开发consul-客户端即微服务"><a href="#开发consul-客户端即微服务" class="headerlink" title="开发consul 客户端即微服务"></a>开发consul 客户端即微服务</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.创建项目并引入consul客户端依赖</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--引入consul依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150915.png" alt="image-20200710113855944"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.编写properties配置</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8889</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">consulclient8889</span></span><br><span class="line"><span class="meta">spring.cloud.consul.host</span>=<span class="string">localhost#注册consul服务的主机</span></span><br><span class="line"><span class="meta">spring.cloud.consul.port</span>=<span class="string">8500#注册consul服务的端口号</span></span><br><span class="line"><span class="meta">spring.cloud.consul.discovery.register-health-check</span>=<span class="string">false    #关闭consu了服务的健康检查[不推荐]</span></span><br><span class="line"><span class="meta">spring.cloud.consul.discovery.service-name</span>=<span class="string">$&#123;spring.application.name&#125; #指定注册的服务名称 默认就是应用名</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150921.png" alt="image-20200713135437947"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.启动服务查看consul界面服务信息</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150926.png" alt="image-20200713135359150"></p><h5 id="consul-开启健康监控检查"><a href="#consul-开启健康监控检查" class="headerlink" title="consul 开启健康监控检查"></a>consul 开启健康监控检查</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.开启consul健康监控</span></span><br><span class="line"><span class="bullet">-</span> 默认情况加consul监控健康是开启的,但是必须依赖健康监控依赖才能正确监控健康状态所以直接启动会显示错误,引入健康监控依赖之后服务正常</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这个包是用做健康度监控的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150932.png" alt="image-20200713140146813"></p><h5 id="consul-关闭健康监控检查"><a href="#consul-关闭健康监控检查" class="headerlink" title="consul 关闭健康监控检查"></a>consul 关闭健康监控检查</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8889</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">consulclient8889</span></span><br><span class="line"><span class="meta">spring.cloud.consul.host</span>=<span class="string">localhost#注册consul服务的主机</span></span><br><span class="line"><span class="meta">spring.cloud.consul.port</span>=<span class="string">8500#注册consul服务的端口号</span></span><br><span class="line"><span class="meta">spring.cloud.consul.discovery.register-health-check</span>=<span class="string">false    #关闭consu了服务的健康检查[不推荐]</span></span><br><span class="line"><span class="meta">spring.cloud.consul.discovery.service-name</span>=<span class="string">$&#123;spring.application.name&#125; #指定注册的服务名称 默认就是应用名</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150938.png" alt="image-20200710114321913"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150942.png" alt="image-20200710121728014"></p><h3 id="不同注册中心区别"><a href="#不同注册中心区别" class="headerlink" title="不同注册中心区别"></a>不同注册中心区别</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.CAP定理     服务注册中心集群 node1   node2  node3    ...   eureka(AP)   consul zk(CP)</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> CAP定理：CAP定理又称CAP原则，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。</span><br><span class="line"><span class="code">`一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</span></span><br><span class="line"><span class="code">`可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</span></span><br><span class="line"><span class="code">`分区容忍性（P），就是高可用性，一个节点崩了，并不影响其它的节点（100个节点，挂了几个，不影响服务，越多机器越好）</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"># 2.Eureka特点  </span></span><br><span class="line"><span class="code">- Eureka中没有使用任何的数据强一致性算法保证不同集群间的Server的数据一致，仅通过数据拷贝的方式争取注册中心数据的最终一致性，虽然放弃数据强一致性但是换来了Server的可用性，降低了注册的代价，提高了集群运行的健壮性。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"># 3.Consul特点</span></span><br><span class="line"><span class="code">- 基于Raft算法，Consul提供强一致性的注册中心服务，但是由于Leader节点承担了所有的处理工作，势必加大了注册和发现的代价，降低了服务的可用性。通过Gossip协议，Consul可以很好地监控Consul集群的运行，同时可以方便通知各类事件，如Leader选择发生、Server地址变更等。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"># 4.zookeeper特点</span></span><br><span class="line"><span class="code">- 基于Zab协议，Zookeeper可以用于构建具备数据强一致性的服务注册与发现中心，而与此相对地牺牲了服务的可用性和提高了注册需要的时间。  </span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114150948.png" alt="image-20200710135837525"></p><h2 id="服务间通信方式"><a href="#服务间通信方式" class="headerlink" title="服务间通信方式"></a>服务间通信方式</h2><p>接下来在整个微服务架构中,我们比较关心的就是服务间的服务改如何调用,有哪些调用方式?</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151108.png" alt="image-20200713095528763"></p><blockquote><p>总结:<code>在springcloud中服务间调用方式主要是使用 http restful方式进行服务间调用</code></p></blockquote><h3 id="基于RestTemplate的服务调用"><a href="#基于RestTemplate的服务调用" class="headerlink" title="基于RestTemplate的服务调用"></a>基于RestTemplate的服务调用</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> spring框架提供的RestTemplate类可用于在应用中调用rest服务，它简化了与http服务的通信方式，统一了RESTful的标准，封装了http链接， 我们只需要传入url及返回值类型即可。相较于之前常用的HttpClient，RestTemplate是一种更优雅的调用RESTful服务的方式。</span><br></pre></td></tr></table></figure><h4 id="1-RestTemplate-服务调用"><a href="#1-RestTemplate-服务调用" class="headerlink" title="1. RestTemplate 服务调用"></a>1. RestTemplate 服务调用</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.创建两个服务并注册到consul注册中心中</span></span><br><span class="line"><span class="bullet">-</span> users    代表用户服务 端口为 9999</span><br><span class="line"><span class="bullet">-</span> products 代表商品服务 端口为 9998</span><br><span class="line"><span class="code">`注意:这里服务仅仅用来测试,没有实际业务意义</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151114.png" alt="image-20200713101224125"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151120.png" alt="image-20200713101422031"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.在商品服务中提供服务方法</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/product/findAll&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;商品服务查询所有调用成功,当前服务端口:[&#123;&#125;]&quot;</span>,port);</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;服务调用成功,服务提供端口为: &quot;</span>+port);</span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151126.png" alt="image-20200713101553893"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.在用户服务中使用restTemplate进行调用</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151130.png" alt="image-20200713102053530"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/findAll&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;调用用户服务...&quot;</span>);</span><br><span class="line">        <span class="comment">//1.使用restTemplate调用商品服务</span></span><br><span class="line">        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">        String forObject = restTemplate.getForObject(<span class="string">&quot;http://localhost:9998/product/findAll&quot;</span>, </span><br><span class="line">                                                     String.class);</span><br><span class="line">        <span class="keyword">return</span> forObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.启动服务</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151137.png" alt="image-20200713102320469"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151141.png" alt="image-20200713140350189"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 5.测试服务调用</span></span><br><span class="line"><span class="bullet">-</span> 浏览器访问用户服务 http://localhost:9999/user/findAll</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151146.png" alt="image-20200713102454337"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151151.png" alt="image-20200713102616311"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 6.总结</span></span><br><span class="line"><span class="bullet">-</span> rest Template是直接基于服务地址调用没有在服务注册中心获取服务,也没有办法完成服务的负载均衡如果需要实现服务的负载均衡需要自己书写服务负载均衡策略。</span><br><span class="line"></span><br><span class="line"><span class="section"># 7.restTemplate直接调用存在问题</span></span><br><span class="line"><span class="bullet">-</span>  1.直接使用restTemplate方式调用没有经过服务注册中心获取服务地址,代码写死不利于维护,当服务宕机时不能高效剔除</span><br><span class="line"><span class="bullet">-</span>  2.调用服务时没有负载均衡需要自己实现负载均衡策略</span><br></pre></td></tr></table></figure><h3 id="基于Ribbon的服务调用"><a href="#基于Ribbon的服务调用" class="headerlink" title="基于Ribbon的服务调用"></a>基于Ribbon的服务调用</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> 官方网址: https://github.com/Netflix/ribbon</span><br><span class="line"><span class="bullet">-</span> Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于Netflix Ribbon实现。通过Spring Cloud的封装，可以让我们轻松地将面向服务的REST模版请求自动转换成客户端负载均衡的服务调用。</span><br></pre></td></tr></table></figure><h4 id="1-Ribbon-服务调用"><a href="#1-Ribbon-服务调用" class="headerlink" title="1.Ribbon 服务调用"></a>1.Ribbon 服务调用</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.项目中引入依赖</span></span><br><span class="line"><span class="bullet">-</span> 说明: </span><br><span class="line"><span class="code">1.如果使用的是eureka client 和 consul client,无须引入依赖,因为在eureka,consul中默认集成了ribbon组件</span></span><br><span class="line"><span class="code">2.如果使用的client中没有ribbon依赖需要显式引入如下依赖</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入ribbon依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.查看consul client中依赖的ribbon</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151159.png" alt="image-20200713140804414"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.使用restTemplate + ribbon进行服务调用</span></span><br><span class="line"><span class="bullet">-</span> 使用discovery client  进行客户端调用</span><br><span class="line"><span class="bullet">-</span> 使用loadBalanceClient 进行客户端调用</span><br><span class="line"><span class="bullet">-</span> 使用@loadBalanced     进行客户端调用</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.1 使用discovery Client形式调用</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取服务列表</span></span><br><span class="line">List&lt;ServiceInstance&gt; products = discoveryClient.getInstances(<span class="string">&quot;服务ID&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (ServiceInstance product : products) &#123;</span><br><span class="line">  log.info(<span class="string">&quot;服务主机:[&#123;&#125;]&quot;</span>,product.getHost());</span><br><span class="line">  log.info(<span class="string">&quot;服务端口:[&#123;&#125;]&quot;</span>,product.getPort());</span><br><span class="line">  log.info(<span class="string">&quot;服务地址:[&#123;&#125;]&quot;</span>,product.getUri());</span><br><span class="line">  log.info(<span class="string">&quot;====================================&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.2 使用loadBalance Client形式调用</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line"><span class="comment">//根据负载均衡策略选取某一个服务调用</span></span><br><span class="line">ServiceInstance product = loadBalancerClient.choose(<span class="string">&quot;服务ID&quot;</span>);<span class="comment">//地址  轮询策略</span></span><br><span class="line">log.info(<span class="string">&quot;服务主机:[&#123;&#125;]&quot;</span>,product.getHost());</span><br><span class="line">log.info(<span class="string">&quot;服务端口:[&#123;&#125;]&quot;</span>,product.getPort());</span><br><span class="line">log.info(<span class="string">&quot;服务地址:[&#123;&#125;]&quot;</span>,product.getUri());</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.3 使用@loadBalanced</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.整合restTemplate + ribbon</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.调用服务位置注入RestTemplate</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"><span class="comment">//3.调用</span></span><br><span class="line">String forObject = restTemplate.getForObject(<span class="string">&quot;http://服务ID/hello/hello?name=&quot;</span> + name, String.class);</span><br></pre></td></tr></table></figure><h4 id="2-Ribbon负载均衡策略"><a href="#2-Ribbon负载均衡策略" class="headerlink" title="2.Ribbon负载均衡策略"></a>2.Ribbon负载均衡策略</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.ribbon负载均衡算法</span></span><br><span class="line"><span class="bullet">-</span> RoundRobinRule         轮训策略按顺序循环选择 Server </span><br><span class="line"><span class="bullet">-</span> RandomRule             随机策略随机选择 Server  </span><br><span class="line"><span class="bullet">-</span> AvailabilityFilteringRule 可用过滤策略</span><br><span class="line"> `会先过滤由于多次访问故障而处于断路器跳闸状态的服务，还有并发的连接数量超过阈值的服务，然后对剩余的服务列表按照轮询策略进行访问</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> WeightedResponseTimeRule  响应时间加权策略   </span><br><span class="line"><span class="code">`根据平均响应的时间计算所有服务的权重，响应时间越快服务权重越大被选中的概率越高，刚启动时如果统计信息不足，则使用</span></span><br><span class="line"><span class="code">RoundRobinRule策略，等统计信息足够会切换到</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">- RetryRule                 重试策略          </span></span><br><span class="line"><span class="code">`先按照RoundRobinRule的策略获取服务，如果获取失败则在制定时间内进行重试，获取可用的服务。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">- BestAviableRule           最低并发策略     </span></span><br><span class="line"><span class="code">`会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151210.png" alt="image-20200713162940968"></p><h4 id="3-修改服务的默认负载均衡策略"><a href="#3-修改服务的默认负载均衡策略" class="headerlink" title="3.修改服务的默认负载均衡策略"></a>3.修改服务的默认负载均衡策略</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.修改服务默认随机策略</span></span><br><span class="line"><span class="bullet">-</span> 服务id.ribbon.NFLoadBalancerRuleClassName=com.netflix.loadbalancer.RandomRule</span><br><span class="line"><span class="code">`下面的products为服务的唯一标识</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">products.ribbon.NFLoadBalancerRuleClassName</span>=<span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151216.png" alt="image-20200713163722927"></p><h4 id="4-Ribbon停止维护"><a href="#4-Ribbon停止维护" class="headerlink" title="4.Ribbon停止维护"></a>4.Ribbon停止维护</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.官方停止维护说明</span></span><br><span class="line"><span class="bullet">-</span> https://github.com/Netflix/ribbon</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151221.png" alt="image-20200713195706787"></p><hr><h2 id="OpenFeign组件的使用"><a href="#OpenFeign组件的使用" class="headerlink" title="OpenFeign组件的使用"></a>OpenFeign组件的使用</h2><ul><li>思考: 使用RestTemplate+ribbon已经可以完成服务间的调用，为什么还要使用feign？</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String restTemplateForObject = restTemplate.getForObject(<span class="string">&quot;http://服务名/url?参数&quot;</span> + name, String.class);</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 存在问题:</span></span><br><span class="line"><span class="bullet">-</span> 1.每次调用服务都需要写这些代码,存在大量的代码冗余</span><br><span class="line"><span class="bullet">-</span> 2.服务地址如果修改,维护成本增高</span><br><span class="line"><span class="bullet">-</span> 3.使用时不够灵活</span><br></pre></td></tr></table></figure><h3 id="OpenFeign-组件"><a href="#OpenFeign-组件" class="headerlink" title="OpenFeign 组件"></a>OpenFeign 组件</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> https://cloud.spring.io/spring-cloud-openfeign/reference/html/</span><br><span class="line"><span class="bullet">-</span> Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性(可以使用springmvc的注解)，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，默认实现了负载均衡的效果并且springcloud为feign添加了springmvc注解的支持。</span><br></pre></td></tr></table></figure><h4 id="1-openFeign-服务调用"><a href="#1-openFeign-服务调用" class="headerlink" title="1.openFeign 服务调用"></a>1.openFeign 服务调用</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.服务调用方法引入依赖OpenFeign依赖</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Open Feign依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151230.png" alt="image-20200713201342374"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.入口类加入注解开启OpenFeign支持</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span>   <span class="comment">//开启openfeign支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Users9999Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Users9999Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151234.png" alt="image-20200713201602139"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.创建一个客户端调用接口</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//value属性用来指定:调用服务名称</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;PRODUCTS&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductClient</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/product/findAll&quot;)</span> <span class="comment">//书写服务调用路径</span></span><br><span class="line">    <span class="function">String <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151238.png" alt="image-20200713202133954"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.使用feignClient客户端对象调用服务</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注入客户端对象</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ProductClient productClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/findAllFeignClient&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findAllFeignClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;通过使用OpenFeign组件调用商品服务...&quot;</span>);</span><br><span class="line">  String msg = productClient.findAll();</span><br><span class="line">  <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151242.png" alt="image-20200713202615159"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 5.访问并测试服务</span></span><br><span class="line"><span class="bullet">-</span> http://localhost:9999/user/findAllFeignClient</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151249.png" alt="image-20200713202802056"></p><h4 id="2-调用服务并传参"><a href="#2-调用服务并传参" class="headerlink" title="2.调用服务并传参"></a>2.调用服务并传参</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> 服务和服务之间通信,不仅仅是调用,往往在调用过程中还伴随着参数传递,接下来重点来看看OpenFeign在调用服务时如何传递参数</span><br></pre></td></tr></table></figure><h6 id="GET方式调用服务传递参数"><a href="#GET方式调用服务传递参数" class="headerlink" title="GET方式调用服务传递参数"></a>GET方式调用服务传递参数</h6><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.GET方式调用服务传递参数</span></span><br><span class="line"><span class="bullet">-</span> 在商品服务中加入需要传递参数的服务方法来进行测试</span><br><span class="line"><span class="bullet">-</span> 在用户服务中进行调用商品服务中需要传递参数的服务方法进行测试</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.商品服务中添加如下方法</span></span><br><span class="line"> <span class="meta">@GetMapping(&quot;/product/findOne&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">findOne</span><span class="params">(String productId)</span></span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;商品服务查询商品信息调用成功,当前服务端口:[&#123;&#125;]&quot;</span>,port);</span><br><span class="line">  log.info(<span class="string">&quot;当前接收商品信息的id:[&#123;&#125;]&quot;</span>,productId);</span><br><span class="line">  Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">  map.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;商品服务查询商品信息调用成功,当前服务端口: &quot;</span>+port);</span><br><span class="line">  map.put(<span class="string">&quot;status&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">  map.put(<span class="string">&quot;productId&quot;</span>,productId);</span><br><span class="line">  <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151254.png" alt="image-20200713203833730"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.用户服务中在product客户端中声明方法</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;PRODUCTS&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductClient</span> </span>&#123; </span><br><span class="line"><span class="meta">@GetMapping(&quot;/product/findOne&quot;)</span></span><br><span class="line"> <span class="function">String <span class="title">findOne</span><span class="params">(<span class="meta">@RequestParam(&quot;productId&quot;)</span> String productId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151304.png" alt="image-20200713204301830"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.用户服务中调用并传递参数</span></span><br><span class="line"><span class="comment">//注入客户端对象</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ProductClient productClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/feign/test1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">test1</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;用来测试Openfiegn的GET方式参数传递&quot;</span>);</span><br><span class="line">  Map&lt;String, Object&gt; msg = productClient.findOne(id);</span><br><span class="line">  log.info(<span class="string">&quot;调用返回信息:[&#123;&#125;]&quot;</span>,msg);</span><br><span class="line">  <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151308.png" alt="image-20200728173210751"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 测试访问</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151312.png" alt="image-20200713204827577"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151317.png" alt="image-20200713204851383"></p><h6 id="post方式调用服务传递参数"><a href="#post方式调用服务传递参数" class="headerlink" title="post方式调用服务传递参数"></a>post方式调用服务传递参数</h6><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.post方式调用服务传递参数</span></span><br><span class="line"><span class="bullet">-</span> 在商品服务中加入需要传递参数的服务方法来进行测试</span><br><span class="line"><span class="bullet">-</span> 在用户服务中进行调用商品服务中需要传递参数的服务方法进行测试</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.商品服务加入post方式请求并接受name</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/product/save&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">save</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;商品服务保存商品调用成功,当前服务端口:[&#123;&#125;]&quot;</span>,port);</span><br><span class="line">  log.info(<span class="string">&quot;当前接收商品名称:[&#123;&#125;]&quot;</span>,name);</span><br><span class="line">  Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">  map.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;商品服务查询商品信息调用成功,当前服务端口: &quot;</span>+port);</span><br><span class="line">  map.put(<span class="string">&quot;status&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">  map.put(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">  <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151322.png" alt="image-20200713205125242"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.用户服务中在product客户端中声明方法</span></span><br><span class="line"><span class="comment">//value属性用来指定:调用服务名称</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;PRODUCTS&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/product/save&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">save</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151327.png" alt="image-20200713205734920"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.用户服务中调用并传递参数</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ProductClient productClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/save&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(String productName)</span></span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;接收到的商品信息名称:[&#123;&#125;]&quot;</span>,productName);</span><br><span class="line">  String save = productClient.save(productName);</span><br><span class="line">  log.info(<span class="string">&quot;调用成功返回结果: &quot;</span>+save);</span><br><span class="line">  <span class="keyword">return</span> save;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151330.png" alt="image-20200713205823467"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 测试访问</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151334.png" alt="image-20200713205919054"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151338.png" alt="image-20200713210001477"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.传递对象类型参数</span></span><br><span class="line"><span class="bullet">-</span> 商品服务定义对象</span><br><span class="line"><span class="bullet">-</span> 商品服务定义对象接收方法</span><br><span class="line"><span class="bullet">-</span> 用户服务调用商品服务定义对象参数方法进行参数传递</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.商品服务定义对象</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Date bir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151344.png" alt="image-20200713210437488"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.商品服务定义接收对象的方法</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/product/saveProduct&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">saveProduct</span><span class="params">(<span class="meta">@RequestBody</span> Product product)</span></span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;商品服务保存商品信息调用成功,当前服务端口:[&#123;&#125;]&quot;</span>,port);</span><br><span class="line">  log.info(<span class="string">&quot;当前接收商品名称:[&#123;&#125;]&quot;</span>,product);</span><br><span class="line">  Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">  map.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;商品服务查询商品信息调用成功,当前服务端口: &quot;</span>+port);</span><br><span class="line">  map.put(<span class="string">&quot;status&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">  map.put(<span class="string">&quot;product&quot;</span>,product);</span><br><span class="line">  <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151351.png" alt="image-20200713210641668"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.将商品对象复制到用户服务中</span></span><br><span class="line"><span class="comment">//4.用户服务中在product客户端中声明方法</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;PRODUCTS&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductClient</span> </span>&#123;</span><br><span class="line">  <span class="meta">@PostMapping(&quot;/product/saveProduct&quot;)</span></span><br><span class="line">  <span class="function">String <span class="title">saveProduct</span><span class="params">(<span class="meta">@RequestBody</span> Product product)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意:服务提供方和调用方一定要加入@RequestBody注解 </span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151357.png" alt="image-20200713211213241"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5.在用户服务中调用保存商品信息服务</span></span><br><span class="line"><span class="comment">//注入客户端对象</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ProductClient productClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/saveProduct&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">saveProduct</span><span class="params">(Product product)</span></span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;接收到的商品信息:[&#123;&#125;]&quot;</span>,product);</span><br><span class="line">  String save = productClient.saveProduct(product);</span><br><span class="line">  log.info(<span class="string">&quot;调用成功返回结果: &quot;</span>+save);</span><br><span class="line">  <span class="keyword">return</span> save;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151402.png" alt="image-20200713211308524"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 测试</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151408.png" alt="image-20200713211338475"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151415.png" alt="image-20200713211402844"></p><h4 id="3-OpenFeign超时设置"><a href="#3-OpenFeign超时设置" class="headerlink" title="3.OpenFeign超时设置"></a>3.OpenFeign超时设置</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.超时说明</span></span><br><span class="line"><span class="bullet">-</span> 默认情况下,openFiegn在进行服务调用时,要求服务提供方处理业务逻辑时间必须在1S内返回,如果超过1S没有返回则OpenFeign会直接报错,不会等待服务执行,但是往往在处理复杂业务逻辑是可能会超过1S,因此需要修改OpenFeign的默认服务调用超时时间。</span><br><span class="line"><span class="bullet">-</span> 调用超时会出现如下错误：</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.模拟超时</span></span><br><span class="line"><span class="bullet">-</span> 服务提供方加入线程等待阻塞</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151418.png" alt="image-20200713213322984"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.进行客户端调用</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151422.png" alt="image-20200713213415230"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.修改OpenFeign默认超时时间</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">feign.client.config.PRODUCTS.connectTimeout</span>=<span class="string">5000  #配置指定服务连接超时</span></span><br><span class="line"><span class="meta">feign.client.config.PRODUCTS.readTimeout</span>=<span class="string">5000  #配置指定服务等待超时</span></span><br><span class="line"><span class="comment">#feign.client.config.default.connectTimeout=5000  #配置所有服务连接超时</span></span><br><span class="line"><span class="comment">#feign.client.config.default.readTimeout=5000#配置所有服务等待超时</span></span><br></pre></td></tr></table></figure><h4 id="4-OpenFeign调用详细日志展示"><a href="#4-OpenFeign调用详细日志展示" class="headerlink" title="4.OpenFeign调用详细日志展示"></a>4.OpenFeign调用详细日志展示</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> 往往在服务调用时我们需要详细展示feign的日志,默认feign在调用是并不是最详细日志输出,因此在调试程序时应该开启feign的详细日志展示。feign对日志的处理非常灵活可为每个feign客户端指定日志记录策略，每个客户端都会创建一个logger默认情况下logger的名称是feign的全限定名需要注意的是，feign日志的打印只会DEBUG级别做出响应。</span><br><span class="line"><span class="bullet">-</span> 我们可以为feign客户端配置各自的logger.level对象，告诉feign记录那些日志logger.lever有以下的几种值</span><br><span class="line"><span class="code">`NONE  不记录任何日志</span></span><br><span class="line"><span class="code">`BASIC 仅仅记录请求方法，url，响应状态代码及执行时间</span></span><br><span class="line"><span class="code">`HEADERS 记录Basic级别的基础上，记录请求和响应的header</span></span><br><span class="line"><span class="code">`FULL 记录请求和响应的header，body和元数据</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.开启日志展示</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">feign.client.config.PRODUCTS.loggerLevel</span>=<span class="string">full  #开启指定服务日志展示</span></span><br><span class="line"><span class="comment">#feign.client.config.default.loggerLevel=full  #全局开启服务日志展示</span></span><br><span class="line"><span class="meta">logging.level.com.baizhi.feignclients</span>=<span class="string">debug    #指定feign调用客户端对象所在包,必须是debug级别</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.测试服务调用查看日志</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151429.png" alt="image-20200713215108861"></p><h2 id="Hystrix组件使用"><a href="#Hystrix组件使用" class="headerlink" title="Hystrix组件使用"></a>Hystrix组件使用</h2><h3 id="Hystrix组件"><a href="#Hystrix组件" class="headerlink" title="Hystrix组件"></a>Hystrix组件</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151510.png" alt="image-20200715123359665"></p><p>In a distributed environment, inevitably some of the many service dependencies will fail. Hystrix is a library that helps you control the interactions between these distributed services by adding latency tolerance and fault tolerance logic. Hystrix does this by isolating points of access between the services, stopping cascading failures across them, and providing fallback options, all of which improve your system’s overall resiliency.                                                        –[摘自官方]</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> https://github.com/Netflix/Hystrix</span><br><span class="line"><span class="bullet">-</span> 译: 在分布式环境中，许多服务依赖项不可避免地会失败。Hystrix是一个库，它通过添加延迟容忍和容错逻辑来帮助您控制这些分布式服务之间的交互。Hystrix通过隔离服务之间的访问点、停止它们之间的级联故障以及提供后备选项来实现这一点，所有这些都可以提高系统的整体弹性。</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 通俗定义: Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统中，许多依赖不可避免的会调用失败，超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障(服务雪崩现象)，提高分布式系统的弹性。</span><br></pre></td></tr></table></figure><h4 id="1-服务雪崩"><a href="#1-服务雪崩" class="headerlink" title="1.服务雪崩"></a>1.服务雪崩</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.服务雪崩</span></span><br><span class="line"><span class="bullet">-</span> 在微服务之间进行服务调用是由于某一个服务故障，导致级联服务故障的现象，称为雪崩效应。雪崩效应描述的是提供方不可用，导致消费方不可用并将不可用逐渐放大的过程。</span><br><span class="line"><span class="section"># 2.图解雪崩效应</span></span><br><span class="line"><span class="bullet">-</span> 如存在如下调用链路:</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151516.png" alt="image-20200715151728240"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 而此时，Service A的流量波动很大，流量经常会突然性增加！那么在这种情况下，就算Service A能扛得住请求，Service B和Service C未必能扛得住这突发的请求。此时，如果Service C因为抗不住请求，变得不可用。那么Service B的请求也会阻塞，慢慢耗尽Service B的线程资源，Service B就会变得不可用。紧接着，Service A也会不可用，这一过程如下图所示</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151523.png" alt="image-20200715152623313"></p><h4 id="2-服务熔断"><a href="#2-服务熔断" class="headerlink" title="2.服务熔断"></a>2.服务熔断</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 服务熔断</span></span><br><span class="line"><span class="bullet">-</span> “熔断器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控，某个异常条件被触发，直接熔断整个服务。向调用方法返回一个符合预期的、可处理的备选响应(FallBack),而不是长时间的等待或者抛出调用方法无法处理的异常，就保证了服务调用方的线程不会被长时间占用，避免故障在分布式系统中蔓延，乃至雪崩。如果目标服务情况好转则恢复调用。服务熔断是解决服务雪崩的重要手段。</span><br><span class="line"></span><br><span class="line"><span class="section"># 服务熔断图示</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151528.png" alt="image-20200717085946385"></p><h4 id="3-服务降级"><a href="#3-服务降级" class="headerlink" title="3.服务降级"></a>3.服务降级</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 服务降级说明</span></span><br><span class="line"><span class="bullet">-</span> 服务压力剧增的时候根据当前的业务情况及流量对一些服务和页面有策略的降级，以此环节服务器的压力，以保证核心任务的进行。同时保证部分甚至大部分任务客户能得到正确的相应。也就是当前的请求处理不了了或者出错了，给一个默认的返回。</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span>  通俗: 关闭系统中边缘服务 保证系统核心服务的正常运行  称之为服务降级</span><br><span class="line">   //12  淘宝 删除地址  确认收货  删除订单   取消支付   节省cpu  内存</span><br><span class="line"><span class="section"># 服务降级图示</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151533.png" alt="image-20200717112327729"></p><h4 id="4-降级和熔断总结"><a href="#4-降级和熔断总结" class="headerlink" title="4.降级和熔断总结"></a>4.降级和熔断总结</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.共同点</span></span><br><span class="line"><span class="bullet">-</span> 目的很一致，都是从可用性可靠性着想，为防止系统的整体缓慢甚至崩溃，采用的技术手段；</span><br><span class="line"><span class="bullet">-</span> 最终表现类似，对于两者来说，最终让用户体验到的是某些功能暂时不可达或不可用；</span><br><span class="line"><span class="bullet">-</span> 粒度一般都是服务级别，当然，业界也有不少更细粒度的做法，比如做到数据持久层（允许查询，不允许增删改）；</span><br><span class="line"><span class="bullet">-</span> 自治性要求很高，熔断模式一般都是服务基于策略的自动触发，降级虽说可人工干预，但在微服务架构下，完全靠人显然不可能，开关预置、配置中心都是必要手段；</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.异同点</span></span><br><span class="line"><span class="bullet">-</span> 触发原因不太一样，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；</span><br><span class="line"><span class="bullet">-</span> 管理目标的层次不太一样，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始）</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.总结</span></span><br><span class="line"><span class="bullet">-</span> 熔断必会触发降级,所以熔断也是降级一种,区别在于熔断是对调用链路的保护,而降级是对系统过载的一种保护处理</span><br></pre></td></tr></table></figure><h4 id="5-服务熔断的实现"><a href="#5-服务熔断的实现" class="headerlink" title="5.服务熔断的实现"></a>5.服务熔断的实现</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#服务熔断的实现思路</span></span><br><span class="line"><span class="bullet">-</span> 引入hystrix依赖,并开启熔断器(断路器)</span><br><span class="line"><span class="bullet">-</span> 模拟降级方法</span><br><span class="line"><span class="bullet">-</span> 进行调用测试</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.项目中引入hystrix依赖</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入hystrix--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151540.png" alt="image-20200716090932981"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.开启断路器</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span>  <span class="comment">//用来开启断路器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Products9998Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Products9998Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151543.png" alt="image-20200716094200460"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.使用HystrixCommand注解实现断路</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务熔断</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/product/break&quot;)</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;testBreakFall&quot; )</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testBreak</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;接收的商品id为: &quot;</span>+ id);</span><br><span class="line">  <span class="keyword">if</span>(id&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;数据不合法!!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;当前接收商品id: &quot;</span>+id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testBreakFall</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;当前数据不合法: &quot;</span>+id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151548.png" alt="image-20200717090743474"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.访问测试</span></span><br><span class="line"><span class="bullet">-</span> 正常参数访问</span><br><span class="line"><span class="bullet">-</span> 错误参数访问</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151554.png" alt="image-20200717090841831"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151557.png" alt="image-20200717091028876"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 5.总结</span></span><br><span class="line"><span class="bullet">-</span> 从上面演示过程中会发现如果触发一定条件断路器会自动打开,过了一点时间正常之后又会关闭。那么断路器打开条件是什么呢？</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 6.断路器打开条件</span></span><br><span class="line"><span class="bullet">-</span> 官网: https://cloud.spring.io/spring-cloud-netflix/2.2.x/reference/html/#circuit-breaker-spring-cloud-circuit-breaker-with-hystrix</span><br></pre></td></tr></table></figure><p>A service failure in the lower level of services can cause cascading failure all the way up to the user. When calls to a particular service exceed <code>circuitBreaker.requestVolumeThreshold</code> (default: 20 requests) and the failure percentage is greater than <code>circuitBreaker.errorThresholdPercentage</code> (default: &gt;50%) in a rolling window defined by <code>metrics.rollingStats.timeInMilliseconds</code> (default: 10 seconds), the circuit opens and the call is not made. In cases of error and an open circuit, a fallback can be provided by the developer.                                                                        –摘自官方</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 原文翻译之后,总结打开关闭的条件:</span></span><br><span class="line"><span class="bullet">-</span> 1、  当满足一定的阀值的时候（默认10秒内超过20个请求次数）</span><br><span class="line"><span class="bullet">-</span> 2、  当失败率达到一定的时候（默认10秒内超过50%的请求失败）</span><br><span class="line"><span class="bullet">-</span> 3、  到达以上阀值，断路器将会开启</span><br><span class="line"><span class="bullet">-</span> 4、  当开启的时候，所有请求都不会进行转发</span><br><span class="line"><span class="bullet">-</span> 5、  一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。重复4和5。</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151605.png" alt="image-20200717092819616"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 7.默认的服务FallBack处理方法</span></span><br><span class="line"><span class="bullet">-</span> 如果为每一个服务方法开发一个降级,对于我们来说,可能会出现大量的代码的冗余,不利于维护,这个时候就需要加入默认服务降级处理方法</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/product/hystrix&quot;)</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;testHystrixFallBack&quot;)</span> <span class="comment">//通过HystrixCommand降级处理 指定出错的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testHystrix</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;接收名称为: &quot;</span> + name);</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;服务[&quot;</span> + port + <span class="string">&quot;]响应成功,当前接收名称为:&quot;</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//服务降级处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testHystrixFallBack</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> port + <span class="string">&quot;当前服务已经被降级处理!!!,接收名称为: &quot;</span>+name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151610.png" alt="image-20200716095016332"></p><h4 id="6-服务降级的实现"><a href="#6-服务降级的实现" class="headerlink" title="6.服务降级的实现"></a>6.服务降级的实现</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.客户端openfeign + hystrix实现服务降级实现</span></span><br><span class="line"><span class="bullet">-</span> 引入hystrix依赖</span><br><span class="line"><span class="bullet">-</span> 配置文件开启feign支持hystrix</span><br><span class="line"><span class="bullet">-</span> 在feign客户端调用加入fallback指定降级处理</span><br><span class="line"><span class="bullet">-</span> 开发降级处理方法</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.开启openfeign支持服务降级</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">feign.hystrix.enabled</span>=<span class="string">true #开启openfeign支持降级</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.在openfeign客户端中加如Hystrix</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;PRODUCTS&quot;,fallback = ProductFallBack.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/product/hystrix&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">testHystrix</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151616.png" alt="image-20200716101101091"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.开发fallback处理类</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFallBack</span> <span class="keyword">implements</span> <span class="title">ProductClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testHystrix</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我是客户端的Hystrix服务实现!!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151621.png" alt="image-20200717101921108"></p><p><strong>注意:如果服务端降级和客户端降级同时开启,要求服务端降级方法的返回值必须与客户端方法降级的返回值一致!!!</strong></p><h4 id="7-Hystrix-Dashboard"><a href="#7-Hystrix-Dashboard" class="headerlink" title="7.Hystrix Dashboard"></a>7.Hystrix Dashboard</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> Hystrix Dashboard的一个主要优点是它收集了关于每个HystrixCommand的一组度量。Hystrix仪表板以高效的方式显示每个断路器的运行状况。</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151625.png" alt="image-20200716161556743"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.项目中引入依赖</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入hystrix dashboard 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.入口类中开启hystrix dashboard</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span> <span class="comment">//开启监控面板</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hystrixdashboard9990Application</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(Hystrixdashboard9990Application.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151631.png" alt="image-20200717154912206"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.启动hystrix dashboard应用</span></span><br><span class="line"><span class="bullet">-</span> http://localhost:9990(dashboard端口)/hystrix</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151635.png" alt="image-20200717155059512"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.监控的项目中入口类中加入监控路径配置[新版本坑],并启动监控项目</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">getServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  HystrixMetricsStreamServlet streamServlet = <span class="keyword">new</span> HystrixMetricsStreamServlet();</span><br><span class="line">  ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(streamServlet);</span><br><span class="line">  registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">  registrationBean.addUrlMappings(<span class="string">&quot;/hystrix.stream&quot;</span>);</span><br><span class="line">  registrationBean.setName(<span class="string">&quot;HystrixMetricsStreamServlet&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151642.png" alt="image-20200717155120335"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 5.通过监控界面监控</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151646.png" alt="image-20200717155258994"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 6.点击监控,一致loading,打开控制台发现报错[特别坑]</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151652.png" alt="image-20200717155555786"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 解决方案</span></span><br><span class="line"><span class="bullet">-</span> 新版本中springcloud将jquery版本升级为3.4.1，定位到monitor.ftlh文件中，js的写法如下：</span><br><span class="line"><span class="code">$(window).load(function() </span></span><br><span class="line"><span class="code">- jquery 3.4.1已经废弃上面写法</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">- 修改方案 修改monitor.ftlh为如下调用方式：</span></span><br><span class="line"><span class="code">$(window).on(&quot;load&quot;,function()</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">- 编译jar源文件，重新打包引入后，界面正常响应。</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151708.png" alt="image-20200717160636218"></p><h4 id="8-Hystrix停止维护"><a href="#8-Hystrix停止维护" class="headerlink" title="8.Hystrix停止维护"></a>8.Hystrix停止维护</h4><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151715.png" alt="image-20200717161223806"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114151724.png" alt="image-20200717161400285"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 官方地址:https://github.com/Netflix/Hystrix</span></span><br><span class="line"><span class="bullet">-</span> 翻译:Hystrix（版本1.5.18）足够稳定，可以满足Netflix对我们现有应用的需求。同时，我们的重点已经转移到对应用程序的实时性能作出反应的更具适应性的实现，而不是预先配置的设置（例如，通过自适应并发限制）。对于像Hystrix这样的东西有意义的情况，我们打算继续在现有的应用程序中使用Hystrix，并在新的内部项目中利用诸如resilience4j这样的开放和活跃的项目。我们开始建议其他人也这样做。</span><br><span class="line"><span class="bullet">-</span> Dashboard也被废弃</span><br></pre></td></tr></table></figure><h2 id="Gateway组件使用"><a href="#Gateway组件使用" class="headerlink" title="Gateway组件使用"></a>Gateway组件使用</h2><h3 id="什么是服务网关"><a href="#什么是服务网关" class="headerlink" title="什么是服务网关"></a>什么是服务网关</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.说明</span></span><br><span class="line"><span class="bullet">-</span> 网关统一服务入口，可方便实现对平台众多服务接口进行管控，对访问服务的身份认证、防报文重放与防数据篡改、功能调用的业务鉴权、响应数据的脱敏、流量与并发控制，甚至基于API调用的计量或者计费等等。</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 网关 =  路由转发 + 过滤器</span><br><span class="line"><span class="code">`路由转发：接收一切外界请求，转发到后端的微服务上去；</span></span><br><span class="line"><span class="code">`在服务网关中可以完成一系列的横切功能，例如权限校验、限流以及监控等，这些都可以通过过滤器完成</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"># 2.为什么需要网关</span></span><br><span class="line"><span class="code"> - 1.网关可以实现服务的统一管理</span></span><br><span class="line"><span class="code"> - 2.网关可以解决微服务中通用代码的冗余问题(如权限控制,流量监控,限流等)</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"># 3.网关组件在微服务中架构</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114155631.png" alt="image-20200720171205828"></p><h3 id="服务网关组件"><a href="#服务网关组件" class="headerlink" title="服务网关组件"></a>服务网关组件</h3><h4 id="zuul"><a href="#zuul" class="headerlink" title="zuul"></a>zuul</h4><p>Zuul is the front door for all requests from devices and web sites to the backend of the Netflix streaming application. As an edge service application, Zuul is built to enable dynamic routing, monitoring, resiliency and security.</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.原文翻译</span></span><br><span class="line"><span class="bullet">-</span> https://github.com/Netflix/zuul/wiki</span><br><span class="line"><span class="bullet">-</span> zul是从设备和网站到Netflix流媒体应用程序后端的所有请求的前门。作为一个边缘服务应用程序，zul被构建为支持动态路由、监视、弹性和安全性。</span><br><span class="line"></span><br><span class="line"><span class="section"># 1.zuul版本说明</span></span><br><span class="line"><span class="bullet">-</span> 目前zuul组件已经从1.0更新到2.0，但是作为springcloud官方不再推荐使用zuul2.0，但是依然支持zuul2.</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.springcloud 官方集成zuul文档</span></span><br><span class="line"><span class="bullet">-</span> https://cloud.spring.io/spring-cloud-netflix/2.2.x/reference/html/#netflix-zuul-starter</span><br></pre></td></tr></table></figure><h4 id="gateway"><a href="#gateway" class="headerlink" title="gateway"></a>gateway</h4><p>This project provides a library for building an API Gateway on top of Spring MVC. Spring Cloud Gateway aims to provide a simple, yet effective way to route to APIs and provide cross cutting concerns to them such as: security, monitoring/metrics, and resiliency.</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.原文翻译</span></span><br><span class="line"><span class="bullet">-</span> https://spring.io/projects/spring-cloud-gateway</span><br><span class="line"><span class="bullet">-</span> 这个项目提供了一个在springmvc之上构建API网关的库。springcloudgateway旨在提供一种简单而有效的方法来路由到api，并为api提供横切关注点，比如：安全性、监控/度量和弹性。</span><br><span class="line"></span><br><span class="line"><span class="section"># 1.特性</span></span><br><span class="line"><span class="bullet">-</span> 基于springboot2.x 和 spring webFlux 和 Reactor 构建 响应式异步非阻塞IO模型</span><br><span class="line"><span class="bullet">-</span> 动态路由</span><br><span class="line"><span class="bullet">-</span> 请求过滤</span><br></pre></td></tr></table></figure><h6 id="1-开发网关动态路由"><a href="#1-开发网关动态路由" class="headerlink" title="1.开发网关动态路由"></a>1.开发网关动态路由</h6><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.翻译</span></span><br><span class="line"><span class="bullet">-</span> 网关配置有两种方式一种是快捷方式,一种是完全展开方式</span><br><span class="line"></span><br><span class="line"><span class="section"># 1.创建项目引入网关依赖</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入gateway网关依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114155735.png" alt="image-20200720175051402"></p><ul><li><strong>快捷方式配置路由</strong></li></ul><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.编写网关配置</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user_route</span><span class="comment"># 指定路由唯一标识</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:9999/</span> <span class="comment"># 指定路由服务的地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span>  <span class="comment"># 指定路由规则</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">product_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:9998/</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/product/**</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8989</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.启动gateway网关项目</span></span><br><span class="line"><span class="bullet">-</span> 直接启动报错:</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114155741.png" alt="image-20200720212535357"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 在启动日志中发现,gateway为了效率使用webflux进行异步非阻塞模型的实现,因此和原来的web包冲突,去掉原来的web即可</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114155748.png" alt="image-20200720212653494"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 再次启动成功启动</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114155753.png" alt="image-20200720213657788"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.测试网关路由转发</span></span><br><span class="line"><span class="bullet">-</span> 测试通过网关访问用户服务: http://localhost:8989/user/findOne?productId=21</span><br><span class="line"><span class="bullet">-</span> 测试通过网关访问商品服务: http://localhost:8989/product/findOne?productId=1</span><br></pre></td></tr></table></figure><ul><li><strong>java方式配置路由</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatewayConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouteLocator <span class="title">customRouteLocator</span><span class="params">(RouteLocatorBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.routes()</span><br><span class="line">                .route(<span class="string">&quot;order_route&quot;</span>, r -&gt; r.path(<span class="string">&quot;/order/**&quot;</span>)</span><br><span class="line">                        .uri(<span class="string">&quot;http://localhost:9997/&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114155759.png" alt="image-20200721103141491"></p><h6 id="2-查看网关路由规则列表"><a href="#2-查看网关路由规则列表" class="headerlink" title="2.查看网关路由规则列表"></a>2.查看网关路由规则列表</h6><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.说明</span></span><br><span class="line"><span class="bullet">-</span> gateway提供路由访问规则列表的web界面,但是默认是关闭的,如果想要查看服务路由规则可以在配置文件中开启</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span>   <span class="comment">#开启所有web端点暴露</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 访问路由管理列表地址</span><br><span class="line"><span class="bullet">-</span> http://localhost:8989/actuator/gateway/routes</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114155805.png" alt="image-20200720220647899"></p><h6 id="3-配置路由服务负载均衡"><a href="#3-配置路由服务负载均衡" class="headerlink" title="3.配置路由服务负载均衡"></a>3.配置路由服务负载均衡</h6><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.说明</span></span><br><span class="line"><span class="bullet">-</span> 现有路由配置方式,都是基于服务地址写死的路由转发,能不能根据服务名称进行路由转发同时实现负载均衡的呢?</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.动态路由以及负载均衡转发配置</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user_route</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:9999/</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://users</span><span class="comment"># lb代表转发后台服务使用负载均衡,users代表服务注册中心上的服务名</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">product_route</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:9998/</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://products</span>          <span class="comment"># lb(loadbalance)代表负载均衡转发路由</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/product/**</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启根据服务名动态获取路由</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114155815.png" alt="image-20200721110013966"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114155820.png" alt="image-20200721110040104"></p><h6 id="4-常用路由predicate-断言-验证"><a href="#4-常用路由predicate-断言-验证" class="headerlink" title="4.常用路由predicate(断言,验证)"></a>4.常用路由predicate(断言,验证)</h6><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.Gateway支持多种方式的predicate</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114155825.png" alt="image-20200721112751340"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> After=2020-07-21T11:33:33.993+08:00[Asia/Shanghai]  `指定日期之后的请求进行路由</span><br><span class="line"><span class="bullet">-</span> Before=2020-07-21T11:33:33.993+08:00[Asia/Shanghai]       `指定日期之前的请求进行路由</span><br><span class="line"><span class="bullet">-</span> Between=2017-01-20T17:42:47.789-07:00[America/Denver], 2017-01-21T17:42:47.789-07:00[America/Denver]</span><br><span class="line"><span class="bullet">-</span> Cookie=username,chenyn`基于指定cookie的请求进行路由</span><br><span class="line"><span class="bullet">-</span> Cookie=username,[A-Za-z0-9]+`基于指定cookie的请求进行路由</span><br><span class="line"><span class="code">`curl http://localhost:8989/user/findAll --cookie &quot;username=zhangsna&quot;</span></span><br><span class="line"><span class="code">- Header=X-Request-Id, \d+ ``基于请求头中的指定属性的正则匹配路由(这里全是整数)</span></span><br><span class="line"><span class="code">`curl http://localhost:8989/user/findAll -H &quot;X-Request-Id:11&quot;</span></span><br><span class="line"><span class="code">- Method=GET,POST `基于指定的请求方式请求进行路由</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">- 官方更多: https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.3.RELEASE/reference/html/#the-cookie-route-predicate-factory</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.使用predicate</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user_route</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:9999/</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://users</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">After=2020-07-21T11:39:33.993+08:00[Asia/Shanghai]</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Cookie=username,[A-Za-z0-9]+</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114155833.png" alt="image-20200721152720455"></p><h6 id="5-常用的Filter以及自定义filter"><a href="#5-常用的Filter以及自定义filter" class="headerlink" title="5.常用的Filter以及自定义filter"></a>5.常用的Filter以及自定义filter</h6><p>Route filters allow the modification of the incoming HTTP request or outgoing HTTP response in some manner. Route filters are scoped to a particular route. Spring Cloud Gateway includes many built-in GatewayFilter Factories.</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.原文翻译</span></span><br><span class="line"><span class="bullet">-</span> 官网: </span><br><span class="line"><span class="code">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.3.RELEASE/reference/html/#gatewayfilter-factories</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">- 路由过滤器允许以某种方式修改传入的HTTP请求或传出的HTTP响应。路由筛选器的作用域是特定路由。springcloudgateway包括许多内置的GatewayFilter工厂。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"># 2.作用</span></span><br><span class="line"><span class="code">- 当我们有很多个服务时，比如下图中的user-service、order-service、product-service等服务，客户端请求各个服务的Api时，每个服务都需要做相同的事情，比如鉴权、限流、日志输出等。</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114155838.png" alt="image-20200721161002001"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114155842.png" alt="image-20200721161421845"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.使用内置过滤器</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114155847.png" alt="image-20200721152425733"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 更多参加官网:https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.3.RELEASE/reference/html/#gatewayfilter-factories</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 使用方式如下:</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">product_route</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:9998/</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://products</span>     <span class="comment"># lb: 使用负载均衡策略   products代表注册中心的具体服务名</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/product/**</span></span><br><span class="line">            <span class="comment">#- After=2020-07-30T09:45:49.078+08:00[Asia/Shanghai]</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestParameter=id,34</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddResponseHeader=username,chenyn</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.使用自定义filter</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomGlobalFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;进入自定义的filter&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(exchange.getRequest().getQueryParams().get(<span class="string">&quot;username&quot;</span>)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;用户身份信息合法,放行请求继续执行!!!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;非法用户,拒绝访问!!!&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;  <span class="comment">//filter 数字越小filter越先执行</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;           <span class="comment">//-1  最先执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160211.png" alt="image-20200721164304994"></p><hr><h2 id="Config组件使用"><a href="#Config组件使用" class="headerlink" title="Config组件使用"></a>Config组件使用</h2><h3 id="什么是Config"><a href="#什么是Config" class="headerlink" title="什么是Config"></a>什么是Config</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.3.RELEASE/reference/html/#<span class="emphasis">_spring_</span>cloud<span class="emphasis">_config_</span>server</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> config(配置)又称为 统一配置中心顾名思义,就是将配置统一管理,配置统一管理的好处是在日后大规模集群部署服务应用时相同的服务配置一致,日后再修改配置只需要统一修改全部同步,不需要一个一个服务手动维护。</span><br><span class="line"></span><br><span class="line"><span class="section"># 1.统一配置中心组件流程图</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160217.png" alt="image-20200721180134903"></p><h3 id="Config-Server-开发"><a href="#Config-Server-开发" class="headerlink" title="Config Server 开发"></a>Config Server 开发</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.引入依赖</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入统一配置中心--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.开启统一配置中心服务</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configserver7878Application</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(Configserver7878Application.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160224.png" alt="image-20200721182003376"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.修改配置文件</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">7878</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">configserver</span></span><br><span class="line"><span class="meta">spring.cloud.consul.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">spring.cloud.consul.port</span>=<span class="string">8500</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160229.png" alt="image-20200721182105648"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.直接启动服务报错</span></span><br><span class="line"><span class="bullet">-</span>  没有指定远程仓库的相关配置</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160234.png" alt="image-20200721182142000"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 5.创建远程仓库</span></span><br><span class="line"><span class="bullet">-</span> github创建一个仓库</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160239.png" alt="image-20200721183541178"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 6.复制仓库地址</span></span><br><span class="line"><span class="bullet">-</span> https://github.com/chenyn-java/configservers.git</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160244.png" alt="image-20200721183727767"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 7.在统一配置中心服务中修改配置文件指向远程仓库地址</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.config.server.git.uri</span>=<span class="string">https://github.com/chenyn-java/configservers.git</span></span><br><span class="line"><span class="comment">#spring.cloud.config.server.git.username=       私有仓库访问用户名</span></span><br><span class="line"><span class="comment">#spring.cloud.config.server.git.password=私有仓库访问密码</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 8.再次启动统一配置中心</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160249.png" alt="image-20200721221656436"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 9.拉取远端配置 [<span class="string">三种方式</span>][<span class="symbol"></span>]</span></span><br><span class="line"><span class="bullet">-</span> 1. http://localhost:7878/test-xxxx.properties</span><br><span class="line"><span class="bullet">-</span> 2. http://localhost:7878/test-xxxx.json</span><br><span class="line"><span class="bullet">-</span> 3. http://localhost:7878/test-xxxx.yml</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160257.png" alt="image-20200721221951670"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 10.拉取远端配置规则</span></span><br><span class="line"><span class="bullet">-</span> label/name-profiles.yml</span><br><span class="line"><span class="code">`label   代表去那个分支获取 默认使用master分支</span></span><br><span class="line"><span class="code">`name    代表读取那个具体的配置文件文件名称</span></span><br><span class="line"><span class="code">`profile 代表读取配置文件环境</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160301.png" alt="image-20200722105313716"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 11.查看拉取配置详细信息</span></span><br><span class="line"><span class="bullet">-</span> http://localhost:7878/client/dev       [<span class="string">client:代表远端配置名称</span>][<span class="symbol">dev:代表远程配置的环境</span>]</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160305.png" alt="image-20200722105950808"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 12.指定分支和本地仓库位置</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.config.server.git.basedir</span>=<span class="string">/localresp #一定要是一个空目录,在首次会将该目录清空</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.default-label</span>=<span class="string">master   #指定使用远程仓库中那个分支中内容</span></span><br></pre></td></tr></table></figure><h3 id="Config-Client-开发"><a href="#Config-Client-开发" class="headerlink" title="Config Client 开发"></a>Config Client 开发</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.项目中引入config client依赖</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入config client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.编写配置文件</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.config.discovery.enabled</span>=<span class="string">true                #开启统一配置中心服务</span></span><br><span class="line"><span class="meta">spring.cloud.config.discovery.service-id</span>=<span class="string">configserver     #指定统一配置服务中心的服务唯一标识</span></span><br><span class="line"><span class="meta">spring.cloud.config.label</span>=<span class="string">master#指定从仓库的那个分支拉取配置</span></span><br><span class="line"><span class="meta">spring.cloud.config.name</span>=<span class="string">client#指定拉取配置文件的名称</span></span><br><span class="line"><span class="meta">spring.cloud.config.profile</span>=<span class="string">dev#指定拉取配置文件的环境</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.远程仓库创建配置文件</span></span><br><span class="line"><span class="bullet">-</span> client.properties[<span class="string">用来存放公共配置</span>][<span class="symbol"></span>]</span><br><span class="line"><span class="code">spring.application.name=configclient</span></span><br><span class="line"><span class="code">spring.cloud.consul.host=localhost</span></span><br><span class="line"><span class="code">spring.cloud.consul.port=8500</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">- client-dev.properties  [用来存放研发相关配置][注意:这里端口为例,以后不同配置分别存放]</span></span><br><span class="line"><span class="code">server.port=9099</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">- client-prod.properties[用来存放生产相关配置][]</span></span><br><span class="line"><span class="code">server.port=9098</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160312.png" alt="image-20200722102322149"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.启动客户端服务进行远程配置拉取测试</span></span><br><span class="line"><span class="bullet">-</span> 直接启动过程中发现无法启动直接报错</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160318.png" alt="image-20200722102851999">![image-20200722102901146](D:\BaiduNetdiskDownload\微服务工具集 SpringCloud &amp; Alibaba课程\springcloud资料\springcloud资料\笔记(含alibaba笔记)\SpringCloud 微服务工具集v1.1.assets\image-20200722102901146.png)</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 报错原因</span></span><br><span class="line"><span class="bullet">-</span> 项目中目前使用的是application.properties启动项目,使用这个配置文件在springboot项目启动过程中不会等待远程配置拉取,直接根据配置文件中内容启动,因此当需要注册中心,服务端口等信息时,远程配置还没有拉取到,所以直接报错</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160322.png" alt="image-20200722103435260"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 解决方案</span></span><br><span class="line"><span class="bullet">-</span> 应该在项目启动时先等待拉取远程配置,拉取远程配置成功之后再根据远程配置信息启动即可,为了完成上述要求springboot官方提供了一种解决方案,就是在使用统一配置中心时应该将微服务的配置文件名修改为bootstrap.(properties|yml),bootstrap.properties作为配置启动项目时,会优先拉取远程配置,远程配置拉取成功之后根据远程配置启动当前应用。</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160327.png" alt="image-20200722103823678"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 再次启动服务</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160333.png" alt="image-20200722103913142"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160336.png" alt="image-20200722104031932"></p><hr><h3 id="手动配置刷新"><a href="#手动配置刷新" class="headerlink" title="手动配置刷新"></a>手动配置刷新</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.说明</span></span><br><span class="line"><span class="bullet">-</span> 在生产环境中,微服务可能非常多,每次修改完远端配置之后,不可能对所有服务进行重新启动,这个时候需要让修改配置的服务能够刷新远端修改之后的配置,从而不要每次重启服务才能生效,进一步提高微服务系统的维护效率。在springcloud中也为我们提供了手动刷新配置和自动刷新配置两种策略,这里我们先试用手动配置文件刷新。</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.在config client端加入刷新暴露端点</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>=<span class="string">*            #开启所有web端点暴露  [推荐使用这种]</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160342.png" alt="image-20200730161148097"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.在需要刷新代码的类中加入刷新配置的注解</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">      log.info(<span class="string">&quot;当前加载配置文件信息为:[&#123;&#125;]&quot;</span>,name);</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160347.png" alt="image-20200722153537692"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.在远程配置中加入name并启动测试</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160352.png" alt="image-20200722153731602"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 5.启动之后直接访问</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160413.png" alt="image-20200722153806932"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 6.修改远程配置</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160448.png" alt="image-20200722203225968"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 7.修改之后在访问</span></span><br><span class="line"><span class="bullet">-</span> 发现并没有自动刷新配置?</span><br><span class="line"><span class="bullet">-</span> 必须调用刷新配置接口才能刷新配置</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160453.png" alt="image-20200722203317795"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 8.手动调用刷新配置接口</span></span><br><span class="line"><span class="bullet">-</span> curl -X POST http://localhost:9099/actuator/refresh</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160459.png" alt="image-20200722203417879"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 9.在次访问发现配置已经成功刷新</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160505.png" alt="image-20200722203452506"></p><hr><h2 id="Bus组件的使用"><a href="#Bus组件的使用" class="headerlink" title="Bus组件的使用"></a>Bus组件的使用</h2><h3 id="什么是Bus"><a href="#什么是Bus" class="headerlink" title="什么是Bus"></a>什么是Bus</h3><p>Spring Cloud Bus links nodes of a distributed system with a lightweight message broker. This can then be used to broadcast state changes (e.g. configuration changes) or other management instructions. AMQP and Kafka broker implementations are included with the project. Alternatively, any <a href="https://spring.io/projects/spring-cloud-stream">Spring Cloud Stream</a> binder found on the classpath will work out of the box as a transport.   –摘自官网</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.翻译</span></span><br><span class="line"><span class="bullet">-</span> https://spring.io/projects/spring-cloud-bus</span><br><span class="line"><span class="bullet">-</span> springcloudbus使用轻量级消息代理将分布式系统的节点连接起来。然后，可以使用它来广播状态更改（例如配置更改）或其他管理指令。AMQP和Kafka broker实现包含在项目中。或者，在类路径上找到的任何springcloudstream绑定器都可以作为传输使用。</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 通俗定义: bus称之为springcloud中消息总线,主要用来在微服务系统中实现远端配置更新时通过广播形式通知所有客户端刷新配置信息,避免手动重启服务的工作</span><br></pre></td></tr></table></figure><h3 id="实现配置刷新原理"><a href="#实现配置刷新原理" class="headerlink" title="实现配置刷新原理"></a>实现配置刷新原理</h3><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160624.png" alt="image-20200723150335451"></p><h3 id="搭建RabbitMQ服务"><a href="#搭建RabbitMQ服务" class="headerlink" title="搭建RabbitMQ服务"></a>搭建RabbitMQ服务</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.下载rabbitmq安装包 [][可以直接使用docker安装更方便]</span></span><br><span class="line"><span class="bullet">-</span> 官方安装包下载:https://www.rabbitmq.com/install-rpm.html#downloads</span><br><span class="line">[<span class="string">注意:</span>][<span class="symbol">这里安装包只能用于centos7.x系统</span>]</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160630.png" alt="image-20190925220343521"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.将rabbitmq安装包上传到linux系统中</span></span><br><span class="line"><span class="code">erlang-22.0.7-1.el7.x86_64.rpm</span></span><br><span class="line"><span class="code">rabbitmq-server-3.7.18-1.el7.noarch.rpm</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"># 2.安装Erlang依赖包</span></span><br><span class="line"><span class="code">rpm -ivh erlang-22.0.7-1.el7.x86_64.rpm</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"># 3.安装RabbitMQ安装包(需要联网)</span></span><br><span class="line"><span class="code">yum install -y rabbitmq-server-3.7.18-1.el7.noarch.rpm</span></span><br><span class="line"><span class="code">注意:默认安装完成后配置文件模板在:/usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example目录中,需要将配置文件复制到/etc/rabbitmq/目录中,并修改名称为rabbitmq.config</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"># 4.复制配置文件</span></span><br><span class="line"><span class="code">cp /usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example /etc/rabbitmq/rabbitmq.config</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"># 5.查看配置文件位置</span></span><br><span class="line"><span class="code">ls /etc/rabbitmq/rabbitmq.config</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"># 6.修改配置文件(参见下图:)</span></span><br><span class="line"><span class="code">vim /etc/rabbitmq/rabbitmq.config </span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160635.png" alt="image-20190925222230260"></p><p>将上图中配置文件中红色部分去掉<code>%%</code>,以及最后的<code>,</code>逗号 修改为下图:</p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160639.png" alt="image-20190925222329200"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 7.执行如下命令,启动rabbitmq中的插件管理</span></span><br><span class="line"><span class="code">rabbitmq-plugins enable rabbitmq_management</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">出现如下说明:</span></span><br><span class="line"><span class="code">Enabling plugins on node rabbit@localhost:</span></span><br><span class="line"><span class="code">    rabbitmq_management</span></span><br><span class="line"><span class="code">    The following plugins have been configured:</span></span><br><span class="line"><span class="code">      rabbitmq_management</span></span><br><span class="line"><span class="code">      rabbitmq_management_agent</span></span><br><span class="line"><span class="code">      rabbitmq_web_dispatch</span></span><br><span class="line"><span class="code">    Applying plugin configuration to rabbit@localhost...</span></span><br><span class="line"><span class="code">    The following plugins have been enabled:</span></span><br><span class="line"><span class="code">      rabbitmq_management</span></span><br><span class="line"><span class="code">      rabbitmq_management_agent</span></span><br><span class="line"><span class="code">      rabbitmq_web_dispatch</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    set 3 plugins.</span></span><br><span class="line"><span class="code">    Offline change; changes will take effect at broker restart.</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"># 8.启动RabbitMQ的服务</span></span><br><span class="line"><span class="code">systemctl start rabbitmq-server</span></span><br><span class="line"><span class="code">systemctl restart rabbitmq-server</span></span><br><span class="line"><span class="code">systemctl stop rabbitmq-server</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"># 9.查看服务状态(见下图:)</span></span><br><span class="line"><span class="code">systemctl status rabbitmq-server</span></span><br><span class="line"><span class="code">  ● rabbitmq-server.service - RabbitMQ broker</span></span><br><span class="line"><span class="code">     Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled)</span></span><br><span class="line"><span class="code">     Active: active (running) since 三 2019-09-25 22:26:35 CST; 7s ago</span></span><br><span class="line"><span class="code">   Main PID: 2904 (beam.smp)</span></span><br><span class="line"><span class="code">     Status: &quot;Initialized&quot;</span></span><br><span class="line"><span class="code">     CGroup: /system.slice/rabbitmq-server.service</span></span><br><span class="line"><span class="code">             ├─2904 /usr/lib64/erlang/erts-10.4.4/bin/beam.smp -W w -A 64 -MBas ageffcbf -MHas ageffcbf -</span></span><br><span class="line"><span class="code">             MBlmbcs...</span></span><br><span class="line"><span class="code">             ├─3220 erl_child_setup 32768</span></span><br><span class="line"><span class="code">             ├─3243 inet_gethost 4</span></span><br><span class="line"><span class="code">             └─3244 inet_gethost 4</span></span><br><span class="line"><span class="code">      .........</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160645.png" alt="image-20190925222743776"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 10.关闭防火墙服务</span></span><br><span class="line"><span class="code">systemctl disable firewalld</span></span><br><span class="line"><span class="code">    Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.</span></span><br><span class="line"><span class="code">    Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.</span></span><br><span class="line"><span class="code">systemctl stop firewalld   </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"># 11.访问web管理界面</span></span><br><span class="line"><span class="code">http://10.15.0.8:15672/</span></span><br></pre></td></tr></table></figure><p> <img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160653.png" alt="image-20190926194738708"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 12.登录管理界面</span></span><br><span class="line"><span class="code">username:  guest</span></span><br><span class="line"><span class="code">password:  guest</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160659.png" alt="image-20190926194954822"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 13.MQ服务搭建成功</span></span><br></pre></td></tr></table></figure><h3 id="实现自动配置刷新"><a href="#实现自动配置刷新" class="headerlink" title="实现自动配置刷新"></a>实现自动配置刷新</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.在所有项目中引入bus依赖</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入bus依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160706.png" alt="image-20200723104333906"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.配置统一配置中心连接到mq</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">localhost#连接主机</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672#连接mq端口</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">user#连接mq用户名</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">password#连接mq密码</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.远端配置中加入连接mq配置</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160712.png" alt="image-20200723105645915"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.启动统一配置中心服务</span></span><br><span class="line"><span class="bullet">-</span> 正常启动</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160717.png" alt="image-20200723111220198"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 5.启动客户端服务</span></span><br><span class="line"><span class="bullet">-</span> 加入bus组件之后客户端启动报错</span><br><span class="line"><span class="bullet">-</span> 原因springcloud中默认链接不到远程服务器不会报错,但是在使用bus消息总线时必须开启连接远程服务失败报错</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160727.png" alt="image-20200723111312496"></p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.config.fail-fast</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160733.png" alt="image-20200723111754187"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 6.修改远程配置后在配置中心服务通过执行post接口刷新配置</span></span><br><span class="line"><span class="bullet">-</span> curl -X POST http://localhost:7878/actuator/bus-refresh</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160739.png" alt="image-20200723112316476"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 7.通过上述配置就实现了配置统一刷新</span></span><br></pre></td></tr></table></figure><h3 id="指定服务刷新配置"><a href="#指定服务刷新配置" class="headerlink" title="指定服务刷新配置"></a>指定服务刷新配置</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.说明</span></span><br><span class="line"><span class="bullet">-</span> 默认情况下使用curl -X POST http://localhost:7878/actuator/bus-refresh这种方式刷新配置是全部广播形式,也就是所有的微服务都能接收到刷新配置通知,但有时我们修改的仅仅是某个服务的配置,这个时候对于其他服务的通知是多余的,因此就需要指定服务进行通知</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.指定服务刷新配置实现</span></span><br><span class="line"><span class="bullet">-</span> 指定端口刷新某个具体服务: curl -X POST http://localhost:7878/actuator/bus-refresh/configclient:9090</span><br><span class="line"><span class="bullet">-</span> 指定服务id刷新服务集群节点: curl -X POST http://localhost:7878/actuator/bus-refresh/configclient</span><br><span class="line"> [<span class="string">注意:</span>][<span class="symbol">configclient代表刷新服务的唯一标识</span>]</span><br></pre></td></tr></table></figure><h3 id="集成webhook实现自动刷新"><a href="#集成webhook实现自动刷新" class="headerlink" title="集成webhook实现自动刷新"></a>集成webhook实现自动刷新</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.配置webhooks</span></span><br><span class="line"><span class="bullet">-</span> 添加webhooks</span><br><span class="line"><span class="bullet">-</span> 在webhooks中添加刷新配置接口</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160746.png" alt="image-20200723120419412"></p><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160752.png" alt="image-20200723120947229"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.解决400错误问题</span></span><br><span class="line"><span class="bullet">-</span> 在配置中心服务端加入过滤器进行解决(springcloud中一个坑)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlFilter</span>  <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest)request;</span><br><span class="line">        HttpServletResponse httpServletResponse = (HttpServletResponse)response;</span><br><span class="line"> </span><br><span class="line">        String url = <span class="keyword">new</span> String(httpServletRequest.getRequestURI());</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//只过滤/actuator/bus-refresh请求</span></span><br><span class="line">        <span class="keyword">if</span> (!url.endsWith(<span class="string">&quot;/bus-refresh&quot;</span>)) &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//获取原始的body</span></span><br><span class="line">        String body = readAsChars(httpServletRequest);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;original body:   &quot;</span>+ body);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//使用HttpServletRequest包装原始请求达到修改post请求中body内容的目的</span></span><br><span class="line">        CustometRequestWrapper requestWrapper = <span class="keyword">new</span> CustometRequestWrapper(httpServletRequest);</span><br><span class="line"> </span><br><span class="line">        chain.doFilter(requestWrapper, response);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CustometRequestWrapper</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustometRequestWrapper</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(request);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ServletInputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">            ByteArrayInputStream byteArrayInputStream = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ServletInputStream() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> byteArrayInputStream.read() == -<span class="number">1</span> ? <span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReadListener</span><span class="params">(ReadListener readListener)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> byteArrayInputStream.read();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readAsChars</span><span class="params">(HttpServletRequest request)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"> </span><br><span class="line">        BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            br = request.getReader();</span><br><span class="line">            String str;</span><br><span class="line">            <span class="keyword">while</span> ((str = br.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sb.append(str);</span><br><span class="line">            &#125;</span><br><span class="line">            br.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != br)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IOException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloud/20210114160808.png" alt="image-20200723121203864"></p><hr>]]></content>
      
      
      <categories>
          
          <category> springCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springCloudAlibaba </tag>
            
            <tag> springCloud </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intellij IDEA 使用技巧</title>
      <link href="2021/01/13/intellij-idea-shi-yong-ji-qiao/"/>
      <url>2021/01/13/intellij-idea-shi-yong-ji-qiao/</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>本文更新于2021年1月13日</p></div><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>IDEA 全称 IntelliJ IDEA，是java编程语言开发的集成环境。IntelliJ在业界被公认为最好的java开发工具，尤其在智能代码助手、代码自动提示、重构、JavaEE支持、各类版本工具(<a href="https://baike.baidu.com/item/git/12647237">git</a>、<a href="https://baike.baidu.com/item/svn/3311103">svn</a>等)、JUnit、CVS整合、代码分析、 创新的GUI设计等方面的功能可以说是超常的。IDEA是<a href="https://baike.baidu.com/item/JetBrains/7502758">JetBrains</a>公司的产品，这家公司总部位于<a href="https://baike.baidu.com/item/%E6%8D%B7%E5%85%8B%E5%85%B1%E5%92%8C%E5%9B%BD/418555">捷克共和国</a>的首都<a href="https://baike.baidu.com/item/%E5%B8%83%E6%8B%89%E6%A0%BC/632">布拉格</a>，开发人员以严谨著称的东欧程序员为主。它的旗舰版本还支持HTML，CSS，PHP，MySQL，Python等。免费版只支持Java,Kotlin等少数语言。</p>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
            <tag> 技巧 </tag>
            
            <tag> 使用说明 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown试验</title>
      <link href="2021/01/12/markdown-shi-yan/"/>
      <url>2021/01/12/markdown-shi-yan/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo搭建个人Blog"><a href="#Hexo搭建个人Blog" class="headerlink" title="Hexo搭建个人Blog"></a>Hexo搭建个人Blog</h1><h2 id="hexo简介："><a href="#hexo简介：" class="headerlink" title="hexo简介："></a>hexo简介：</h2><p> Hexo 是一个静态博客框架，基于 Node.js，将 Markdown 文章通过渲染引擎，生成一个静态网页，再结合 Git 命令（ssh），Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="超快速度"><a href="#超快速度" class="headerlink" title="超快速度"></a>超快速度</h3><p>Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。</p><h3 id="支持-Markdown"><a href="#支持-Markdown" class="headerlink" title="支持 Markdown"></a>支持 Markdown</h3><p>Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</p><h3 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h3><p>只需一条指令即可部署到 GitHub Pages, Heroku 或其他平台。</p><h3 id="插件和可扩展性"><a href="#插件和可扩展性" class="headerlink" title="插件和可扩展性"></a>插件和可扩展性</h3><p>强大的 API 带来无限的可能，与数种模板引擎（EJS，Pug，Nunjucks）和工具（Babel，PostCSS，Less/Sass）轻易集成。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hexo框架的安装</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"># 等上一个命令完成后，在输入下面的命令</span><br><span class="line">hexo init &lt;新建文件夹的名称&gt;  #初始化文件夹</span><br><span class="line">cd &lt;新建文件夹的名称&gt;</span><br><span class="line">npm install  # 安装博客所需要的依赖文件</span><br><span class="line"># Hexo会根据配置文件渲染出一套静态页面</span><br><span class="line">hexo g</span><br><span class="line"># 将上一步渲染出的一系列文件上传至至Github Pages</span><br><span class="line">hexo d</span><br><span class="line"># 也可以直接输入此命令，直接完成渲染和上传</span><br><span class="line">hexo g -d</span><br><span class="line"></span><br><span class="line">npm install hexo-deployer-git --save    #安装git插件</span><br><span class="line"></span><br><span class="line">config添加配置</span><br><span class="line">type: git</span><br><span class="line">repo: git@github.com:Github用户名&#x2F;github用户名.github.io.git  </span><br><span class="line">&#x2F;&#x2F;也可使用https地址，如：https:&#x2F;&#x2F;github.com&#x2F;Github用户名&#x2F;Github用户名.github.io.git            </span><br><span class="line">branch: master</span><br><span class="line"></span><br><span class="line">引用本地图片：</span><br><span class="line">npm install https:&#x2F;&#x2F;github.com&#x2F;xcodebuild&#x2F;hexo-asset-image.git</span><br><span class="line"># or yarn add https:&#x2F;&#x2F;github.com&#x2F;xcodebuild&#x2F;hexo-asset-image.git</span><br><span class="line"></span><br><span class="line">配置文件_config.yml 里的post_asset_folder:这个选项设置为true</span><br></pre></td></tr></table></figure><h2 id="Front-matter："><a href="#Front-matter：" class="headerlink" title="Front-matter："></a>Front-matter：</h2><p>Front-matter 是档案最上方以 — 分隔的区域，用于指定个别档案的变数。</p><p>如果标注可选的参数，可根据自己需要添加，不用全部都写在markdown里</p><h3 id="Page-Front-matter"><a href="#Page-Front-matter" class="headerlink" title="Page Front-matter"></a>Page Front-matter</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top_img:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aside:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/markdown/20210112164941.png" alt="image-20210112164941030"></p><h3 id="Post-Front-matter"><a href="#Post-Front-matter" class="headerlink" title="Post Front-matter"></a>Post Front-matter</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top_img:</span><br><span class="line">comments:</span><br><span class="line">cover:</span><br><span class="line">toc:</span><br><span class="line">toc_number:</span><br><span class="line">copyright:</span><br><span class="line">copyright_author:</span><br><span class="line">copyright_author_href:</span><br><span class="line">copyright_url:</span><br><span class="line">copyright_info:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">aside:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/markdown/20210112165355.png" alt="image-20210112165354917"></p><h3 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo n &quot;我的第一篇文章&quot; 等价于 hexo new &quot;我的第一篇文章&quot; 还等价于 hexo new post &quot;我的第一篇文章&quot;</span><br><span class="line">hexo p 等价于 hexo publish</span><br><span class="line">hexo g 等价于 hexo generate</span><br><span class="line">hexo s等价于 hexo server</span><br><span class="line">hexo d 等价于 hexo deploy</span><br><span class="line">hexo deploy -g 等价于 hexo deploy --generate</span><br><span class="line">hexo generate -d等价于hexo generate --deploy</span><br></pre></td></tr></table></figure><h4 id="指令说明"><a href="#指令说明" class="headerlink" title="指令说明:"></a>指令说明:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server #Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。</span><br><span class="line">hexo server -s #以静态模式启动</span><br><span class="line">hexo server -p 5000 #更改访问端口 (默认端口为4000，&#39;ctrl + c&#39;关闭server)</span><br><span class="line">hexo server -i IP地址 #自定义 IP</span><br><span class="line">hexo clean #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹</span><br><span class="line">hexo g #生成静态网页 (执行 $ hexo g后会在站点根目录下生成public文件夹, hexo会将&quot;&#x2F;blog&#x2F;source&#x2F;&quot; 下面的.md后缀的文件编译为.html后缀的文件,存放在&quot;&#x2F;blog&#x2F;public&#x2F; &quot; 路径下)</span><br><span class="line">hexo d #将本地数据部署到远端服务器(如github)</span><br><span class="line">hexo init 文件夹名称 #初始化XX文件夹名称</span><br><span class="line">npm update hexo -g#升级</span><br><span class="line">npm install hexo -g#安装</span><br><span class="line">node-v #查看node.js版本号</span><br><span class="line">npm -v #查看npm版本号</span><br><span class="line">git --version #查看git版本号</span><br><span class="line">hexo -v #查看hexo版本号</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo publish [layout] &lt;title&gt;  </span><br><span class="line">#通过 &#96;publish&#96; 命令将草稿移动到 &#96;source&#x2F;_posts&#96; 文件夹,如:&#96;$ hexo publish [layout] &lt;title&gt;&#96;,草稿默认是不会显示在页面中的，可在执行时加上 &#96;--draft&#96; 参数，或是把 &#96;render_drafts&#96; 参数设为 &#96;true&#96;来预览草稿。</span><br></pre></td></tr></table></figure><hr><div class="note info flat"><p>试验markdown语法</p></div><h2 id="本地插图"><a href="#本地插图" class="headerlink" title="本地插图"></a>本地插图</h2><h2 id><a href="#" class="headerlink" title></a><img src="https://gitee.com/hnnwb/myImg/raw/master/imgs/springCloudAlibaba/20210314195708.jpg" alt="about-BY-gentle"></h2><h2 id="横线"><a href="#横线" class="headerlink" title="横线"></a>横线</h2><p>*** and—and___and—-都可以显示分割线效果</p><hr><hr><hr><h2 id="标题："><a href="#标题：" class="headerlink" title="标题："></a>标题：</h2><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><h3 id="普通文本："><a href="#普通文本：" class="headerlink" title="普通文本："></a>普通文本：</h3><p>这是普通文本</p><h3 id="单行文本："><a href="#单行文本：" class="headerlink" title="单行文本："></a>单行文本：</h3><p>​    你好，这是一行单行文本。</p><h3 id="文本块："><a href="#文本块：" class="headerlink" title="文本块："></a>文本块：</h3><p>语法1：</p><p>​    欢迎到访</p><p>​    很高兴见到你</p><p>语法2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">欢迎到访</span><br><span class="line">很高兴见到你</span><br></pre></td></tr></table></figure><h3 id="文字高亮："><a href="#文字高亮：" class="headerlink" title="文字高亮："></a>文字高亮：</h3><p><code>王先生</code> <code>Java</code></p><h3 id="换行："><a href="#换行：" class="headerlink" title="换行："></a>换行：</h3><p>直接回车不能换行，可以在上一行文本后面补两个空格，这样下一行的文本就换行了。</p><p>或者就是在两行文本直接加一个空行。</p><p>也能实现换行效果，不过这个行间距有点大。</p><h3 id="斜体、粗体、删除线："><a href="#斜体、粗体、删除线：" class="headerlink" title="斜体、粗体、删除线："></a>斜体、粗体、删除线：</h3><table><thead><tr><th align="center">语法</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center"><code>*斜体1*</code></td><td align="center"><em>斜体1</em></td></tr><tr><td align="center"><code>_斜体2_</code></td><td align="center"><em>斜体2</em></td></tr><tr><td align="center"><code>**粗体1**</code></td><td align="center"><strong>粗体1</strong></td></tr><tr><td align="center"><code>__粗体2__</code></td><td align="center"><strong>粗体2</strong></td></tr><tr><td align="center"><code>这是一个 ~~删除线~~</code></td><td align="center"><del>删除线</del></td></tr><tr><td align="center"><code>***斜粗体1***</code></td><td align="center"><strong><em>斜粗体1</em></strong></td></tr><tr><td align="center"><code>___斜粗体2___</code></td><td align="center"><strong><em>斜粗体2</em></strong></td></tr><tr><td align="center"><code>***~~斜粗体删除线1~~***</code></td><td align="center"><strong><em><del>斜粗体删除线1</del></em></strong></td></tr><tr><td align="center"><code>~~***斜粗体删除线2***~~</code></td><td align="center"><del><strong><em>斜粗体删除线2</em></strong></del></td></tr></tbody></table><p>斜体、粗体、删除线可混合使用</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>基本格式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![alt](URL title)</span><br></pre></td></tr></table></figure><p><code>alt</code> 和 <code>title</code> 即对应 <code>HTML</code> 中的 <code>alt</code> 和 <code>title</code> 属性（都可省略）：</p><ul><li><p><code>alt</code> 表示图片显示失败时的替换文本</p></li><li><p><code>title</code> 表示鼠标悬停在图片时的显示文本（注意这里要加引号）</p></li></ul><p><code>URL</code> 即图片的 <code>url</code> 地址，如果引用本仓库中的图片，直接使用<strong>相对路径</strong>就可了，如果引用其他 <code>github</code> 仓库中的图片要注意格式，即：<code>仓库地址/raw/分支名/图片路径</code>，如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;guodongxiaren&#x2F;ImageCache&#x2F;raw&#x2F;master&#x2F;Logo&#x2F;foryou.gif</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="链接外部-URL"><a href="#链接外部-URL" class="headerlink" title="链接外部 URL"></a>链接外部 URL</h3><table><thead><tr><th align="center">语法</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center"><code>【我的博客】（http://hnnwb.github.io）</code></td><td align="center"><a href="http://hnnwb.github.io/">我的博客</a></td></tr><tr><td align="center"><code>[我的博客][wbblog]</code></td><td align="center"><a href="http://hnnwb.github.io/">我的博客</a></td></tr><tr><td align="center"><code>[wbblog](http://hnnwb.github.io &quot;欢迎关注我的博客&quot;)</code></td><td align="center"><a href="http://hnnwb.github.io/" title="欢迎关注我的博客">wbblog</a></td></tr></tbody></table><p>语法 2 由两部分组成：</p><ul><li>第一部分使用两个中括号，[ ] 里的标识符（本例中 <code>zhihu</code>），可以是数字，字母等的组合，标识符上下对应就行了（<strong>姑且称之为 URL 标识符</strong>）</li><li>第二部分标记实际 <code>URL</code>。</li></ul><blockquote><p>使用 <code>URL</code> 标识符能达到复用的目的，一般把全文所有的 URL 标识符统一放在文章末尾，这样看起来比较干净。</p><blockquote><p><code>URL</code> 标识符是我起的名字，不知道是否准确。囧。。</p></blockquote></blockquote><h3 id="链接本仓库里的-URL"><a href="#链接本仓库里的-URL" class="headerlink" title="链接本仓库里的 URL"></a>链接本仓库里的 URL</h3><table><thead><tr><th align="center">语法</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center"><code>[我的简介]</code></td><td align="center">（/example/jianjie.md）</td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="图片链接"><a href="#图片链接" class="headerlink" title="图片链接"></a>图片链接</h3><p>给图片加链接的本质是混合图片显示语法和普通的链接语法。<br>普通的链接中 <code>[ ]</code> 内部是链接要显示的文本，而图片链接 <code>[ ]</code> 里面则是要显示的图片。<br>直接混合两种语法当然可以，但是十分啰嗦，为此我们可以使用 <code>URL</code> 标识符的形式。</p><table><thead><tr><th align="center">语法</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/01/08/hello-world/"/>
      <url>2021/01/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
